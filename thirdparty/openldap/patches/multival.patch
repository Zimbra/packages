--- openldap-2.4.46/doc/man/man5/slapd-mdb.5.orig	2018-08-31 21:25:36.425302202 +0000
+++ openldap-2.4.46/doc/man/man5/slapd-mdb.5	2018-08-31 21:20:15.245014918 +0000
@@ -162,6 +162,23 @@
 files should have.
 The default is 0600.
 .TP
+\fBmultival \fR{\fI<attrlist>\fR|\fBdefault\fR} \fI<integer hi>\fR,\fI<integer lo>
+Specify the number of values for which a multivalued attribute is
+stored in a separate table. Normally entries are stored as a single
+blob inside the database. When an entry gets very large or contains
+attributes with a very large number of values, modifications on that
+entry may get very slow. Splitting the large attributes out to a separate
+table can improve the performance of modification operations.
+The threshold is specified as a pair of integers. If the number of
+values exceeds the hi threshold the values will be split out. If
+a modification deletes enough values to bring an attribute below
+the lo threshold the values will be removed from the separate
+table and merged back into the main entry blob.
+The threshold can be set for a specific list of attributes, or
+the default can be configured for all other attributes.
+The default value for both hi and lo thresholds is UINT_MAX, which keeps
+all attributes in the main blob.
+.TP
 .BI rtxnsize \ <entries>
 Specify the maximum number of entries to process in a single read
 transaction when executing a large search. Long-lived read transactions
--- openldap-2.4.46/servers/slapd/slap.h.orig	2018-08-31 21:25:51.085135455 +0000
+++ openldap-2.4.46/servers/slapd/slap.h	2018-08-31 21:20:08.589093362 +0000
@@ -1163,10 +1163,11 @@
 #define SLAP_ATTR_DONT_FREE_DATA	0x4U
 #define SLAP_ATTR_DONT_FREE_VALS	0x8U
 #define	SLAP_ATTR_SORTED_VALS		0x10U	/* values are sorted */
+#define	SLAP_ATTR_BIG_MULTI		0x20U	/* for backends */
 
 /* These flags persist across an attr_dup() */
 #define	SLAP_ATTR_PERSISTENT_FLAGS \
-	SLAP_ATTR_SORTED_VALS
+	(SLAP_ATTR_SORTED_VALS|SLAP_ATTR_BIG_MULTI)
 
 	Attribute		*a_next;
 #ifdef LDAP_COMP_MATCH
--- openldap-2.4.46/servers/slapd/back-mdb/attr.c.orig	2018-08-31 21:35:03.686948796 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/attr.c	2018-08-31 21:22:45.599260954 +0000
@@ -122,6 +122,8 @@
 	for ( i=0; i<mdb->mi_nattrs; i++ ) {
 		if ( mdb->mi_attrs[i]->ai_dbi )	/* already open */
 			continue;
+		if ( !( mdb->mi_attrs[i]->ai_indexmask || mdb->mi_attrs[i]->ai_newmask ))   /* not an index record */
+			continue;
 		rc = mdb_dbi_open( txn, mdb->mi_attrs[i]->ai_desc->ad_type->sat_cname.bv_val,
 			flags, &mdb->mi_attrs[i]->ai_dbi );
 		if ( rc ) {
@@ -382,6 +384,8 @@
 		a->ai_root = NULL;
 		a->ai_desc = ad;
 		a->ai_dbi = 0;
+		a->ai_multi_hi = UINT_MAX;
+		a->ai_multi_lo = UINT_MAX;
 
 		if ( mdb->mi_flags & MDB_IS_OPEN ) {
 			a->ai_indexmask = 0;
@@ -419,8 +423,16 @@
 #endif
 		rc = ainfo_insert( mdb, a );
 		if( rc ) {
+			AttrInfo *b = mdb_attr_mask( mdb, ad );
+			/* If this is just a multival record, reuse it for index info */
+			if ( !( b->ai_indexmask || b->ai_newmask ) && b->ai_multi_lo < UINT_MAX ) {
+				b->ai_indexmask = a->ai_indexmask;
+				b->ai_newmask = a->ai_newmask;
+				ch_free( a );
+				rc = 0;
+				continue;
+			}
 			if ( mdb->mi_flags & MDB_IS_OPEN ) {
-				AttrInfo *b = mdb_attr_mask( mdb, ad );
 				/* If there is already an index defined for this attribute
 				 * it must be replaced. Otherwise we end up with multiple 
 				 * olcIndex values for the same attribute */
@@ -490,7 +502,169 @@
 		mdb_attr_index_unparser( &aidef, bva );
 	}
 	for ( i=0; i<mdb->mi_nattrs; i++ )
-		mdb_attr_index_unparser( mdb->mi_attrs[i], bva );
+		if ( mdb->mi_attrs[i]->ai_indexmask )
+			mdb_attr_index_unparser( mdb->mi_attrs[i], bva );
+}
+
+int
+mdb_attr_multi_config(
+	struct mdb_info	*mdb,
+	const char		*fname,
+	int			lineno,
+	int			argc,
+	char		**argv,
+	struct		config_reply_s *c_reply)
+{
+	int rc = 0;
+	int	i;
+	unsigned hi,lo;
+	char **attrs, *next, *s;
+
+	attrs = ldap_str2charray( argv[0], "," );
+
+	if( attrs == NULL ) {
+		fprintf( stderr, "%s: line %d: "
+			"no attributes specified: %s\n",
+			fname, lineno, argv[0] );
+		return LDAP_PARAM_ERROR;
+	}
+
+	hi = strtoul( argv[1], &next, 10 );
+	if ( next == argv[1] || next[0] != ',' )
+		goto badval;
+	s = next+1;
+	lo = strtoul( s, &next, 10 );
+	if ( next == s || next[0] != '\0' )
+		goto badval;
+
+	if ( lo > hi ) {
+badval:
+		snprintf(c_reply->msg, sizeof(c_reply->msg),
+			"invalid hi/lo thresholds" );
+		fprintf( stderr, "%s: line %d: %s\n",
+			fname, lineno, c_reply->msg );
+		return LDAP_PARAM_ERROR;
+	}
+
+	for ( i = 0; attrs[i] != NULL; i++ ) {
+		AttrInfo	*a;
+		AttributeDescription *ad;
+		const char *text;
+
+		if( strcasecmp( attrs[i], "default" ) == 0 ) {
+			mdb->mi_multi_hi = hi;
+			mdb->mi_multi_lo = lo;
+			continue;
+		}
+
+		ad = NULL;
+		rc = slap_str2ad( attrs[i], &ad, &text );
+
+		if( rc != LDAP_SUCCESS ) {
+			if ( c_reply )
+			{
+				snprintf(c_reply->msg, sizeof(c_reply->msg),
+					"multival attribute \"%s\" undefined",
+					attrs[i] );
+
+				fprintf( stderr, "%s: line %d: %s\n",
+					fname, lineno, c_reply->msg );
+			}
+fail:
+			goto done;
+		}
+
+		a = (AttrInfo *) ch_calloc( 1, sizeof(AttrInfo) );
+
+		a->ai_desc = ad;
+		a->ai_multi_hi = hi;
+		a->ai_multi_lo = lo;
+
+		rc = ainfo_insert( mdb, a );
+		if( rc ) {
+			AttrInfo *b = mdb_attr_mask( mdb, ad );
+			/* If this is just an index record, reuse it for multival info */
+			if ( b->ai_multi_lo == UINT_MAX ) {
+				b->ai_multi_hi = a->ai_multi_hi;
+				b->ai_multi_lo = a->ai_multi_lo;
+				ch_free( a );
+				rc = 0;
+				continue;
+			}
+			if (c_reply) {
+				snprintf(c_reply->msg, sizeof(c_reply->msg),
+					"duplicate multival definition for attr \"%s\"",
+					attrs[i] );
+				fprintf( stderr, "%s: line %d: %s\n",
+					fname, lineno, c_reply->msg );
+			}
+
+			rc = LDAP_PARAM_ERROR;
+			goto done;
+		}
+	}
+
+done:
+	ldap_charray_free( attrs );
+
+	return rc;
+}
+
+static int
+mdb_attr_multi_unparser( void *v1, void *v2 )
+{
+	AttrInfo *ai = v1;
+	BerVarray *bva = v2;
+	struct berval bv;
+	char digbuf[sizeof("4294967296,4294967296")];
+	char *ptr;
+
+	bv.bv_len = snprintf( digbuf, sizeof(digbuf), "%u,%u",
+		ai->ai_multi_hi, ai->ai_multi_lo );
+	if ( bv.bv_len ) {
+		bv.bv_len += ai->ai_desc->ad_cname.bv_len + 1;
+		ptr = ch_malloc( bv.bv_len+1 );
+		bv.bv_val = lutil_strcopy( ptr, ai->ai_desc->ad_cname.bv_val );
+		*bv.bv_val++ = ' ';
+		strcpy(bv.bv_val, digbuf);
+		bv.bv_val = ptr;
+		ber_bvarray_add( bva, &bv );
+	}
+	return 0;
+}
+
+void
+mdb_attr_multi_unparse( struct mdb_info *mdb, BerVarray *bva )
+{
+	int i;
+
+	if ( mdb->mi_multi_hi < UINT_MAX ) {
+		aidef.ai_multi_hi = mdb->mi_multi_hi;
+		aidef.ai_multi_lo = mdb->mi_multi_lo;
+		mdb_attr_multi_unparser( &aidef, bva );
+	}
+	for ( i=0; i<mdb->mi_nattrs; i++ )
+		if ( mdb->mi_attrs[i]->ai_multi_hi < UINT_MAX )
+			mdb_attr_multi_unparser( mdb->mi_attrs[i], bva );
+}
+
+void
+mdb_attr_multi_thresh( struct mdb_info *mdb, AttributeDescription *ad, unsigned *hi, unsigned *lo )
+{
+	AttrInfo *ai = mdb_attr_mask( mdb, ad );
+	if ( ai && ai->ai_multi_hi < UINT_MAX )
+	{
+		if ( hi )
+			*hi = ai->ai_multi_hi;
+		if ( lo )
+			*lo = ai->ai_multi_lo;
+	} else
+	{
+		if ( hi )
+			*hi = mdb->mi_multi_hi;
+		if ( lo )
+			*lo = mdb->mi_multi_lo;
+	}
 }
 
 void
@@ -532,12 +706,18 @@
 
 	for ( i=0; i<mdb->mi_nattrs; i++ ) {
 		if ( mdb->mi_attrs[i]->ai_indexmask & MDB_INDEX_DELETING ) {
-			int j;
-			mdb_attr_info_free( mdb->mi_attrs[i] );
-			mdb->mi_nattrs--;
-			for (j=i; j<mdb->mi_nattrs; j++)
-				mdb->mi_attrs[j] = mdb->mi_attrs[j+1];
-			i--;
+			/* if this is also a multival rec, just clear index */
+			if ( mdb->mi_attrs[i]->ai_multi_lo < UINT_MAX ) {
+				mdb->mi_attrs[i]->ai_indexmask = 0;
+				mdb->mi_attrs[i]->ai_newmask = 0;
+			} else {
+				int j;
+				mdb_attr_info_free( mdb->mi_attrs[i] );
+				mdb->mi_nattrs--;
+				for (j=i; j<mdb->mi_nattrs; j++)
+					mdb->mi_attrs[j] = mdb->mi_attrs[j+1];
+				i--;
+			}
 		}
 	}
 }
--- openldap-2.4.46/servers/slapd/back-mdb/back-mdb.h.orig	2018-08-31 21:34:38.687225761 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/back-mdb.h	2018-08-31 21:20:15.249014871 +0000
@@ -32,7 +32,8 @@
 #define MDB_AD2ID		0
 #define MDB_DN2ID		1
 #define MDB_ID2ENTRY	2
-#define MDB_NDB			3
+#define MDB_ID2VAL		3
+#define MDB_NDB			4
 
 /* The default search IDL stack cache depth */
 #define DEFAULT_SEARCH_STACK_DEPTH	16
@@ -84,6 +85,7 @@
 	int			mi_txn_cp;
 	unsigned	mi_txn_cp_min;
 	unsigned	mi_txn_cp_kbyte;
+
 	struct re_s		*mi_txn_cp_task;
 	struct re_s		*mi_index_task;
 
@@ -104,6 +106,13 @@
 
 	int mi_numads;
 
+	unsigned	mi_multi_hi;
+		/* more than this many values in an attr goes
+		 * into a separate DB */
+	unsigned	mi_multi_lo;
+		/* less than this many values in an attr goes
+		 * back into main blob */
+
 	MDB_dbi	mi_dbis[MDB_NDB];
 	AttributeDescription *mi_ads[MDB_MAXADS];
 	int mi_adxs[MDB_MAXADS];
@@ -112,6 +121,7 @@
 #define mi_id2entry	mi_dbis[MDB_ID2ENTRY]
 #define mi_dn2id	mi_dbis[MDB_DN2ID]
 #define mi_ad2id	mi_dbis[MDB_AD2ID]
+#define mi_id2val	mi_dbis[MDB_ID2VAL]
 
 typedef struct mdb_op_info {
 	OpExtra		moi_oe;
@@ -122,24 +132,6 @@
 #define MOI_READER	0x01
 #define MOI_FREEIT	0x02
 
-/* Copy an ID "src" to pointer "dst" in big-endian byte order */
-#define MDB_ID2DISK( src, dst )	\
-	do { int i0; ID tmp; unsigned char *_p;	\
-		tmp = (src); _p = (unsigned char *)(dst);	\
-		for ( i0=sizeof(ID)-1; i0>=0; i0-- ) {	\
-			_p[i0] = tmp & 0xff; tmp >>= 8;	\
-		} \
-	} while(0)
-
-/* Copy a pointer "src" to a pointer "dst" from big-endian to native order */
-#define MDB_DISK2ID( src, dst ) \
-	do { unsigned i0; ID tmp = 0; unsigned char *_p;	\
-		_p = (unsigned char *)(src);	\
-		for ( i0=0; i0<sizeof(ID); i0++ ) {	\
-			tmp <<= 8; tmp |= *_p++;	\
-		} *(dst) = tmp; \
-	} while (0)
-
 LDAP_END_DECL
 
 /* for the cache of attribute information (which are indexed, etc.) */
@@ -156,6 +148,8 @@
 	MDB_cursor *ai_cursor;	/* for tools */
 	int ai_idx;	/* position in AI array */
 	MDB_dbi ai_dbi;
+	unsigned ai_multi_hi;
+	unsigned ai_multi_lo;
 } AttrInfo;
 
 /* These flags must not clash with SLAP_INDEX flags or ops in slap.h! */
--- openldap-2.4.46/servers/slapd/back-mdb/config.c.orig	2018-08-31 21:34:31.111309728 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/config.c	2018-08-31 21:22:48.499227430 +0000
@@ -39,7 +39,8 @@
 	MDB_MAXREADERS,
 	MDB_MAXSIZE,
 	MDB_MODE,
-	MDB_SSTACK
+	MDB_SSTACK,
+	MDB_MULTIVAL,
 };
 
 static ConfigTable mdbcfg[] = {
@@ -78,6 +79,11 @@
 		mdb_cf_gen, "( OLcfgDbAt:0.3 NAME 'olcDbMode' "
 		"DESC 'Unix permissions of database files' "
 		"SYNTAX OMsDirectoryString SINGLE-VALUE )", NULL, NULL },
+	{ "multival", "attr> <hi,lo", 3, 3, 0, ARG_MAGIC|MDB_MULTIVAL,
+		mdb_cf_gen,
+		"( OLcfgDbAt:12.6 NAME 'olcDbMultival' "
+		"DESC 'Hi/Lo thresholds for splitting multivalued attr out of main blob' "
+		"SYNTAX OMsDirectoryString )", NULL, NULL },
 	{ "rtxnsize", "entries", 2, 2, 0, ARG_UINT|ARG_OFFSET,
 		(void *)offsetof(struct mdb_info, mi_rtxn_size),
 		"( OLcfgDbAt:12.5 NAME 'olcDbRtxnSize' "
@@ -100,7 +106,8 @@
 		"MUST olcDbDirectory "
 		"MAY ( olcDbCheckpoint $ olcDbEnvFlags $ "
 		"olcDbNoSync $ olcDbIndex $ olcDbMaxReaders $ olcDbMaxSize $ "
-		"olcDbMode $ olcDbSearchStack $ olcDbRtxnSize ) )",
+		"olcDbMode $ olcDbSearchStack $ olcDbRtxnSize $ "
+		"olcDbMultival ) )",
 		 	Cft_Database, mdbcfg },
 	{ NULL, 0, NULL }
 };
@@ -341,6 +348,11 @@
 		case MDB_MAXSIZE:
 			c->value_ulong = mdb->mi_mapsize;
 			break;
+
+		case MDB_MULTIVAL:
+			mdb_attr_multi_unparse( mdb, &c->rvalue_vals );
+			if ( !c->rvalue_vals ) rc = 1;
+			break;
 		}
 		return rc;
 	} else if ( c->op == LDAP_MOD_DELETE ) {
@@ -473,6 +486,61 @@
 				}
 			}
 			break;
+		case MDB_MULTIVAL:
+			if ( c->valx == -1 ) {
+				int i;
+
+				/* delete all */
+				for ( i = 0; i < mdb->mi_nattrs; i++ ) {
+					mdb->mi_attrs[i]->ai_multi_hi = UINT_MAX;
+					mdb->mi_attrs[i]->ai_multi_lo = UINT_MAX;
+				}
+				mdb->mi_multi_hi = UINT_MAX;
+				mdb->mi_multi_lo = UINT_MAX;
+
+			} else {
+				struct berval bv, def = BER_BVC("default");
+				char *ptr;
+
+				for (ptr = c->line; !isspace( (unsigned char) *ptr ); ptr++);
+
+				bv.bv_val = c->line;
+				bv.bv_len = ptr - bv.bv_val;
+				if ( bvmatch( &bv, &def )) {
+					mdb->mi_multi_hi = UINT_MAX;
+					mdb->mi_multi_lo = UINT_MAX;
+
+				} else {
+					int i;
+					char **attrs;
+					char sep;
+
+					sep = bv.bv_val[ bv.bv_len ];
+					bv.bv_val[ bv.bv_len ] = '\0';
+					attrs = ldap_str2charray( bv.bv_val, "," );
+
+					for ( i = 0; attrs[ i ]; i++ ) {
+						AttributeDescription *ad = NULL;
+						const char *text;
+						AttrInfo *ai;
+
+						slap_str2ad( attrs[ i ], &ad, &text );
+						/* if we got here... */
+						assert( ad != NULL );
+
+						ai = mdb_attr_mask( mdb, ad );
+						/* if we got here... */
+						assert( ai != NULL );
+
+						ai->ai_multi_hi = UINT_MAX;
+						ai->ai_multi_lo = UINT_MAX;
+					}
+
+					bv.bv_val[ bv.bv_len ] = sep;
+					ldap_charray_free( attrs );
+				}
+			}
+			break;
 		}
 		return rc;
 	}
@@ -678,6 +746,12 @@
 		}
 		break;
 
+	case MDB_MULTIVAL:
+		rc = mdb_attr_multi_config( mdb, c->fname, c->lineno,
+			c->argc - 1, &c->argv[1], &c->reply);
+
+		if( rc != LDAP_SUCCESS ) return 1;
+		break;
 	}
 	return 0;
 }
--- openldap-2.4.46/servers/slapd/back-mdb/id2entry.c.orig	2018-08-31 21:34:57.455017822 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/id2entry.c	2018-08-31 21:20:15.253014824 +0000
@@ -23,10 +23,12 @@
 #include "back-mdb.h"
 
 typedef struct Ecount {
-	ber_len_t len;
+	ber_len_t len;	/* total entry size */
+	ber_len_t dlen;	/* contiguous data size */
 	int nattrs;
 	int nvals;
 	int offset;
+	Attribute *multi;
 } Ecount;
 
 static int mdb_entry_partsize(struct mdb_info *mdb, MDB_txn *txn, Entry *e,
@@ -35,6 +37,229 @@
 	Ecount *ec);
 static Entry *mdb_entry_alloc( Operation *op, int nattrs, int nvals );
 
+#define ID2VKSZ	(sizeof(ID)+2)
+
+int
+mdb_id2v_compare(
+	const MDB_val *usrkey,
+	const MDB_val *curkey
+)
+{
+	unsigned short *uv, *cv;
+	ID ui, ci;
+	int rc;
+
+	memcpy(&ui, usrkey->mv_data, sizeof(ID));
+	memcpy(&ci, curkey->mv_data, sizeof(ID));
+	if (ui < ci)
+		return -1;
+	if (ui > ci)
+		return 1;
+	uv = usrkey->mv_data;
+	cv = curkey->mv_data;
+	return uv[sizeof(ID)/2] - cv[sizeof(ID)/2];
+}
+
+/* usrkey[0] is the key in DB format, as described at mdb_mval_put.
+ * usrkey[1] is the value we'll actually match against.
+ * usrkey[2] is the attributeDescription for this value.
+ */
+int
+mdb_id2v_dupsort(
+	const MDB_val *usrkey,
+	const MDB_val *curkey
+)
+{
+	AttributeDescription *ad = usrkey[2].mv_data;
+	struct berval bv1, bv2;
+	int rc, match, olen;
+	unsigned short s;
+	char *ptr;
+
+	ptr = curkey->mv_data + curkey->mv_size - 2;
+	memcpy(&s, ptr, 2);
+	bv2.bv_val = curkey->mv_data;
+	bv2.bv_len = curkey->mv_size - 3;
+	if (s)
+		bv2.bv_len -= (s+1);
+
+	bv1.bv_val = usrkey[1].mv_data;
+	bv1.bv_len = usrkey[1].mv_size;
+
+	if (ad) {
+		MatchingRule *mr = ad->ad_type->sat_equality;
+		rc = mr->smr_match(&match, SLAP_MR_EQUALITY
+		| SLAP_MR_VALUE_OF_ASSERTION_SYNTAX
+		| SLAP_MR_ASSERTED_VALUE_NORMALIZED_MATCH
+		| SLAP_MR_ATTRIBUTE_VALUE_NORMALIZED_MATCH,
+		ad->ad_type->sat_syntax, mr, &bv1, &bv2);
+	} else {
+		match = ber_bvcmp(&bv1, &bv2);
+	}
+
+	return match;
+}
+
+/* Values are stored as
+ * [normalized-value NUL ] original-value NUL 2-byte-len
+ * The trailing 2-byte-len is zero if there is no normalized value.
+ * Otherwise, it is the length of the original-value.
+ */
+int mdb_mval_put(Operation *op, MDB_cursor *mc, ID id, Attribute *a)
+{
+	struct mdb_info *mdb = (struct mdb_info *) op->o_bd->be_private;
+	MDB_val key, data[3];
+	char *buf;
+	char ivk[ID2VKSZ];
+	unsigned i;
+	unsigned short s;
+	int rc, len;
+
+	memcpy(ivk, &id, sizeof(id));
+	s = mdb->mi_adxs[a->a_desc->ad_index];
+	memcpy(ivk+sizeof(ID), &s, 2);
+	key.mv_data = &ivk;
+	key.mv_size = sizeof(ivk);
+	if ((a->a_desc->ad_type->sat_flags & SLAP_AT_ORDERED) || a->a_desc == slap_schema.si_ad_objectClass)
+		data[2].mv_data = NULL;
+	else
+		data[2].mv_data = a->a_desc;
+
+	for (i=0; i<a->a_numvals; i++) {
+		len = a->a_nvals[i].bv_len + 1 + 2;
+		if (a->a_nvals != a->a_vals) {
+			len += a->a_vals[i].bv_len + 1;
+			data[1].mv_data = a->a_nvals[i].bv_val;
+			data[1].mv_size = a->a_nvals[i].bv_len;
+		} else {
+			data[1].mv_data = a->a_vals[i].bv_val;
+			data[1].mv_size = a->a_vals[i].bv_len;
+		}
+		data[0].mv_size = len;
+		buf = op->o_tmpalloc( len, op->o_tmpmemctx );
+		data[0].mv_data = buf;
+		memcpy(buf, a->a_nvals[i].bv_val, a->a_nvals[i].bv_len);
+		buf += a->a_nvals[i].bv_len;
+		*buf++ = 0;
+		if (a->a_nvals != a->a_vals) {
+			s = a->a_vals[i].bv_len;
+			memcpy(buf, a->a_vals[i].bv_val, a->a_vals[i].bv_len);
+			buf += a->a_vals[i].bv_len;
+			*buf++ = 0;
+			memcpy(buf, &s, 2);
+		} else {
+			*buf++ = 0;
+			*buf++ = 0;
+		}
+		rc = mdb_cursor_put(mc, &key, data, 0);
+		op->o_tmpfree( data[0].mv_data, op->o_tmpmemctx );
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+int mdb_mval_del(Operation *op, MDB_cursor *mc, ID id, Attribute *a)
+{
+	struct mdb_info *mdb = (struct mdb_info *) op->o_bd->be_private;
+	MDB_val key, data[3];
+	char *ptr;
+	char ivk[ID2VKSZ];
+	unsigned i;
+	int rc;
+	unsigned short s;
+
+	memcpy(ivk, &id, sizeof(id));
+	s = mdb->mi_adxs[a->a_desc->ad_index];
+	memcpy(ivk+sizeof(ID), &s, 2);
+	key.mv_data = &ivk;
+	key.mv_size = sizeof(ivk);
+	if ((a->a_desc->ad_type->sat_flags & SLAP_AT_ORDERED) || a->a_desc == slap_schema.si_ad_objectClass)
+		data[2].mv_data = NULL;
+	else
+		data[2].mv_data = a->a_desc;
+
+	if (a->a_numvals) {
+		for (i=0; i<a->a_numvals; i++) {
+			data[0].mv_data = a->a_nvals[i].bv_val;
+			data[0].mv_size = a->a_nvals[i].bv_len+1;
+			if (a->a_nvals != a->a_vals) {
+				data[1].mv_data = a->a_nvals[i].bv_val;
+				data[1].mv_size = a->a_nvals[i].bv_len;
+			} else {
+				data[1].mv_data = a->a_vals[i].bv_val;
+				data[1].mv_size = a->a_vals[i].bv_len;
+			}
+			rc = mdb_cursor_get(mc, &key, data, MDB_GET_BOTH_RANGE);
+			if (rc)
+				return rc;
+			rc = mdb_cursor_del(mc, 0);
+			if (rc)
+				return rc;
+		}
+	} else {
+		rc = mdb_cursor_get(mc, &key, data, MDB_SET);
+		if (rc)
+			return rc;
+		rc = mdb_cursor_del(mc, MDB_NODUPDATA);
+	}
+	return rc;
+}
+
+static int mdb_mval_get(Operation *op, MDB_cursor *mc, ID id, Attribute *a, int have_nvals)
+{
+	struct mdb_info *mdb = (struct mdb_info *) op->o_bd->be_private;
+	MDB_val key, data[3];
+	char *ptr;
+	char ivk[ID2VKSZ];
+	unsigned i;
+	int rc = 0;
+	unsigned short s;
+
+	memcpy(ivk, &id, sizeof(id));
+	s = mdb->mi_adxs[a->a_desc->ad_index];
+	memcpy(ivk+sizeof(ID), &s, 2);
+	key.mv_data = &ivk;
+	key.mv_size = sizeof(ivk);
+
+	/* not needed */
+	if ((a->a_desc->ad_type->sat_flags & SLAP_AT_ORDERED) || a->a_desc == slap_schema.si_ad_objectClass)
+		data[2].mv_data = NULL;
+	else
+		data[2].mv_data = a->a_desc;
+
+	if (have_nvals)
+		a->a_nvals = a->a_vals + a->a_numvals + 1;
+	else
+		a->a_nvals = a->a_vals;
+	for (i=0; i<a->a_numvals; i++) {
+		if (!i)
+			rc = mdb_cursor_get(mc, &key, data, MDB_SET);
+		else
+			rc = mdb_cursor_get(mc, &key, data, MDB_NEXT_DUP);
+		if (rc)
+			break;
+		ptr = (char*)data[0].mv_data + data[0].mv_size - 2;
+		memcpy(&s, ptr, 2);
+		if (have_nvals) {
+			a->a_nvals[i].bv_val = data[0].mv_data;
+			a->a_vals[i].bv_len = s;
+			a->a_vals[i].bv_val = ptr - a->a_vals[i].bv_len - 1;
+			a->a_nvals[i].bv_len = a->a_vals[i].bv_val - a->a_nvals[i].bv_val - 1;
+		} else {
+			assert(!s);
+			a->a_vals[i].bv_val = data[0].mv_data;
+			a->a_vals[i].bv_len = data[0].mv_size - 3;
+		}
+	}
+	a->a_numvals = i;
+	BER_BVZERO(&a->a_vals[i]);
+	if (have_nvals) {
+		BER_BVZERO(&a->a_nvals[i]);
+	}
+	return rc;
+}
+
 #define ADD_FLAGS	(MDB_NOOVERWRITE|MDB_APPEND)
 
 static int mdb_id2entry_put(
@@ -47,7 +272,7 @@
 	struct mdb_info *mdb = (struct mdb_info *) op->o_bd->be_private;
 	Ecount ec;
 	MDB_val key, data;
-	int rc, prev_ads = mdb->mi_numads;
+	int rc, prev_ads = mdb->mi_numads, adding = flag;
 
 	/* We only store rdns, and they go in the dn2id database. */
 
@@ -64,7 +289,7 @@
 		flag &= ~MDB_APPEND;
 
 again:
-	data.mv_size = ec.len;
+	data.mv_size = ec.dlen;
 	if ( mc )
 		rc = mdb_cursor_put( mc, &key, &data, flag );
 	else
@@ -73,6 +298,31 @@
 		rc = mdb_entry_encode( op, e, &data, &ec );
 		if( rc != LDAP_SUCCESS )
 			goto fail;
+		/* Handle adds of large multi-valued attrs here.
+		 * Modifies handle them directly.
+		 */
+		if (adding && ec.multi) {
+			MDB_cursor *mvc;
+			Attribute *a;
+			rc = mdb_cursor_open( txn, mdb->mi_dbis[MDB_ID2VAL], &mvc );
+			if( !rc ) {
+				for ( a = ec.multi; a; a=a->a_next ) {
+					if (!(a->a_flags & SLAP_ATTR_BIG_MULTI))
+						continue;
+					rc = mdb_mval_put( op, mvc, e->e_id, a );
+					if( rc )
+						break;
+				}
+				mdb_cursor_close( mvc );
+			}
+			if ( rc ) {
+				Debug( LDAP_DEBUG_ANY,
+					"mdb_id2entry_put: mdb_mval_put failed: %s(%d) \"%s\"\n",
+					mdb_strerror(rc), rc,
+					e->e_nname.bv_val );
+				return LDAP_OTHER;
+			}
+		}
 	}
 	if (rc) {
 		/* Was there a hole from slapadd? */
@@ -92,10 +342,7 @@
 
 /*
  * This routine adds (or updates) an entry on disk.
- * The cache should be already be updated.
  */
-
-
 int mdb_id2entry_add(
 	Operation *op,
 	MDB_txn *txn,
@@ -187,7 +434,7 @@
 		rc = MDB_NOTFOUND;
 	if ( rc ) return rc;
 
-	rc = mdb_entry_decode( op, mdb_cursor_txn( mc ), &data, e );
+	rc = mdb_entry_decode( op, mdb_cursor_txn( mc ), &data, id, e );
 	if ( rc ) return rc;
 
 	(*e)->e_id = id;
@@ -205,6 +452,7 @@
 	struct mdb_info *mdb = (struct mdb_info *) be->be_private;
 	MDB_dbi dbi = mdb->mi_id2entry;
 	MDB_val key;
+	MDB_cursor *mvc;
 	int rc;
 
 	key.mv_data = &e->e_id;
@@ -212,7 +460,29 @@
 
 	/* delete from database */
 	rc = mdb_del( tid, dbi, &key, NULL );
+	if (rc)
+		return rc;
+	rc = mdb_cursor_open( tid, mdb->mi_dbis[MDB_ID2VAL], &mvc );
+	if (rc)
+		return rc;
 
+	rc = mdb_cursor_get( mvc, &key, NULL, MDB_SET_RANGE );
+	if (rc) {
+		if (rc == MDB_NOTFOUND)
+			rc = MDB_SUCCESS;
+		return rc;
+	}
+	while (*(ID *)key.mv_data == e->e_id ) {
+		rc = mdb_cursor_del( mvc, MDB_NODUPDATA );
+		if (rc)
+			return rc;
+		rc = mdb_cursor_get( mvc, &key, NULL, MDB_GET_CURRENT );
+		if (rc) {
+			if (rc == MDB_NOTFOUND)
+				rc = MDB_SUCCESS;
+			break;
+		}
+	}
 	return rc;
 }
 
@@ -528,11 +798,14 @@
 static int mdb_entry_partsize(struct mdb_info *mdb, MDB_txn *txn, Entry *e,
 	Ecount *eh)
 {
-	ber_len_t len;
-	int i, nat = 0, nval = 0, nnval = 0;
+	ber_len_t len, dlen;
+	int i, nat = 0, nval = 0, nnval = 0, doff = 0;
 	Attribute *a;
+	unsigned hi;
 
+	eh->multi = NULL;
 	len = 4*sizeof(int);	/* nattrs, nvals, ocflags, offset */
+	dlen = len;
 	for (a=e->e_attrs; a; a=a->a_next) {
 		/* For AttributeDesc, we only store the attr index */
 		nat++;
@@ -547,46 +820,75 @@
 				return rc;
 		}
 		len += 2*sizeof(int);	/* AD index, numvals */
+		dlen += 2*sizeof(int);
 		nval += a->a_numvals + 1;	/* empty berval at end */
+		mdb_attr_multi_thresh( mdb, a->a_desc, &hi, NULL );
+		if (a->a_numvals > hi)
+			a->a_flags |= SLAP_ATTR_BIG_MULTI;
+		if (a->a_flags & SLAP_ATTR_BIG_MULTI)
+			doff += a->a_numvals;
 		for (i=0; i<a->a_numvals; i++) {
-			len += a->a_vals[i].bv_len + 1 + sizeof(int);	/* len */
+			int alen = a->a_vals[i].bv_len + 1 + sizeof(int);	/* len */
+			len += alen;
+			if (a->a_flags & SLAP_ATTR_BIG_MULTI) {
+				if (!eh->multi)
+					eh->multi = a;
+			} else {
+				dlen += alen;
+			}
 		}
 		if (a->a_nvals != a->a_vals) {
 			nval += a->a_numvals + 1;
 			nnval++;
+			if (a->a_flags & SLAP_ATTR_BIG_MULTI)
+				doff += a->a_numvals;
 			for (i=0; i<a->a_numvals; i++) {
-				len += a->a_nvals[i].bv_len + 1 + sizeof(int);;
+				int alen = a->a_nvals[i].bv_len + 1 + sizeof(int);
+				len += alen;
+				if (!(a->a_flags & SLAP_ATTR_BIG_MULTI))
+					dlen += alen;
 			}
 		}
 	}
 	/* padding */
-	len = (len + sizeof(ID)-1) & ~(sizeof(ID)-1);
+	dlen = (dlen + sizeof(ID)-1) & ~(sizeof(ID)-1);
 	eh->len = len;
+	eh->dlen = dlen;
 	eh->nattrs = nat;
 	eh->nvals = nval;
-	eh->offset = nat + nval - nnval;
+	eh->offset = nat + nval - nnval - doff;
 	return 0;
 }
 
-#define HIGH_BIT (1U<<(sizeof(unsigned int)*CHAR_BIT-1))
+/* Flag bits for an encoded attribute */
+#define MDB_AT_SORTED	(1<<(sizeof(unsigned int)*CHAR_BIT-1))
+	/* the values are in sorted order */
+#define MDB_AT_MULTI	(1<<(sizeof(unsigned int)*CHAR_BIT-2))
+	/* the values of this multi-valued attr are stored separately */
+
+#define MDB_AT_NVALS	(1<<(sizeof(unsigned int)*CHAR_BIT-1))
+	/* this attribute has normalized values */
 
 /* Flatten an Entry into a buffer. The buffer starts with the count of the
  * number of attributes in the entry, the total number of values in the
  * entry, and the e_ocflags. It then contains a list of integers for each
  * attribute. For each attribute the first integer gives the index of the
  * matching AttributeDescription, followed by the number of values in the
- * attribute. If the high bit of the attr index is set, the attribute's
- * values are already sorted.
- * If the high bit of numvals is set, the attribute also has normalized
- * values present. (Note - a_numvals is an unsigned int, so this means
- * it's possible to receive an attribute that we can't encode due to size
- * overflow. In practice, this should not be an issue.) Then the length
- * of each value is listed. If there are normalized values, their lengths
- * come next. This continues for each attribute. After all of the lengths
- * for the last attribute, the actual values are copied, with a NUL
- * terminator after each value. The buffer is padded to the sizeof(ID).
- * The entire buffer size is precomputed so that a single malloc can be
- * performed.
+ * attribute. If the MDB_AT_SORTED bit of the attr index is set, the
+ * attribute's values are already sorted. If the MDB_AT_MULTI bit of the
+ * attr index is set, the values are stored separately.
+ *
+ * If the MDB_AT_NVALS bit of numvals is set, the attribute also has
+ * normalized values present. (Note - a_numvals is an unsigned int, so this
+ * means it's possible to receive an attribute that we can't encode due
+ * to size overflow. In practice, this should not be an issue.)
+ *
+ * Then the length of each value is listed. If there are normalized values,
+ * their lengths come next. This continues for each attribute. After all
+ * of the lengths for the last attribute, the actual values are copied,
+ * with a NUL terminator after each value.
+ * The buffer is padded to the sizeof(ID). The entire buffer size is
+ * precomputed so that a single malloc can be performed.
  */
 static int mdb_entry_encode(Operation *op, Entry *e, MDB_val *data, Ecount *eh)
 {
@@ -614,31 +916,37 @@
 		if (!a->a_desc->ad_index)
 			return LDAP_UNDEFINED_TYPE;
 		l = mdb->mi_adxs[a->a_desc->ad_index];
+		if (a->a_flags & SLAP_ATTR_BIG_MULTI)
+			l |= MDB_AT_MULTI;
 		if (a->a_flags & SLAP_ATTR_SORTED_VALS)
-			l |= HIGH_BIT;
+			l |= MDB_AT_SORTED;
 		*lp++ = l;
 		l = a->a_numvals;
 		if (a->a_nvals != a->a_vals)
-			l |= HIGH_BIT;
+			l |= MDB_AT_NVALS;
 		*lp++ = l;
-		if (a->a_vals) {
-			for (i=0; a->a_vals[i].bv_val; i++);
-			assert( i == a->a_numvals );
-			for (i=0; i<a->a_numvals; i++) {
-				*lp++ = a->a_vals[i].bv_len;
-				memcpy(ptr, a->a_vals[i].bv_val,
-					a->a_vals[i].bv_len);
-				ptr += a->a_vals[i].bv_len;
-				*ptr++ = '\0';
-			}
-			if (a->a_nvals != a->a_vals) {
+		if (a->a_flags & SLAP_ATTR_BIG_MULTI) {
+			continue;
+		} else {
+			if (a->a_vals) {
+				for (i=0; a->a_vals[i].bv_val; i++);
+				assert( i == a->a_numvals );
 				for (i=0; i<a->a_numvals; i++) {
-					*lp++ = a->a_nvals[i].bv_len;
-					memcpy(ptr, a->a_nvals[i].bv_val,
-						a->a_nvals[i].bv_len);
-					ptr += a->a_nvals[i].bv_len;
+					*lp++ = a->a_vals[i].bv_len;
+					memcpy(ptr, a->a_vals[i].bv_val,
+						a->a_vals[i].bv_len);
+					ptr += a->a_vals[i].bv_len;
 					*ptr++ = '\0';
 				}
+				if (a->a_nvals != a->a_vals) {
+					for (i=0; i<a->a_numvals; i++) {
+						*lp++ = a->a_nvals[i].bv_len;
+						memcpy(ptr, a->a_nvals[i].bv_val,
+							a->a_nvals[i].bv_len);
+						ptr += a->a_nvals[i].bv_len;
+						*ptr++ = '\0';
+					}
+				}
 			}
 		}
 	}
@@ -656,7 +964,7 @@
  * structure. Attempting to do so will likely corrupt memory.
  */
 
-int mdb_entry_decode(Operation *op, MDB_txn *txn, MDB_val *data, Entry **e)
+int mdb_entry_decode(Operation *op, MDB_txn *txn, MDB_val *data, ID id, Entry **e)
 {
 	struct mdb_info *mdb = (struct mdb_info *) op->o_bd->be_private;
 	int i, j, nattrs, nvals;
@@ -667,6 +975,7 @@
 	unsigned int *lp = (unsigned int *)data->mv_data;
 	unsigned char *ptr;
 	BerVarray bptr;
+	MDB_cursor *mvc = NULL;
 
 	Debug( LDAP_DEBUG_TRACE,
 		"=> mdb_entry_decode:\n",
@@ -685,43 +994,49 @@
 	ptr = (unsigned char *)(lp + i);
 
 	for (;nattrs>0; nattrs--) {
-		int have_nval = 0;
+		int have_nval = 0, multi = 0;
 		a->a_flags = SLAP_ATTR_DONT_FREE_DATA | SLAP_ATTR_DONT_FREE_VALS;
 		i = *lp++;
-		if (i & HIGH_BIT) {
-			i ^= HIGH_BIT;
+		if (i & MDB_AT_SORTED) {
+			i ^= MDB_AT_SORTED;
 			a->a_flags |= SLAP_ATTR_SORTED_VALS;
 		}
+		if (i & MDB_AT_MULTI) {
+			i ^= MDB_AT_MULTI;
+			a->a_flags |= SLAP_ATTR_BIG_MULTI;
+			multi = 1;
+		}
 		if (i > mdb->mi_numads) {
 			rc = mdb_ad_read(mdb, txn);
 			if (rc)
-				return rc;
+				goto leave;
 			if (i > mdb->mi_numads) {
 				Debug( LDAP_DEBUG_ANY,
 					"mdb_entry_decode: attribute index %d not recognized\n",
 					i, 0, 0 );
-				return LDAP_OTHER;
+				rc = LDAP_OTHER;
+				goto leave;
 			}
 		}
 		a->a_desc = mdb->mi_ads[i];
 		a->a_numvals = *lp++;
-		if (a->a_numvals & HIGH_BIT) {
-			a->a_numvals ^= HIGH_BIT;
+		if (a->a_numvals & MDB_AT_NVALS) {
+			a->a_numvals ^= MDB_AT_NVALS;
 			have_nval = 1;
 		}
 		a->a_vals = bptr;
-		for (i=0; i<a->a_numvals; i++) {
-			bptr->bv_len = *lp++;;
-			bptr->bv_val = (char *)ptr;
-			ptr += bptr->bv_len+1;
-			bptr++;
-		}
-		bptr->bv_val = NULL;
-		bptr->bv_len = 0;
-		bptr++;
-
-		if (have_nval) {
-			a->a_nvals = bptr;
+		if (multi) {
+			if (!mvc) {
+				rc = mdb_cursor_open(txn, mdb->mi_dbis[MDB_ID2VAL], &mvc);
+				if (rc)
+					goto leave;
+			}
+			i = a->a_numvals;
+			mdb_mval_get(op, mvc, id, a, have_nval);
+			bptr += i + 1;
+			if (have_nval)
+				bptr += i + 1;
+		} else {
 			for (i=0; i<a->a_numvals; i++) {
 				bptr->bv_len = *lp++;
 				bptr->bv_val = (char *)ptr;
@@ -731,9 +1046,23 @@
 			bptr->bv_val = NULL;
 			bptr->bv_len = 0;
 			bptr++;
-		} else {
-			a->a_nvals = a->a_vals;
+
+			if (have_nval) {
+				a->a_nvals = bptr;
+				for (i=0; i<a->a_numvals; i++) {
+					bptr->bv_len = *lp++;
+					bptr->bv_val = (char *)ptr;
+					ptr += bptr->bv_len+1;
+					bptr++;
+				}
+				bptr->bv_val = NULL;
+				bptr->bv_len = 0;
+				bptr++;
+			} else {
+				a->a_nvals = a->a_vals;
+			}
 		}
+
 		/* FIXME: This is redundant once a sorted entry is saved into the DB */
 		if (( a->a_desc->ad_type->sat_flags & SLAP_AT_SORTED_VAL )
 			&& !(a->a_flags & SLAP_ATTR_SORTED_VALS)) {
@@ -745,7 +1074,7 @@
 				Debug( LDAP_DEBUG_ANY,
 					"mdb_entry_decode: attributeType %s value #%d provided more than once\n",
 					a->a_desc->ad_cname.bv_val, j, 0 );
-				return rc;
+				goto leave;
 			}
 		}
 		a->a_next = a+1;
@@ -753,9 +1082,13 @@
 	}
 	a[-1].a_next = NULL;
 done:
-
 	Debug(LDAP_DEBUG_TRACE, "<= mdb_entry_decode\n",
 		0, 0, 0 );
 	*e = x;
-	return 0;
+	rc = 0;
+
+leave:
+	if (mvc)
+		mdb_cursor_close(mvc);
+	return rc;
 }
--- openldap-2.4.46/servers/slapd/back-mdb/index.c.orig	2018-08-31 21:34:11.079531839 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/index.c	2018-08-31 21:20:15.253014824 +0000
@@ -310,7 +310,7 @@
 	/* If this type has no AD, we've never used it before */
 	if( type->sat_ad ) {
 		ai = mdb_attr_mask( op->o_bd->be_private, type->sat_ad );
-		if ( ai ) {
+		if ( ai && ( ai->ai_indexmask || ai->ai_newmask )) {
 #ifdef LDAP_COMP_MATCH
 			/* component indexing */
 			if ( ai->ai_cr ) {
@@ -349,7 +349,7 @@
 		if( desc ) {
 			ai = mdb_attr_mask( op->o_bd->be_private, desc );
 
-			if( ai ) {
+			if( ai && ( ai->ai_indexmask || ai->ai_newmask )) {
 				if ( opid == MDB_INDEX_UPDATE_OP )
 					mask = ai->ai_newmask & ~ai->ai_indexmask;
 				else
--- openldap-2.4.46/servers/slapd/back-mdb/init.c.orig	2018-08-31 21:34:16.043476787 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/init.c	2018-08-31 21:20:08.585093409 +0000
@@ -31,6 +31,7 @@
 	BER_BVC("ad2i"),
 	BER_BVC("dn2i"),
 	BER_BVC("id2e"),
+	BER_BVC("id2v"),
 	BER_BVNULL
 };
 
@@ -63,6 +64,8 @@
 
 	mdb->mi_mapsize = DEFAULT_MAPSIZE;
 	mdb->mi_rtxn_size = DEFAULT_RTXN_SIZE;
+	mdb->mi_multi_hi = UINT_MAX;
+	mdb->mi_multi_lo = UINT_MAX;
 
 	be->be_private = mdb;
 	be->be_cf_ocs = be->bd_info->bi_cf_ocs;
@@ -201,6 +204,8 @@
 		} else {
 			if ( i == MDB_DN2ID )
 				flags |= MDB_DUPSORT;
+			if ( i == MDB_ID2VAL )
+				flags ^= MDB_INTEGERKEY|MDB_DUPSORT;
 			if ( !(slapMode & SLAP_TOOL_READONLY) )
 				flags |= MDB_CREATE;
 		}
@@ -224,7 +229,10 @@
 
 		if ( i == MDB_ID2ENTRY )
 			mdb_set_compare( txn, mdb->mi_dbis[i], mdb_id_compare );
-		else if ( i == MDB_DN2ID ) {
+		else if ( i == MDB_ID2VAL ) {
+			mdb_set_compare( txn, mdb->mi_dbis[i], mdb_id2v_compare );
+			mdb_set_dupsort( txn, mdb->mi_dbis[i], mdb_id2v_dupsort );
+		} else if ( i == MDB_DN2ID ) {
 			MDB_cursor *mc;
 			MDB_val key, data;
 			mdb_set_dupsort( txn, mdb->mi_dbis[i], mdb_dup_compare );
--- openldap-2.4.46/servers/slapd/back-mdb/modify.c.orig	2018-08-31 21:35:11.854858351 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/modify.c	2018-08-31 21:20:15.253014824 +0000
@@ -74,13 +74,17 @@
 	char *textbuf,
 	size_t textlen )
 {
+	struct mdb_info *mdb = (struct mdb_info *) op->o_bd->be_private;
 	int rc, err;
 	Modification	*mod;
 	Modifications	*ml;
 	Attribute	*save_attrs;
-	Attribute 	*ap;
+	Attribute 	*ap, *aold, *anew;
 	int			glue_attr_delete = 0;
+	int			softop, chkpresent;
 	int			got_delete;
+	int			a_flags;
+	MDB_cursor	*mvc = NULL;
 
 	Debug( LDAP_DEBUG_TRACE, "mdb_modify_internal: 0x%08lx: %s\n",
 		e->e_id, e->e_dn, 0);
@@ -129,16 +133,71 @@
 		mod = &ml->sml_mod;
 		got_delete = 0;
 
+		aold = attr_find( e->e_attrs, mod->sm_desc );
+		if (aold)
+			a_flags = aold->a_flags;
+		else
+			a_flags = 0;
+
 		switch ( mod->sm_op ) {
 		case LDAP_MOD_ADD:
+			softop = 0;
+			chkpresent = 0;
 			Debug(LDAP_DEBUG_ARGS,
 				"mdb_modify_internal: add %s\n",
 				mod->sm_desc->ad_cname.bv_val, 0, 0);
+
+do_add:
 			err = modify_add_values( e, mod, get_permissiveModify(op),
 				text, textbuf, textlen );
+
+			if( softop ) {
+				mod->sm_op = SLAP_MOD_SOFTADD;
+				if ( err == LDAP_TYPE_OR_VALUE_EXISTS )
+					err = LDAP_SUCCESS;
+			}
+			if( chkpresent ) {
+				mod->sm_op = SLAP_MOD_ADD_IF_NOT_PRESENT;
+			}
+
 			if( err != LDAP_SUCCESS ) {
 				Debug(LDAP_DEBUG_ARGS, "mdb_modify_internal: %d %s\n",
 					err, *text, 0);
+			} else {
+				unsigned hi;
+				if (!aold)
+					anew = attr_find( e->e_attrs, mod->sm_desc );
+				else
+					anew = aold;
+				mdb_attr_multi_thresh( mdb, mod->sm_desc, &hi, NULL );
+				/* check for big multivalued attrs */
+				if ( anew->a_numvals > hi )
+					anew->a_flags |= SLAP_ATTR_BIG_MULTI;
+				if ( anew->a_flags & SLAP_ATTR_BIG_MULTI ) {
+					if (!mvc) {
+						err = mdb_cursor_open( tid, mdb->mi_dbis[MDB_ID2VAL], &mvc );
+						if (err) {
+mval_fail:					strncpy( textbuf, mdb_strerror( err ), textlen );
+							err = LDAP_OTHER;
+							break;
+						}
+					}
+					/* if prev was set, just add new values */
+					if (a_flags & SLAP_ATTR_BIG_MULTI ) {
+						anew = (Attribute *)mod;
+						/* Tweak nvals */
+						if (!anew->a_nvals)
+							anew->a_nvals = anew->a_vals;
+					}
+					err = mdb_mval_put(op, mvc, e->e_id, anew);
+					if (a_flags & SLAP_ATTR_BIG_MULTI ) {
+						/* Undo nvals tweak */
+						if (anew->a_nvals == anew->a_vals)
+							anew->a_nvals = NULL;
+					}
+					if ( err )
+						goto mval_fail;
+				}
 			}
 			break;
 
@@ -148,16 +207,61 @@
 				break;
 			}
 
+			softop = 0;
 			Debug(LDAP_DEBUG_ARGS,
 				"mdb_modify_internal: delete %s\n",
 				mod->sm_desc->ad_cname.bv_val, 0, 0);
+do_del:
 			err = modify_delete_values( e, mod, get_permissiveModify(op),
 				text, textbuf, textlen );
+
+			if (softop) {
+				mod->sm_op = SLAP_MOD_SOFTDEL;
+				if ( err == LDAP_NO_SUCH_ATTRIBUTE ) {
+					err = LDAP_SUCCESS;
+					softop = 2;
+				}
+			}
+
 			if( err != LDAP_SUCCESS ) {
 				Debug(LDAP_DEBUG_ARGS, "mdb_modify_internal: %d %s\n",
 					err, *text, 0);
 			} else {
-				got_delete = 1;
+				if (softop != 2)
+					got_delete = 1;
+				/* check for big multivalued attrs */
+				if (a_flags & SLAP_ATTR_BIG_MULTI) {
+					Attribute a_dummy;
+					if (!mvc) {
+						err = mdb_cursor_open( tid, mdb->mi_dbis[MDB_ID2VAL], &mvc );
+						if (err)
+							goto mval_fail;
+					}
+					if ( mod->sm_numvals ) {
+						anew = attr_find( e->e_attrs, mod->sm_desc );
+						if ( anew ) {
+							unsigned lo;
+							mdb_attr_multi_thresh( mdb, mod->sm_desc, NULL, &lo );
+							if ( anew->a_numvals < lo ) {
+								anew->a_flags ^= SLAP_ATTR_BIG_MULTI;
+								anew = NULL;
+							} else {
+								anew = (Attribute *)mod;
+							}
+						}
+					} else {
+						anew = NULL;
+					}
+					if (!anew) {
+					/* delete all values */
+						anew = &a_dummy;
+						anew->a_desc = mod->sm_desc;
+						anew->a_numvals = 0;
+					}
+					err = mdb_mval_del( op, mvc, e->e_id, anew );
+					if ( err )
+						goto mval_fail;
+				}
 			}
 			break;
 
@@ -171,7 +275,39 @@
 				Debug(LDAP_DEBUG_ARGS, "mdb_modify_internal: %d %s\n",
 					err, *text, 0);
 			} else {
+				unsigned hi;
 				got_delete = 1;
+				if (a_flags & SLAP_ATTR_BIG_MULTI) {
+					Attribute a_dummy;
+					if (!mvc) {
+						err = mdb_cursor_open( tid, mdb->mi_dbis[MDB_ID2VAL], &mvc );
+						if (err)
+							goto mval_fail;
+					}
+					/* delete all values */
+					anew = &a_dummy;
+					anew->a_desc = mod->sm_desc;
+					anew->a_numvals = 0;
+					err = mdb_mval_del( op, mvc, e->e_id, anew );
+					if (err)
+						goto mval_fail;
+				}
+				anew = attr_find( e->e_attrs, mod->sm_desc );
+				mdb_attr_multi_thresh( mdb, mod->sm_desc, &hi, NULL );
+				if (mod->sm_numvals > hi) {
+					anew->a_flags |= SLAP_ATTR_BIG_MULTI;
+					if (!mvc) {
+						err = mdb_cursor_open( tid, mdb->mi_dbis[MDB_ID2VAL], &mvc );
+						if (err)
+							goto mval_fail;
+					}
+					err = mdb_mval_put(op, mvc, e->e_id, anew);
+					if (err)
+						goto mval_fail;
+				} else if (anew) {
+					/* revert back to normal attr */
+					anew->a_flags &= ~SLAP_ATTR_BIG_MULTI;
+				}
 			}
 			break;
 
@@ -198,21 +334,9 @@
  			 * We need to add index if necessary.
  			 */
  			mod->sm_op = LDAP_MOD_ADD;
-
-			err = modify_add_values( e, mod, get_permissiveModify(op),
-				text, textbuf, textlen );
-
- 			mod->sm_op = SLAP_MOD_SOFTADD;
-
- 			if ( err == LDAP_TYPE_OR_VALUE_EXISTS ) {
- 				err = LDAP_SUCCESS;
- 			}
-
-			if( err != LDAP_SUCCESS ) {
-				Debug(LDAP_DEBUG_ARGS, "mdb_modify_internal: %d %s\n",
-					err, *text, 0);
-			}
- 			break;
+			softop = 1;
+			chkpresent = 0;
+			goto do_add;
 
 		case SLAP_MOD_SOFTDEL:
 			Debug(LDAP_DEBUG_ARGS,
@@ -222,23 +346,8 @@
  			 * We need to add index if necessary.
  			 */
  			mod->sm_op = LDAP_MOD_DELETE;
-
-			err = modify_delete_values( e, mod, get_permissiveModify(op),
-				text, textbuf, textlen );
-
- 			mod->sm_op = SLAP_MOD_SOFTDEL;
-
-			if ( err == LDAP_SUCCESS ) {
-				got_delete = 1;
-			} else if ( err == LDAP_NO_SUCH_ATTRIBUTE ) {
- 				err = LDAP_SUCCESS;
- 			}
-
-			if( err != LDAP_SUCCESS ) {
-				Debug(LDAP_DEBUG_ARGS, "mdb_modify_internal: %d %s\n",
-					err, *text, 0);
-			}
- 			break;
+			softop = 1;
+			goto do_del;
 
 		case SLAP_MOD_ADD_IF_NOT_PRESENT:
 			if ( attr_find( e->e_attrs, mod->sm_desc ) != NULL ) {
@@ -254,17 +363,9 @@
  			 * We need to add index if necessary.
  			 */
  			mod->sm_op = LDAP_MOD_ADD;
-
-			err = modify_add_values( e, mod, get_permissiveModify(op),
-				text, textbuf, textlen );
-
- 			mod->sm_op = SLAP_MOD_ADD_IF_NOT_PRESENT;
-
-			if( err != LDAP_SUCCESS ) {
-				Debug(LDAP_DEBUG_ARGS, "mdb_modify_internal: %d %s\n",
-					err, *text, 0);
-			}
- 			break;
+			softop = 0;
+			chkpresent = 1;
+			goto do_add;
 
 		default:
 			Debug(LDAP_DEBUG_ANY, "mdb_modify_internal: invalid op %d\n",
--- openldap-2.4.46/servers/slapd/back-mdb/proto-mdb.h.orig	2018-08-31 21:34:46.931134408 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/proto-mdb.h	2018-08-31 21:20:15.253014824 +0000
@@ -44,6 +44,15 @@
 void mdb_attr_index_free LDAP_P(( struct mdb_info *mdb,
 	AttributeDescription *ad ));
 
+int mdb_attr_multi_config LDAP_P(( struct mdb_info *mdb,
+	const char *fname, int lineno,
+	int argc, char **argv, struct config_reply_s *cr ));
+
+void mdb_attr_multi_unparse LDAP_P(( struct mdb_info *mdb, BerVarray *bva ));
+
+void mdb_attr_multi_thresh LDAP_P(( struct mdb_info *mdb, AttributeDescription *ad,
+	unsigned *hi, unsigned *lo ));
+
 void mdb_attr_info_free( AttrInfo *ai );
 
 int mdb_ad_read( struct mdb_info *mdb, MDB_txn *txn );
@@ -168,6 +177,9 @@
  * id2entry.c
  */
 
+MDB_cmp_func mdb_id2v_compare;
+MDB_cmp_func mdb_id2v_dupsort;
+
 int mdb_id2entry_add(
 	Operation *op,
 	MDB_txn *tid,
@@ -201,11 +213,14 @@
 BI_entry_release_rw mdb_entry_release;
 BI_entry_get_rw mdb_entry_get;
 
-int mdb_entry_decode( Operation *op, MDB_txn *txn, MDB_val *data, Entry **e );
+int mdb_entry_decode( Operation *op, MDB_txn *txn, MDB_val *data, ID id, Entry **e );
 
 void mdb_reader_flush( MDB_env *env );
 int mdb_opinfo_get( Operation *op, struct mdb_info *mdb, int rdonly, mdb_op_info **moi );
 
+int mdb_mval_put(Operation *op, MDB_cursor *mc, ID id, Attribute *a);
+int mdb_mval_del(Operation *op, MDB_cursor *mc, ID id, Attribute *a);
+
 /*
  * idl.c
  */
--- openldap-2.4.46/servers/slapd/back-mdb/search.c.orig	2018-08-31 21:34:04.503604782 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/search.c	2018-08-31 21:20:08.589093362 +0000
@@ -708,6 +708,7 @@
 	}
 
 	wwctx.flag = 0;
+	wwctx.nentries = 0;
 	/* If we're running in our own read txn */
 	if (  moi == &opinfo ) {
 		cb.sc_writewait = mdb_writewait;
@@ -921,7 +922,7 @@
 				goto done;
 			}
 
-			rs->sr_err = mdb_entry_decode( op, ltid, &edata, &e );
+			rs->sr_err = mdb_entry_decode( op, ltid, &edata, id, &e );
 			if ( rs->sr_err ) {
 				rs->sr_err = LDAP_OTHER;
 				rs->sr_text = "internal error in mdb_entry_decode";
--- openldap-2.4.46/servers/slapd/back-mdb/tools.c.orig	2018-08-31 21:34:26.027366088 +0000
+++ openldap-2.4.46/servers/slapd/back-mdb/tools.c	2018-08-31 21:20:08.589093362 +0000
@@ -379,7 +379,7 @@
 			}
 		}
 	}
-	rc = mdb_entry_decode( &op, mdb_tool_txn, &data, &e );
+	rc = mdb_entry_decode( &op, mdb_tool_txn, &data, id, &e );
 	e->e_id = id;
 	if ( !BER_BVISNULL( &dn )) {
 		e->e_name = dn;
