diff --git a/auto/cc/gcc b/auto/cc/gcc
index a5c5c18fb..8a688914b 100644
--- a/auto/cc/gcc
+++ b/auto/cc/gcc
@@ -50,7 +50,7 @@ esac
 
 #NGX_GCC_OPT="-O2"
 #NGX_GCC_OPT="-Os"
-NGX_GCC_OPT="-O"
+NGX_GCC_OPT="-O0"
 
 #CFLAGS="$CFLAGS -fomit-frame-pointer"
 
diff --git a/auto/lib/conf b/auto/lib/conf
index 2c7af1040..273309660 100644
--- a/auto/lib/conf
+++ b/auto/lib/conf
@@ -1,7 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
-
+# Portions Copyright (c) Zimbra Software, LLC. [1998 – 2011]. All Rights Reserved.
 
 if [ $USE_PCRE = YES -o $PCRE != NONE ]; then
     . auto/lib/pcre/conf
@@ -52,3 +52,8 @@ fi
 if [ $NGX_LIBATOMIC != NO ]; then
     . auto/lib/libatomic/conf
 fi
+
+if [ $USE_SASL = YES ]; then
+    . auto/lib/sasl/conf
+fi
+
diff --git a/auto/lib/sasl/conf b/auto/lib/sasl/conf
new file mode 100644
index 000000000..a83d09cbb
--- /dev/null
+++ b/auto/lib/sasl/conf
@@ -0,0 +1,93 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Zimbra Collaboration Suite Server
+# Copyright (C) 2011 Zimbra Software, LLC.
+#
+# The contents of this file are subject to the Zimbra Public License
+# Version 1.4 ("License"); you may not use this file except in
+# compliance with the License.  You may obtain a copy of the License at
+# http://www.zimbra.com/license.
+#
+# Software distributed under the License is distributed on an "AS IS"
+# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+# ***** END LICENSE BLOCK *****
+#
+    ngx_feature="SASL library"
+    ngx_feature_name="NGX_SASL"
+    ngx_feature_run=no
+    ngx_feature_incs="#include <sasl/sasl.h>"
+    ngx_feature_path=
+    ngx_feature_libs="-lsasl2"
+    ngx_feature_test="int rc = sasl_server_init(NULL, \"test\");"
+    . auto/feature
+
+
+if [ $ngx_found = no ]; then
+
+    # FreeBSD port
+
+    ngx_feature="SASL library in /usr/local/"
+    ngx_feature_path="/usr/local/include"
+
+    if [ $NGX_RPATH = YES ]; then
+        ngx_feature_libs="-R/usr/local/lib -L/usr/local/lib -lsasl2"
+    else
+        ngx_feature_libs="-L/usr/local/lib -lsasl2"
+    fi
+
+    . auto/feature
+fi
+
+
+if [ $ngx_found = no ]; then
+
+    # NetBSD port
+
+    ngx_feature="SASL library in /usr/pkg/"
+    ngx_feature_path="/usr/pkg/include/"
+
+    if [ $NGX_RPATH = YES ]; then
+        ngx_feature_libs="-R/usr/pkg/lib -L/usr/pkg/lib -lsasl2"
+    else
+        ngx_feature_libs="-L/usr/pkg/lib -lsasl2"
+    fi
+
+    . auto/feature
+fi
+
+
+if [ $ngx_found = no ]; then
+
+    # MacPorts
+
+    ngx_feature="SASL library in /opt/local/"
+    ngx_feature_path="/opt/local/include"
+
+    if [ $NGX_RPATH = YES ]; then
+        ngx_feature_libs="-R/opt/local/lib -L/opt/local/lib -lsasl2"
+    else
+        ngx_feature_libs="-L/opt/local/lib -lsasl2"
+    fi
+
+    . auto/feature
+fi
+
+
+if [ $ngx_found = yes ]; then
+
+    CORE_INCS="$CORE_INCS $ngx_feature_path"
+    CORE_LIBS="$CORE_LIBS $ngx_feature_libs"
+    SASL=YES
+
+else
+
+cat << END
+
+$0: error: SASL support in the MAIL filter modules requires the SASL library.
+You can either not enable the feature or install the libraries.
+
+END
+
+    exit 1
+
+fi
diff --git a/auto/modules b/auto/modules
index d78e2823a..362d256cb 100644
--- a/auto/modules
+++ b/auto/modules
@@ -1,7 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
-
+# Portions Copyright (c) Zimbra Software, LLC. [1998 – 2011]. All Rights Reserved.
 
 if [ $EVENT_SELECT = NO -a $EVENT_FOUND = NO ]; then
     EVENT_SELECT=YES
@@ -898,6 +898,32 @@ if [ $HTTP = YES ]; then
         . auto/module
     fi
 
+    if [ $HTTP_UPSTREAM_ZMAUTH = YES ]; then
+        have=NGX_HTTP_UPSTREAM_ZMAUTH . auto/have
+
+        ngx_module_name=ngx_http_upstream_zmauth_module
+        ngx_module_incs=
+        ngx_module_deps=src/http/modules/ngx_http_upstream_zmauth_module.h
+        ngx_module_srcs=src/http/modules/ngx_http_upstream_zmauth_module.c
+        ngx_module_libs=
+        ngx_module_link=$HTTP_UPSTREAM_ZMAUTH
+
+        . auto/module
+    fi
+
+    if [ $HTTP_ZM_SSO = YES ]; then
+        have=NGX_HTTP_ZM_SSO . auto/have
+
+        ngx_module_name=ngx_http_zm_sso_module
+        ngx_module_incs=
+        ngx_module_deps=src/http/modules/ngx_http_zm_sso_module.h
+        ngx_module_srcs=src/http/modules/ngx_http_zm_sso_module.c
+        ngx_module_libs=
+        ngx_module_link=$HTTP_ZM_SSO
+
+        . auto/module
+    fi
+
     if [ $HTTP_STUB_STATUS = YES ]; then
         have=NGX_STAT_STUB . auto/have
 
@@ -936,6 +962,11 @@ if [ $MAIL != NO ]; then
 
     ngx_module_incs=
 
+    if [ $MAIL_SASL = YES ]; then
+        USE_SASL=YES
+        have=NGX_MAIL_SASL . auto/have
+    fi
+
     if [ $MAIL_SSL = YES ]; then
         USE_OPENSSL=YES
         have=NGX_MAIL_SSL . auto/have
@@ -974,6 +1005,32 @@ if [ $MAIL != NO ]; then
         . auto/module
     fi
 
+    if [ $MAIL_ZMAUTH = YES ]; then
+        have=NGX_MAIL_ZMAUTH . auto/have
+
+        ngx_module_name=ngx_mail_zmauth_module
+        ngx_module_incs=
+        ngx_module_deps=src/mail/ngx_mail_zmauth_module.h
+        ngx_module_srcs=src/mail/ngx_mail_zmauth_module.c
+        ngx_module_libs=
+        ngx_module_link=$MAIL_ZMAUTH
+
+        . auto/module
+    fi
+
+    if [ $MAIL_THROTTLE = YES ]; then
+        have=NGX_MAIL_THROTTLE . auto/have
+
+        ngx_module_name=ngx_mail_throttle_module
+        ngx_module_incs=
+        ngx_module_deps=src/mail/ngx_mail_throttle_module.h
+        ngx_module_srcs=src/mail/ngx_mail_throttle_module.c
+        ngx_module_libs=
+        ngx_module_link=$MAIL_THROTTLE
+
+        . auto/module
+    fi
+
     ngx_module_name=ngx_mail_auth_http_module
     ngx_module_deps=
     ngx_module_srcs=src/mail/ngx_mail_auth_http_module.c
@@ -1268,6 +1325,8 @@ fi
 
 
 modules="$CORE_MODULES $EVENT_MODULES"
+modules="$modules $MEMCACHE_MODULE"
+modules="$modules $ZM_LOOKUP_MODULE"
 
 
 # thread pool module should be initialized after events
diff --git a/auto/options b/auto/options
index 521c9768d..0ca041e2b 100644
--- a/auto/options
+++ b/auto/options
@@ -1,7 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
-
+# Portions Copyright (c) Zimbra Software, LLC. [1998 – 2011]. All Rights Reserved.
 
 help=no
 
@@ -104,15 +104,20 @@ HTTP_UPSTREAM_LEAST_CONN=YES
 HTTP_UPSTREAM_RANDOM=YES
 HTTP_UPSTREAM_KEEPALIVE=YES
 HTTP_UPSTREAM_ZONE=YES
+HTTP_UPSTREAM_ZMAUTH=NO
+HTTP_ZM_SSO=NO
 
 # STUB
 HTTP_STUB_STATUS=NO
 
 MAIL=NO
+MAIL_SASL=NO
 MAIL_SSL=NO
 MAIL_POP3=YES
 MAIL_IMAP=YES
 MAIL_SMTP=YES
+MAIL_THROTTLE=NO
+MAIL_ZMAUTH=NO
 
 STREAM=NO
 STREAM_SSL=NO
@@ -138,6 +143,10 @@ DYNAMIC_ADDONS=
 
 NGX_COMPAT=NO
 
+USE_SASL=NO
+SASL=NONE
+SASL_OPT=
+
 USE_PCRE=NO
 PCRE=NONE
 PCRE_OPT=
@@ -245,7 +254,10 @@ $0: warning: the \"--with-ipv6\" option is deprecated"
         --with-http_secure_link_module)  HTTP_SECURE_LINK=YES       ;;
         --with-http_degradation_module)  HTTP_DEGRADATION=YES       ;;
         --with-http_slice_module)        HTTP_SLICE=YES             ;;
-
+        --with-http_upstream_zmauth_module) HTTP_UPSTREAM_ZMAUTH=YES ;;
+        --with-http_zm_sso_module)       HTTP_ZM_SSO=YES            ;;
+        --with-mail_throttle)            MAIL_THROTTLE=YES          ;;
+        --with-mail_zmauth)              MAIL_ZMAUTH=YES            ;;
         --without-http_charset_module)   HTTP_CHARSET=NO            ;;
         --without-http_gzip_module)      HTTP_GZIP=NO               ;;
         --without-http_ssi_module)       HTTP_SSI=NO                ;;
@@ -288,6 +300,7 @@ $0: warning: the \"--with-ipv6\" option is deprecated"
         --with-http_stub_status_module)  HTTP_STUB_STATUS=YES       ;;
 
         --with-mail)                     MAIL=YES                   ;;
+        --with-mail-sasl)                MAIL_SASL=YES              ;;
         --with-mail=dynamic)             MAIL=DYNAMIC               ;;
         --with-mail_ssl_module)          MAIL_SSL=YES               ;;
         # STUB
@@ -369,7 +382,12 @@ $0: warning: the \"--with-md5-opt\" option is deprecated"
             NGX_POST_CONF_MSG="$NGX_POST_CONF_MSG
 $0: warning: the \"--with-md5-asm\" option is deprecated"
         ;;
-
+        --with-sasl=*)
+            SASL="$value"
+        ;;
+        --with-sasl-opt=*)
+            SASL_OPT="$value"
+        ;;
         --with-sha1=*)
             NGX_POST_CONF_MSG="$NGX_POST_CONF_MSG
 $0: warning: the \"--with-sha1\" option is deprecated"
@@ -460,6 +478,8 @@ cat << END
   --with-http_degradation_module     enable ngx_http_degradation_module
   --with-http_slice_module           enable ngx_http_slice_module
   --with-http_stub_status_module     enable ngx_http_stub_status_module
+  --with-http_upstream_zmauth_module enable ngx_http_upstream_zmauth_module
+  --with-http_zm_sso_module          enable ngx_http_zm_sso_module
 
   --without-http_charset_module      disable ngx_http_charset_module
   --without-http_gzip_module         disable ngx_http_gzip_module
@@ -518,6 +538,7 @@ cat << END
   --without-http-cache               disable HTTP cache
 
   --with-mail                        enable POP3/IMAP4/SMTP proxy module
+  --with-mail-sasl                   enable SASL support
   --with-mail=dynamic                enable dynamic POP3/IMAP4/SMTP proxy module
   --with-mail_ssl_module             enable ngx_mail_ssl_module
   --without-mail_pop3_module         disable ngx_mail_pop3_module
@@ -581,6 +602,9 @@ cat << END
   --with-openssl=DIR                 set path to OpenSSL library sources
   --with-openssl-opt=OPTIONS         set additional build options for OpenSSL
 
+  --with-sasl=DIR                    set path to sasl library sources
+  --with-sasl-opt=OPTIONS            set additional options for sasl building
+
   --with-debug                       enable debug logging
 
 END
diff --git a/auto/sources b/auto/sources
index 3dad11132..899fd5a03 100644
--- a/auto/sources
+++ b/auto/sources
@@ -1,7 +1,7 @@
 
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
-
+# Portions Copyright (c) Zimbra Software, LLC. [1998 – 2011]. All Rights Reserved.
 
 CORE_MODULES="ngx_core_module ngx_errlog_module ngx_conf_module"
 
@@ -39,6 +39,8 @@ CORE_DEPS="src/core/nginx.h \
            src/core/ngx_module.h \
            src/core/ngx_resolver.h \
            src/core/ngx_open_file_cache.h \
+           src/core/ngx_memcache.h \
+           src/core/ngx_zm_lookup.h \
            src/core/ngx_crypt.h \
            src/core/ngx_proxy_protocol.h \
            src/core/ngx_syslog.h"
@@ -76,6 +78,8 @@ CORE_SRCS="src/core/nginx.c \
            src/core/ngx_module.c \
            src/core/ngx_resolver.c \
            src/core/ngx_open_file_cache.c \
+           src/core/ngx_memcache.c \
+           src/core/ngx_zm_lookup.c \
            src/core/ngx_crypt.c \
            src/core/ngx_proxy_protocol.c \
            src/core/ngx_syslog.c"
@@ -126,6 +130,9 @@ IOCP_SRCS=src/event/modules/ngx_iocp_module.c
 FILE_AIO_SRCS="src/os/unix/ngx_file_aio_read.c"
 LINUX_AIO_SRCS="src/os/unix/ngx_linux_aio_read.c"
 
+MEMCACHE_MODULE=ngx_memcache_module
+ZM_LOOKUP_MODULE=ngx_zm_lookup_module
+
 UNIX_INCS="$CORE_INCS $EVENT_INCS src/os/unix"
 
 UNIX_DEPS="$CORE_DEPS $EVENT_DEPS \
@@ -253,5 +260,4 @@ WIN32_SRCS="$CORE_SRCS $EVENT_SRCS \
 NGX_WIN32_ICONS="src/os/win32/nginx.ico"
 NGX_WIN32_RC="src/os/win32/nginx.rc"
 
-
 HTTP_FILE_CACHE_SRCS=src/http/ngx_http_file_cache.c
diff --git a/auto/summary b/auto/summary
index 9aa776edf..f1de5c8e8 100644
--- a/auto/summary
+++ b/auto/summary
@@ -2,6 +2,7 @@
 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
 
+# Portions Copyright (c) Zimbra Software, LLC. [1998 – 2011]. All Rights Reserved.
 
 echo
 echo "Configuration summary"
@@ -40,6 +41,13 @@ case $NGX_LIBATOMIC in
     *)     echo "  + using libatomic_ops library: $NGX_LIBATOMIC" ;;
 esac
 
+case $SASL in
+    YES)   echo "  + using system sasl library" ;;
+    NONE)  echo "  + sasl library is not used" ;;
+    NO)    echo "  + sasl library is not found" ;;
+    *)     echo "  + using sasl library: $SASL" ;;
+esac
+
 echo
 
 
diff --git a/html/zmerror_upstream_502.html b/html/zmerror_upstream_502.html
new file mode 100644
index 000000000..8a8217c5f
--- /dev/null
+++ b/html/zmerror_upstream_502.html
@@ -0,0 +1,29 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
+<title>Error 502 Connection to Upstream is Refused</title>
+</head>
+<body>
+<h2>HTTP ERROR 502</h2>
+<p>Problem accessing ZCS upstream server.
+	Cannot connect to the ZCS upstream server. Connection is refused.<br/>
+    Possible reasons:
+    <ul>
+        <li>upstream server is unreachable</li>
+        <li>upstream server is currently being upgraded</li>
+        <li>upstream server is down</li>
+    </ul>
+    Please contact your ZCS administrator to fix the problem.
+</p><br/>
+<i><small>Powered by Nginx-Zimbra://</small></i><br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                                                             
+
+</body>
+</html>
diff --git a/html/zmerror_upstream_504.html b/html/zmerror_upstream_504.html
new file mode 100644
index 000000000..c2e8a1884
--- /dev/null
+++ b/html/zmerror_upstream_504.html
@@ -0,0 +1,29 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
+<title>Error 504 Connection to Upstream is Time Out</title>
+</head>
+<body>
+<h2>HTTP ERROR 504</h2>
+<p>Problem accessing ZCS upstream server. Reason:
+	Cannot connect to the ZCS upstream server. Connection timeout.<br/>
+    Possible reasons:
+    <ul>
+        <li>upstream server is blocked by a firewall</li>
+        <li>upstream server is failing to send back the response in time</li>
+        <li>upstream server is down</li>
+    </ul>
+    Please contact your ZCS administrator to fix the problem.
+</p><br/>
+<i><small>Powered by Nginx-Zimbra://</small></i><br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                
+<br/>                                                                                             
+
+</body>
+</html>
diff --git a/src/core/nginx.c b/src/core/nginx.c
index 9fcb0eb23..edd9af475 100644
--- a/src/core/nginx.c
+++ b/src/core/nginx.c
@@ -29,6 +29,7 @@ static char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
 #if (NGX_HAVE_DLOPEN)
 static void ngx_unload_module(void *data);
 #endif
+static char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
 
 
 static ngx_conf_enum_t  ngx_debug_points[] = {
diff --git a/src/core/nginx.h b/src/core/nginx.h
index 796c25c20..3945ef3ad 100644
--- a/src/core/nginx.h
+++ b/src/core/nginx.h
@@ -10,7 +10,7 @@
 
 
 #define nginx_version      1017009
-#define NGINX_VERSION      "1.17.9"
+#define NGINX_VERSION      "1.17.9-zimbra"
 #define NGINX_VER          "nginx/" NGINX_VERSION
 
 #ifdef NGX_BUILD
diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c
index 95f4bdfab..923cb31ff 100644
--- a/src/core/ngx_cycle.c
+++ b/src/core/ngx_cycle.c
@@ -4,6 +4,9 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998 – 2020]. All Rights Reserved.
+ */
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -387,6 +390,17 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)
             goto failed;
         }
 
+        //bug 55962, change the owner of log file when current effective
+        //user is root
+        if (geteuid() == 0 && ccf->user != (ngx_uid_t) NGX_CONF_UNSET_UINT) {
+            int rc = fchown(file[i].fd, ccf->user, ccf->group);
+            if(rc != 0) {
+                ngx_log_error(NGX_LOG_WARN, log, ngx_errno,
+                        "Cannot set the owner of log file \"%V\" "
+                        "to user \"%s\"", &file[i].name, &ccf->username);
+            }
+        }
+
 #if !(NGX_WIN32)
         if (fcntl(file[i].fd, F_SETFD, FD_CLOEXEC) == -1) {
             ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
diff --git a/src/core/ngx_inet.c b/src/core/ngx_inet.c
index 4228504ad..eaee8afd4 100644
--- a/src/core/ngx_inet.c
+++ b/src/core/ngx_inet.c
@@ -4,6 +4,9 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998 – 2020]. All Rights Reserved.
+ */
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -14,6 +17,7 @@ static ngx_int_t ngx_parse_inet_url(ngx_pool_t *pool, ngx_url_t *u);
 static ngx_int_t ngx_parse_inet6_url(ngx_pool_t *pool, ngx_url_t *u);
 static ngx_int_t ngx_inet_add_addr(ngx_pool_t *pool, ngx_url_t *u,
     struct sockaddr *sockaddr, socklen_t socklen, ngx_uint_t total);
+static ngx_int_t ngx_resolve_hostname(ngx_pool_t *pool, ngx_url_t *u);
 
 
 in_addr_t
@@ -966,6 +970,8 @@ no_port:
         }
 
         return ngx_inet_add_addr(pool, u, &u->sockaddr.sockaddr, u->socklen, 1);
+    } else {
+        return ngx_resolve_hostname(pool, u);
     }
 
     if (u->no_resolve) {
@@ -984,6 +990,113 @@ no_port:
     return NGX_OK;
 }
 
+static ngx_int_t
+ngx_resolve_hostname(ngx_pool_t *pool, ngx_url_t *u) {
+    u_char               *p;
+    ngx_uint_t            family;
+    in_addr_t             in_addr;
+    struct sockaddr_in   *sin;
+
+#if (NGX_HAVE_INET6)
+    struct addrinfo       hints, *addrinfo;
+    struct in6_addr       in6_addr;
+    struct sockaddr_in6  *sin6;
+    int                   n;
+#else
+    struct hostent       *h;
+#endif
+
+    in_addr = 0;
+
+    /* resolve the IP address through host name.
+     * only the first IP address will be used.   */
+    p = ngx_alloc(u->host.len + 1, pool->log);
+
+    if (p == NULL) {
+      return NGX_ERROR;
+    }
+
+    ngx_cpystrn(p, u->host.data, u->host.len + 1);
+
+#if (NGX_HAVE_INET6)
+
+    ngx_memzero (&hints, sizeof (struct addrinfo));
+
+    if (u->listen) {
+       hints.ai_flags = AI_PASSIVE;
+    } else {
+       hints.ai_flags = AI_CANONNAME;
+    }
+
+    hints.ai_protocol = IPPROTO_TCP;
+
+    n = getaddrinfo((const char *) p,
+           NULL, &hints, &addrinfo);
+
+    if (n != NGX_OK) {
+       u->err = "host not found";
+       return NGX_ERROR;
+    }
+
+    if (addrinfo->ai_family == AF_INET) {
+       family = AF_INET;
+       in_addr = ((struct sockaddr_in *) addrinfo->ai_addr)->sin_addr.s_addr;
+
+    } else { /* AF_INET6 */
+       family = AF_INET6;
+       in6_addr = ((struct sockaddr_in6 *) addrinfo->ai_addr)->sin6_addr;
+
+    }
+#else
+    h = gethostbyname((const char *) p);
+
+    if (h == NULL || h->h_addr_list[0] == NULL) {
+        u->err = "host not found";
+        return NGX_ERROR;
+    }
+
+    in_addr = *(in_addr_t *) (h->h_addr_list[0]);
+#endif
+
+    ngx_free(p);
+
+    switch (family) {
+
+#if (NGX_HAVE_INET6)
+    case AF_INET6:
+       sin6 = (struct sockaddr_in6 *) &u->sockaddr;
+       sin6->sin6_family = AF_INET6;
+       sin6->sin6_port = htons(u->port);
+       u->family = AF_INET6;
+       u->socklen = sizeof (struct sockaddr_in6);
+       ngx_memcpy(sin6->sin6_addr.s6_addr, in6_addr.s6_addr, 16);
+
+       if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
+           u->wildcard = 1;
+       }
+       break;
+#endif
+
+    default: /* AF_INET */
+       sin = (struct sockaddr_in *) &u->sockaddr;
+       sin->sin_family = AF_INET;
+       sin->sin_port = htons(u->port);
+       u->family = AF_INET;
+       u->socklen = sizeof (struct sockaddr_in);
+       sin->sin_addr.s_addr = in_addr;
+       if (sin->sin_addr.s_addr == INADDR_ANY) {
+           u->wildcard = 1;
+       }
+       break;
+    }
+
+    if (u->listen) {
+        return NGX_OK;
+    }
+
+    return ngx_inet_resolve_host(pool, u);
+}
+
 
 static ngx_int_t
 ngx_parse_inet6_url(ngx_pool_t *pool, ngx_url_t *u)
@@ -1253,6 +1366,10 @@ ngx_inet_resolve_host(ngx_pool_t *pool, ngx_url_t *u)
         }
     }
 
+    if (ngx_inet_resolve_host(pool, u) != NGX_OK) {
+           return NGX_ERROR;
+    }
+
     return NGX_OK;
 }
 
diff --git a/src/core/ngx_log.c b/src/core/ngx_log.c
index 8e9408df0..c9b643c37 100644
--- a/src/core/ngx_log.c
+++ b/src/core/ngx_log.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998 – 2020]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -86,7 +90,7 @@ static ngx_str_t err_levels[] = {
 
 static const char *debug_levels[] = {
     "debug_core", "debug_alloc", "debug_mutex", "debug_event",
-    "debug_http", "debug_mail", "debug_stream"
+    "debug_http", "debug_mail", "debug_stream", "debug_zimbra"
 };
 
 
diff --git a/src/core/ngx_log.h b/src/core/ngx_log.h
index afb73bf71..034a43dea 100644
--- a/src/core/ngx_log.h
+++ b/src/core/ngx_log.h
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998 – 2011]. All Rights Reserved.
+ */
+
 
 #ifndef _NGX_LOG_H_INCLUDED_
 #define _NGX_LOG_H_INCLUDED_
@@ -30,6 +34,7 @@
 #define NGX_LOG_DEBUG_HTTP        0x100
 #define NGX_LOG_DEBUG_MAIL        0x200
 #define NGX_LOG_DEBUG_STREAM      0x400
+#define NGX_LOG_DEBUG_ZIMBRA      0x800
 
 /*
  * do not forget to update debug_levels[] in src/core/ngx_log.c
@@ -37,7 +42,7 @@
  */
 
 #define NGX_LOG_DEBUG_FIRST       NGX_LOG_DEBUG_CORE
-#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_STREAM
+#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_ZIMBRA
 #define NGX_LOG_DEBUG_CONNECTION  0x80000000
 #define NGX_LOG_DEBUG_ALL         0x7ffffff0
 
diff --git a/src/core/ngx_memcache.c b/src/core/ngx_memcache.c
new file mode 100644
index 000000000..0562c68ae
--- /dev/null
+++ b/src/core/ngx_memcache.c
@@ -0,0 +1,2156 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#include <ngx_memcache.h>
+#include <openssl/md5.h>
+
+#define MC_INVALID_HASH ((ngx_uint_t) - 1)
+#define MC_REQ_POOL_SIZE 1024
+
+static int mc_sndbuf_len = 256 * 1024;
+
+ngx_str_t NGX_EMPTY_STR = ngx_string("");
+
+/* config-related function prototypes */
+static char *ngx_memcache_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static void *ngx_memcache_create_conf(ngx_cycle_t *cycle);
+static char *ngx_memcache_init_conf(ngx_cycle_t *cycle, void *conf);
+static ngx_int_t ngx_memcache_init_process(ngx_cycle_t *cycle);
+static char *
+ngx_memcache_servers (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *
+ngx_memcache_ttl (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+/* memcache protocol response handler prototype */
+typedef ngx_int_t (*mcp_handler)
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+
+/* memcache protocol response processing functions */
+static ngx_int_t ngx_memcache_process_add_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_add_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_add_invalid
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_delete_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_delete_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_get_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_get_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_incr_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_incr_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_decr_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_decr_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_error
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_client_error
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_server_error
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_error_line
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+static ngx_int_t ngx_memcache_process_any_response
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed);
+
+/* hashing functions to elect a memcached server for caching */
+static ngx_uint_t ngx_memcache_hash (u_char *key, size_t len);
+static ngx_uint_t ngx_memcache_perl_hash (u_char *key, size_t len);
+
+/* generic event handler to read any memcache response */
+static void ngx_memcache_any_read_handler (ngx_event_t *rev);
+static void ngx_memcache_dummy_write_handler (ngx_event_t *wev);
+static void ngx_memcache_reconnection_handler (ngx_event_t *ev);
+static inline void ngx_memcache_callback (mc_work_t * w);
+
+/* Workqueue and connection maintenance functions */
+static inline mc_workqueue_t *ngx_memcache_wq_front (mc_workqueue_t *head);
+static inline ngx_int_t ngx_memcache_wq_isempty (mc_workqueue_t *head);
+static void ngx_memcache_purge_connection_workqueue (mc_context_t *mcctx, mc_response_code_t res);
+static void ngx_memcache_reestablish_connection (mc_context_t *mcctx);
+static inline void ngx_memcache_close_connection (ngx_peer_connection_t *pc);
+static inline void ngx_memcache_prepare_reconnection (mc_context_t *mcctx);
+
+/* main post function */
+static void ngx_memcache_do_post(mc_work_t *w, ngx_str_t key, ngx_str_t value,
+        ngx_str_t ttl, ngx_pool_t *p, ngx_log_t *l);
+
+/* other utility */
+static u_char * ngx_memcache_hexstr(u_char* md, int len);
+static ngx_str_t ngx_memcache_create_pdu(ngx_pool_t *pool, mc_work_t *w,
+        ngx_str_t key, ngx_str_t value, ngx_str_t ttl, ngx_log_t * log);
+
+static ngx_command_t ngx_memcache_commands[] =
+{
+    { ngx_string("memcache"),
+      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_memcache_block,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("servers"),
+      NGX_DIRECT_CONF|NGX_MEMCACHE_CONF|NGX_CONF_1MORE,
+      ngx_memcache_servers,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("timeout"),
+      NGX_DIRECT_CONF|NGX_MEMCACHE_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      0,
+      offsetof(ngx_memcache_conf_t, timeout),
+      NULL },
+
+    { ngx_string("reconnect"),
+      NGX_DIRECT_CONF|NGX_MEMCACHE_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      0,
+      offsetof(ngx_memcache_conf_t, reconnect),
+      NULL },
+
+    { ngx_string("ttl"),
+      NGX_DIRECT_CONF|NGX_MEMCACHE_CONF|NGX_CONF_TAKE1,
+      ngx_memcache_ttl,
+      0,
+      offsetof(ngx_memcache_conf_t, ttl),
+      NULL },
+
+    ngx_null_command
+};
+
+static ngx_core_module_t ngx_memcache_module_ctx =
+{
+    ngx_string("memcache"),
+    ngx_memcache_create_conf,
+    ngx_memcache_init_conf
+};
+
+ngx_module_t ngx_memcache_module =
+{
+    NGX_MODULE_V1,
+    &ngx_memcache_module_ctx,           /* module context */
+    ngx_memcache_commands,              /* module directives */
+    NGX_CORE_MODULE,                    /* module type */
+    NULL,                               /* init master */
+    NULL,                               /* init module */
+    ngx_memcache_init_process,          /* init process */
+    NULL,                               /* init thread */
+    NULL,                               /* exit thread */
+    NULL,                               /* exit process */
+    NULL,                               /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+static void *ngx_memcache_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_memcache_conf_t *mcf;
+    ngx_pool_t          *pool;
+    ngx_log_t           *log;
+
+    log = cycle->log;
+    pool = ngx_create_pool (8 * ngx_pagesize, cycle->log);
+
+    mcf = ngx_pcalloc (pool, sizeof(ngx_memcache_conf_t));
+    if (mcf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    mcf->cpool = pool;
+    mcf->log = log;
+
+    if(ngx_array_init (&mcf->servers, mcf->cpool, 4, sizeof(ngx_addr_t*))
+        != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    mcf->timeout = NGX_CONF_UNSET_MSEC;
+    mcf->reconnect = NGX_CONF_UNSET_MSEC;
+    mcf->ttl = NGX_CONF_UNSET_MSEC;
+    mcf->ttl_text.len = 0;
+    mcf->allow_unqualified = NGX_CONF_UNSET;
+
+    ngx_log_error(NGX_LOG_DEBUG_CORE, cycle->log, 0,
+        "memcache - created configuration:%p", mcf);
+    return mcf;
+}
+
+static char *ngx_memcache_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_memcache_conf_t *mcf = conf;
+
+    ngx_conf_init_msec_value(mcf->timeout, 5000);
+    ngx_conf_init_msec_value(mcf->reconnect, 60000);
+    ngx_conf_init_msec_value(mcf->ttl, 0);
+    if (mcf->ttl_text.len == 0) {
+        ngx_str_set(&mcf->ttl_text, "0");
+    }
+    ngx_conf_init_value(mcf->allow_unqualified, 0);
+
+    ngx_log_error(NGX_LOG_DEBUG_CORE,cycle->log, 0,
+        "memcache - initialized config defaults:%p", mcf);
+    return NGX_CONF_OK;
+}
+
+static char* ngx_memcache_ttl(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char      *res;
+    ngx_str_t *value, *ttl;
+    ngx_memcache_conf_t *mcf = (ngx_memcache_conf_t *)conf;
+
+    res = ngx_conf_set_msec_slot(cf, cmd, conf);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    value = cf->args->elts;
+    ttl = &value[1];
+
+    /* trim the last 5 digit 'NNNms' and become the number of seconds
+     * for example, 3600000ms --> 3600 */
+    if (mcf->ttl > 1000) {
+        mcf->ttl_text.data = ttl->data;
+        mcf->ttl_text.len = ttl->len - 5;
+    } else if (mcf->ttl > 0) {
+        /* 0 ~ 1000ms, make it 1 */
+        ngx_str_set(&mcf->ttl_text, "1");
+    } else {
+        /* ttl is 0, so keep the default ttl_text "0" */
+    }
+
+    return NGX_CONF_OK;
+}
+/* per-process initialization routine */
+static ngx_int_t ngx_memcache_init_process(ngx_cycle_t *cycle)
+{
+    ngx_memcache_conf_t     *mcf;
+    ngx_log_t               *log;
+    ngx_pool_t              *pool;
+    ngx_addr_t              *peer,
+                           **peers;
+    ngx_peer_connection_t   *peercxn;
+    mc_context_t            *mcctx;
+    mc_workqueue_t          *mcwq;
+    ngx_int_t                rc;
+    ngx_uint_t               npeers,i;
+    ngx_buf_t               *buff;
+
+    mcf = (ngx_memcache_conf_t*) ngx_get_conf(cycle->conf_ctx, ngx_memcache_module);
+    log = cycle->log;
+    // pool = ngx_create_pool(8*ngx_pagesize,log);
+    pool = mcf->cpool;
+
+    npeers = mcf->servers.nelts;
+    peers = (ngx_addr_t **)mcf->servers.elts;
+
+    rc = ngx_array_init(&mcf->contexts, pool, npeers > 0 ? npeers : 1, sizeof(mc_context_t));
+    if (rc != NGX_OK) {
+        return rc;
+    }
+
+    for ( i = 0; i < npeers; ++i)
+    {
+        peer = peers[i];
+        peercxn = ngx_pcalloc(pool, sizeof(ngx_peer_connection_t));
+        peercxn->sockaddr = peer->sockaddr; /* XXX peer->sockaddr is on cf->pool */
+        peercxn->socklen = peer->socklen;
+        peercxn->name = &peer->name;        /* XXX peer->name is on cf->pool */
+        peercxn->get = ngx_event_get_peer;
+        peercxn->log = log;
+        peercxn->log_error = NGX_ERROR_ERR;
+
+        rc = ngx_event_connect_peer(peercxn);
+
+        if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {
+            ngx_log_error (NGX_LOG_ERR, log, 0,
+                "cannot connect to memcached server %V (rc:%d)",
+                &peer->name, rc);
+
+            if (peercxn->connection) {
+                ngx_close_connection (peercxn->connection);
+            }
+            continue;
+        }
+
+        /* nginx sockets are non-blocking, so connect() returns EINPROGRESS */
+        peercxn->connection->read->handler = ngx_memcache_any_read_handler;
+        peercxn->connection->write->handler = ngx_memcache_dummy_write_handler;
+
+        mcctx = ngx_array_push (&mcf->contexts);
+        ngx_memzero (mcctx, sizeof (mc_context_t));
+        buff = ngx_create_temp_buf (pool, ngx_pagesize);    /* circular buffer */
+        mcctx->readbuffer = buff;
+
+        /* reconnection event */
+        mcctx->reconnect_ev = ngx_palloc (pool, sizeof (ngx_event_t));
+        ngx_memzero (mcctx->reconnect_ev, sizeof (ngx_event_t));
+        mcctx->reconnect_ev->handler = ngx_memcache_reconnection_handler;
+        mcctx->reconnect_ev->log = log;
+
+        /* Initialize the head of the work queue doubly-linked list */
+        mcwq = &mcctx->wq_head;
+        mcwq->w.request_code = mcreq_noop;
+        mcwq->pool = pool;
+        mcwq->prev = mcwq;
+        mcwq->next = mcwq;
+
+        peercxn->connection->data = mcctx;
+        peercxn->connection->log = log;
+
+        mcctx->srvconn  = peercxn;
+        mcctx->srvaddr  = peer;
+        mcctx->status   = mcchan_good;
+        mcctx->timeout  = mcf->timeout;
+        mcctx->cxn_interval = mcf->reconnect;
+        setsockopt(peercxn->connection->fd, SOL_SOCKET, SO_SNDBUF,
+        (void *) &mc_sndbuf_len, sizeof (mc_sndbuf_len));
+    }
+
+    ngx_log_error(NGX_LOG_INFO, log, 0,
+        "memcache: %d/%d connections initialized",
+        mcf->contexts.nelts, mcf->servers.nelts);
+
+    return NGX_OK;
+}
+
+static char *ngx_memcache_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_conf_t  ocf;
+    char        *rc;
+
+    ocf = *cf;
+
+    cf->ctx = cf->cycle->conf_ctx;
+    cf->module_type = NGX_CORE_MODULE;
+    cf->cmd_type = NGX_MEMCACHE_CONF;
+
+    rc = ngx_conf_parse(cf, NULL);
+
+    *cf = ocf;
+
+    return rc;
+}
+
+static char *
+ngx_memcache_servers (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_memcache_conf_t     *mcf = conf;
+    ngx_addr_t              **server;
+    ngx_uint_t               i;
+    ngx_url_t                u;
+
+    for (i = 1; i < cf->args->nelts; ++i)
+    {
+        server = ngx_array_push(&mcf->servers);
+        if (server == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        *server = NULL;
+
+        ngx_memzero(&u, sizeof(u));
+        u.url = ((ngx_str_t *)cf->args->elts)[i];
+        u.default_port = 11211;
+        u.uri_part = 1;
+
+        /* note - since ngx_parse_url uses pools from cf, therefore all address
+           structures in *server will be allocated on the config pool instead
+           of the memcached pool
+         */
+        if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+            if (u.err) {
+                ngx_log_error(NGX_LOG_ERR, cf->cycle->log, 0,
+                    "%s in memcache:server %V", u.err, &u.url);
+            }
+            return NGX_CONF_ERROR;
+        }
+
+        *server = u.addrs;
+    }
+
+    return NGX_CONF_OK;
+}
+
+/* Work queue manipulation functions */
+static inline mc_workqueue_t *ngx_memcache_wq_front (mc_workqueue_t *head)
+{
+    return head->next;
+}
+
+mc_workqueue_t *ngx_memcache_wq_enqueue (mc_workqueue_t *head, mc_workqueue_t *wqe)
+{
+    wqe->prev = head->prev;
+    wqe->next = head;
+    wqe->prev->next = wqe;
+    wqe->next->prev = wqe;
+    return wqe;
+}
+
+mc_workqueue_t *ngx_memcache_wq_dequeue (mc_workqueue_t *head)
+{
+    mc_workqueue_t  *wqe;
+
+    wqe = head->next;
+
+    if (wqe != head)
+    {
+        wqe->prev->next = wqe->next;
+        wqe->next->prev = wqe->prev;
+        wqe->prev = NULL;
+        wqe->next = NULL;
+    }
+
+    return wqe;
+}
+
+static inline ngx_int_t ngx_memcache_wq_isempty (mc_workqueue_t *head)
+{
+    return (ngx_memcache_wq_front(head) == head);
+}
+
+/* Ignore a work entry in memcache work queue. This should be done if
+ * the ctx who initiated the memcache request is destroyed before
+ * memcache server returns. Otherwise, when response is coming, the
+ * invalid ctx may be callback and reused.
+ *
+ * Any work entry in the queue whose ctx is equal to the specified one
+ * will be ignored.
+ *
+ * */
+void ngx_memcache_ignore_work_by_ctx (void * ctx) {
+    mc_workqueue_t      * head, * entry;
+    ngx_memcache_conf_t * mcf;
+    mc_context_t        * contexts;
+    ngx_uint_t            i;
+
+    mcf = (ngx_memcache_conf_t *)
+    ngx_get_conf(ngx_cycle->conf_ctx, ngx_memcache_module);
+    contexts = (mc_context_t *)mcf->contexts.elts;
+    for (i = 0; i < mcf->contexts.nelts; i++) {
+        mc_context_t * context = contexts + i;
+        head = &context->wq_head;
+        if (!ngx_memcache_wq_isempty(head)) {
+            entry = head->next;
+            while (entry->w.request_code != mcreq_noop) {
+                if ((void *) entry->w.ctx == (void *) ctx ) {
+                    // mark it NULL and ignored later
+                    entry->w.ctx = NULL;
+                }
+                entry = entry->next;
+            }
+        }
+    }
+}
+
+/* Post a memcached request onto the workqueue of a memcached server
+   w    work request describing the task
+        (also contains on_success/on_failure handlers)
+   k    opaque key which will be used for calculating the server hash
+   value  the data which should be sent to the memcached server
+   p    the pool from which additional memory may be allocated as needed
+   l    log object for debug/informational messages
+ */
+void ngx_memcache_post (
+     mc_work_t      *w,
+     ngx_str_t       key,
+     ngx_str_t       value,
+     ngx_pool_t     *p,
+     ngx_log_t      *l
+    )
+{
+    ngx_str_t dummy_ttl = ngx_string("-1");
+    ngx_memcache_post_with_ttl (w, key, value, dummy_ttl, p, l);
+}
+
+void ngx_memcache_post_with_ttl (
+        mc_work_t      *w,
+        ngx_str_t       key,
+        ngx_str_t       value,
+        ngx_str_t       ttl,
+        ngx_pool_t     *p,
+        ngx_log_t      *l) {
+    ngx_memcache_do_post(w, key, value, ttl, p, l);
+}
+
+static void
+ngx_memcache_do_post (
+     mc_work_t      *w,
+     ngx_str_t       key,
+     ngx_str_t       value,
+     ngx_str_t       ttl,
+     ngx_pool_t     *p,
+     ngx_log_t      *l
+    )
+{
+    ngx_uint_t       h;
+    size_t           t;
+    ssize_t          n;
+    mc_context_t    *mcctx;
+    mc_workqueue_t  *r;
+    ngx_memcache_conf_t  *mcf;
+    mc_context_t    *contexts;
+    ngx_flag_t      locked = 0;
+    ngx_flag_t      reclaim = 0;
+    ngx_str_t       pdu;
+
+    mcf = (ngx_memcache_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_memcache_module);
+    contexts = (mc_context_t *)mcf->contexts.elts;
+
+    h = ngx_memcache_hash(key.data, key.len);
+
+    if (h == MC_INVALID_HASH)
+    {
+        ngx_log_error (NGX_LOG_NOTICE, l, 0,
+            "no memcache server available, cannot post request");
+        w->response_code = mcres_failure_unavailable;
+        w->on_failure(w);
+        return;
+    }
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, l, 0,
+        "posting memcache request to cache server #%d", h);
+    mcctx =  contexts + h;
+
+    if (p == NULL) {
+        p = ngx_create_pool(MC_REQ_POOL_SIZE, l);
+        if (p == NULL) {
+            w->response_code = mcres_failure_unavailable;
+            w->on_failure(w);
+            return;
+        }
+        reclaim = 1;
+    }
+
+    pdu = ngx_memcache_create_pdu(p, w, key, value, ttl, l);
+    if (pdu.data == NULL) {
+        w->response_code = mcres_failure_normal;
+        w->on_failure(w);
+        return;
+    }
+
+    /* build up the request to enqueue on the workqueue
+       we build up the request earlier on, so that if
+       memory errors occur, we would not have posted a pdu
+       on the memcached channel that we cannot handle
+     */
+
+    r = ngx_pcalloc(p, sizeof(mc_workqueue_t));
+    if (r == NULL) {
+        w->response_code = mcres_failure_unavailable;
+        w->on_failure(w);
+        return;
+    }
+
+    if (ngx_log_tid && mcctx->lock != ngx_log_tid) {
+        ngx_spinlock(&mcctx->lock, ngx_log_tid, 40);
+        locked = 1;
+    }
+    t = 0;
+    while (t < pdu.len)
+    {
+        n = ngx_send (mcctx->srvconn->connection, pdu.data + t, pdu.len - t);
+        if (n > 0) {
+            t += n;
+            if (mcctx->status == mcchan_reconnect) {
+                mcctx->status = mcchan_good;
+            }
+        } else {
+            if (locked)
+                ngx_unlock(&mcctx->lock);
+
+            ngx_log_error (NGX_LOG_NOTICE, l, 0,
+                    "memcached channel %V orderly shutdown when posting request",
+                    mcctx->srvconn->name);
+
+            mcctx->status = mcchan_bad;
+            ngx_memcache_close_connection (mcctx->srvconn);
+            ngx_memcache_purge_connection_workqueue
+                            (mcctx, mcres_failure_again);
+            ngx_memcache_prepare_reconnection(mcctx);
+            w->response_code = mcres_failure_again;
+            w->on_failure(w);
+            return;
+        }
+    }
+
+    if (t == pdu.len)
+    {
+        /* set the read timeout on the server channel *only* if there is no
+           outstanding timer set already (this is to opportunistically catch
+           any responses before the stipulated timeout
+         */
+
+        if (!mcctx->srvconn->connection->read->timer_set) {
+            ngx_add_timer (mcctx->srvconn->connection->read, mcctx->timeout);
+        }
+
+       /* ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, ngx_cycle->log, 0,
+                "XXX post requst:%V", &pdu);*/
+    }
+
+    r->pool = p;
+    r->reclaim = reclaim;
+    r->w = *w;
+    r->w.response_code = mcres_unknown;
+
+    ngx_memcache_wq_enqueue (&mcctx->wq_head, r);
+
+    if (locked)
+        ngx_unlock(&mcctx->lock);
+    ngx_log_debug2 (NGX_LOG_DEBUG_CORE, l, 0, "posted request(%p) on server #%d",
+                    r, h);
+
+    return;
+}
+
+/* memcache protocol handling routines */
+
+/* process successful add response */
+static ngx_int_t ngx_memcache_process_add_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("STORED") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "STORED" CRLF, sizeof("STORED" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream, size, wq, consumed);
+    }
+
+    *consumed = sizeof ("STORED" CRLF) - 1;
+    wq->w.response_code = mcres_success;
+
+    return NGX_OK;
+}
+
+/* process unsuccessful add response */
+static ngx_int_t ngx_memcache_process_add_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("NOT_STORED") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "NOT_STORED" CRLF, sizeof("NOT_STORED" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream, size, wq, consumed);
+    }
+
+    *consumed = sizeof ("NOT_STORED" CRLF) - 1;
+    wq->w.response_code = mcres_failure_normal;
+
+    return NGX_OK;
+}
+
+/*
+ *  process the invalid add command. If the key in add command too long,
+ *  memcached will return 2 error msgs for "add <key> <flag> <ttl> <len>CRLF"
+ *  and the "<value>CRLF" respectively. It should be:
+ *  CLIENT_ERROR bad command line format\r\nERROR\r\n
+ */
+static ngx_int_t ngx_memcache_process_add_invalid
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t len;
+    len = sizeof ("CLIENT_ERROR bad command line format" CRLF) - 1 +
+                  sizeof ("ERROR" CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "CLIENT_ERROR bad command line format" CRLF
+                            "ERROR" CRLF,
+                    len))
+    {
+        return ngx_memcache_process_error_line(stream, size, wq, consumed);
+    }
+
+    *consumed = len;
+    wq->w.response_code = mcres_failure_input;
+
+    ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+            "memcached return error message: "
+            "CLIENT_ERROR bad command line format ERROR");
+
+    return NGX_OK;
+}
+
+/* process successful delete response */
+static ngx_int_t ngx_memcache_process_delete_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("DELETED") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "DELETED" CRLF, sizeof("DELETED" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream, size, wq, consumed);
+    }
+
+    *consumed = sizeof ("DELETED" CRLF) - 1;
+    wq->w.response_code = mcres_success;
+
+    return NGX_OK;
+}
+
+/* handle unsuccessful delete response */
+static ngx_int_t ngx_memcache_process_delete_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("NOT_FOUND") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "NOT_FOUND" CRLF, sizeof("NOT_FOUND" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream,size,wq,consumed);
+    }
+
+    *consumed = sizeof ("NOT_FOUND" CRLF) - 1;
+    wq->w.response_code = mcres_failure_normal;
+
+    return NGX_OK;
+}
+
+/* process successful get response */
+static ngx_int_t ngx_memcache_process_get_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    /* A successful `get' response looks like:
+
+       VALUE keyname flag size
+       <size bytes of data>
+       END
+
+       A successful `get' response must be at least as long as:
+
+       VALUE K F S
+       b
+       END
+     */
+
+    enum {
+                rr_value_read,
+                rr_key_read,
+                rr_flag_read,
+                rr_size_read,
+                rr_data_read,
+                rr_end_read
+    } state;
+
+    size_t      minimum_len;
+    u_char      *p;
+    /* size_t      tokenpos; */
+    /* ngx_str_t   key = ngx_string (""); */
+    ngx_str_t   value = ngx_string ("");
+    size_t      value_size;
+    uint16_t    flag;
+
+    minimum_len =
+                sizeof ("VALUE ") - 1 +
+                sizeof ("k ") - 1 +
+                sizeof ("0 ") - 1 +
+                sizeof ("0 ") - 1 +
+                sizeof (CRLF) - 1 +
+                sizeof (CRLF) - 1 +
+                sizeof ("END") - 1 +
+                sizeof (CRLF) -1;
+
+    p = stream;
+    *consumed = 0;
+    value_size = 0;
+
+    /* If there is not enough space to even hold a bare minimum response,
+     then we cannot proceed */
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "VALUE ", sizeof ("VALUE ") - 1))
+    {
+        return ngx_memcache_process_error_line(stream,size,wq,consumed);
+    }
+
+    p += (sizeof ("VALUE ") - 1);
+    *consumed += (sizeof ("VALUE ") - 1);
+    state = rr_value_read;
+
+    for (;(p < stream + size) && (state != rr_end_read); ++p, ++*consumed)
+    {
+        switch (state)
+        {
+            case rr_value_read:
+                /* now we're expecting the key name */
+                /* tokenpos = *consumed; */
+
+                while ((p < stream + size) && (*p != ' '))
+                {
+                    ++p;
+                    ++*consumed;
+                }
+
+                if (p == stream + size)
+                {
+                    /* end of stream */
+                    --p; --*consumed;
+                }
+                else
+                {
+                    /* The key is constructed */
+                    /* key.data = stream + tokenpos; */
+                    /* key.len = *consumed - tokenpos; */
+
+                    state = rr_key_read;
+                }
+
+                break;
+
+            case rr_key_read:
+                /* now we're expecting a flag, which is a short integer
+                   which corresponds to the `flags' argument to mc_add
+                   To avoid looping more than is necessary, we'll play a
+                   simple trick, which is to initialize the flag to 0,
+                   and then keep *10 + the current digit encountered
+                 */
+
+                flag = 0;
+
+                while ((p < stream + size) && (*p != ' '))
+                {
+                   flag = (flag * 10) + *p;
+                   ++p;
+                   ++*consumed;
+                }
+
+                if (p == stream + size)
+                {
+                   --p; --*consumed;
+                }
+                else
+                {
+                   /* The flag is constructed */
+
+                   state = rr_flag_read;
+                }
+
+                break;
+
+            case rr_flag_read:
+                /* now we're expecting the size of the data
+                 */
+                value_size = 0;
+
+                while ((p < stream + size)
+                       && (*p != ' ')      /* wasteful ? */
+                       && (*p != CR)
+                       && (*p != LF)       /* wasteful ? */
+                      )
+                {
+                   value_size = (value_size * 10) + (*p - '0');
+                   ++p;
+                   ++*consumed;
+                }
+
+                if (p == stream + size)
+                {
+                   --p; --*consumed;
+                }
+                else
+                {
+                   /* The size is constructed */
+                   state = rr_size_read;
+                }
+
+                break;
+
+            case rr_size_read:
+                /* now we're looking out for the data
+                   the '\r' has already been consumed in the for loop
+                   so we must look beyond the '\n', and then read
+                   value_size bytes more from the stream
+                */
+
+                while ((p < stream + size) && (*p != LF))
+                {
+                    ++p; ++*consumed;
+                }
+
+                if (p == stream + size)
+                {
+                    --p; --*consumed;
+                }
+                else
+                {
+                    /* now p is pointing at the line feed preceding the data */
+
+                    ++p; ++*consumed;
+
+                    if (p == stream + size)
+                    {
+                        --p; --*consumed;
+                    }
+                    else
+                    {
+                        minimum_len =
+                            value_size +
+                            sizeof (CRLF) - 1 +
+                            sizeof ("END") - 1 +
+                            sizeof (CRLF) - 1;
+
+
+                        if (size - *consumed < minimum_len)
+                        {
+                            /* request cannot be completed here */
+                        }
+                        else
+                        {
+                            /* we have the value, starting at p */
+                            value.data = p;
+                            value.len = value_size;
+
+                            /* now just advance in one shot till the end */
+
+                            p+= value_size; *consumed += value_size;
+
+                            /* And now, just consume the following CR too
+                               so that the END context lands bingo at END
+                             */
+
+                            state = rr_data_read;
+
+                            if (*p == CR)     /* this is superfluous */
+                            {
+                                ++p; ++*consumed;
+                            }
+                        }
+                    }
+                }
+
+                break;
+
+            case rr_data_read:
+                /* we know that sufficient bytes are present, and that we
+                   should be looking at "END"
+                 */
+
+                if (ngx_memcmp (p, "END" CRLF, sizeof ("END" CRLF) - 1))
+                {
+                   /* not possible. try logging here */
+                }
+                else
+                {
+                   state = rr_end_read;
+
+                   p += (sizeof ("END") - 1);
+                   *consumed += (sizeof ("END") - 1);
+
+                   /* again, we will consume the CR so that we break out at
+                      once */
+
+                   if (*p == CR)    /* superfluous */
+                   {
+                       ++p;
+                       ++*consumed;
+                   }
+                }
+
+                break;
+
+             default:
+                break;
+        }
+    }
+
+    if (state != rr_end_read)
+    {
+        return NGX_AGAIN;       /* This means there wasn't enough data */
+    }
+
+    /* we've finished processing the get response */
+
+    wq->w.payload.data = ngx_pstrdup (wq->pool, &value);
+    wq->w.payload.len = value.len;
+    wq->w.response_code = mcres_success;
+
+    return NGX_OK;
+}
+
+/* process unsuccessful get response */
+static ngx_int_t ngx_memcache_process_get_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("END") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "END" CRLF, sizeof("END" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream,size,wq,consumed);
+    }
+
+    *consumed = sizeof ("END" CRLF) - 1;
+    wq->w.response_code = mcres_failure_normal;
+
+    return NGX_OK;
+}
+
+static ngx_int_t ngx_memcache_process_incr_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    u_char *p;
+
+    p = stream;
+
+    while ((p < stream + size) && (*p != CR) && (*p != LF))
+    {
+        if (!(*p >= '0' && *p <= '9')) {
+            return ngx_memcache_process_error_line(stream, size, wq, consumed);
+        }
+
+        ++p;
+        ++*consumed;
+    }
+
+    if (p == stream + size) {
+        return NGX_AGAIN;
+    } else {
+        if (size - *consumed >= 2)
+        {
+            if (*p == CR && *(p + 1) == LF)
+            {
+                *consumed += 2;
+                wq->w.payload.len = p - stream;
+                wq->w.payload.data = ngx_palloc(wq->pool, wq->w.payload.len);
+                ngx_memcpy (wq->w.payload.data,stream, wq->w.payload.len);
+                wq->w.response_code = mcres_success;
+                return NGX_OK;
+            }
+            else
+            {
+                return ngx_memcache_process_error_line(stream, size, wq, consumed);
+            }
+        }
+        else
+        {
+            return NGX_AGAIN;
+        }
+    }
+}
+
+static ngx_int_t ngx_memcache_process_incr_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("NOT_FOUND") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "NOT_FOUND" CRLF, sizeof ("NOT_FOUND" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream, size, wq, consumed);
+    }
+
+    *consumed = sizeof ("NOT_FOUND" CRLF) - 1;
+    wq->w.response_code = mcres_failure_normal;
+
+    return NGX_OK;
+}
+
+static ngx_int_t ngx_memcache_process_decr_ok
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    u_char *p;
+
+    p = stream;
+
+    while ((p < stream+size) && (*p != CR) && (*p != LF))
+    {
+        if (!(*p>='0' && *p<='9')) {
+            return ngx_memcache_process_error_line(stream, size, wq, consumed);
+        }
+
+        ++p;
+        ++*consumed;
+    }
+
+    if (p == stream + size) {
+        return NGX_AGAIN;
+    } else {
+        if (size - *consumed >= 2)
+        {
+            if (*p == CR && *(p+1) == LF)
+            {
+                *consumed += 2;
+                wq->w.payload.len = p-stream;
+                wq->w.payload.data = ngx_palloc(wq->pool,wq->w.payload.len);
+                ngx_memcpy (wq->w.payload.data,stream,wq->w.payload.len);
+                wq->w.response_code = mcres_success;
+                return NGX_OK;
+            }
+            else
+            {
+                return ngx_memcache_process_error_line(stream, size, wq, consumed);
+            }
+        }
+        else
+        {
+            return NGX_AGAIN;
+        }
+    }
+}
+
+static ngx_int_t ngx_memcache_process_decr_failed
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("NOT_FOUND") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "NOT_FOUND" CRLF, sizeof ("NOT_FOUND" CRLF) - 1))
+    {
+        return ngx_memcache_process_error_line(stream, size, wq, consumed);
+    }
+
+    *consumed = sizeof ("NOT_FOUND" CRLF) - 1;
+    wq->w.response_code = mcres_failure_normal;
+
+    return NGX_OK;
+}
+
+/* process "ERROR\r\n" */
+static ngx_int_t ngx_memcache_process_error
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+
+    minimum_len = sizeof ("ERROR") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "ERROR" CRLF, sizeof ("ERROR" CRLF) - 1))
+    {
+        return NGX_ERROR;
+    }
+
+    *consumed = sizeof ("ERROR" CRLF) - 1;
+
+    ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+            "memcached return error message: ERROR");
+
+    wq->w.response_code = mcres_failure_input;
+    return NGX_OK;
+}
+
+static ngx_int_t ngx_memcache_process_client_error
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+    u_char *p;
+    minimum_len = sizeof ("CLIENT_ERROR") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "CLIENT_ERROR", sizeof ("CLIENT_ERROR") - 1))
+    {
+        return NGX_ERROR;
+    }
+
+    p = stream + sizeof ("CLIENT_ERROR") - 1;
+    *consumed = sizeof ("CLIENT_ERROR") - 1;
+    while ((p < stream + size) && (*p != LF))
+    {
+        ++p; ++*consumed;
+    }
+
+    if (*p != LF || *(p - 1) != CR)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (p < stream + size)
+    {
+        ++p;
+        ++*consumed;
+    }
+
+    ngx_str_t log_output;
+    log_output.data = stream;
+    log_output.len = *consumed - 2; //chomp the trailing CRLF
+
+    ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+            "memcached return error message: %V", &log_output);
+
+    wq->w.response_code = mcres_failure_input;
+    return NGX_OK;
+}
+
+static ngx_int_t ngx_memcache_process_server_error
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    size_t minimum_len;
+    u_char *p;
+    minimum_len = sizeof ("SERVER_ERROR") - 1 +
+                  sizeof (CRLF) - 1;
+
+    *consumed = 0;
+
+    if (size < minimum_len)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (ngx_memcmp (stream, "SERVER_ERROR", sizeof ("SERVER_ERROR") - 1))
+    {
+        return NGX_ERROR;
+    }
+
+    p = stream + sizeof ("SERVER_ERROR") - 1;
+    *consumed = sizeof ("SERVER_ERROR") - 1;
+    while ((p < stream + size) && (*p != LF))
+    {
+        ++p; ++*consumed;
+    }
+
+    if (*p != LF || *(p - 1) != CR)
+    {
+        return NGX_AGAIN;
+    }
+
+    if (p < stream + size)
+    {
+        ++p;
+        ++*consumed;
+    }
+
+    ngx_str_t log_output;
+    log_output.data = stream;
+    log_output.len = *consumed - 2; //chomp the trailing CRLF
+
+    ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+            "memcached return error message: %V", &log_output);
+
+    wq->w.response_code = mcres_failure_again;
+    return NGX_OK;
+}
+
+/* consume a line of error message or unexcepted response,
+ * including ERROR, SERVER_ERROR and CLIENT_ERROR, as well as
+ * other unrecognized ones.
+ * Returns:
+ * NGX_OK: handle correctly and continue the next qork queue entry
+ * NGX_ERROR: server is bad, has to close connection and purge work
+ *            queue
+ * NGX_AGAIN: recv more bytes to complete handling */
+static ngx_int_t ngx_memcache_process_error_line
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    u_char *p;
+    ngx_int_t rc = NGX_ERROR;
+
+    p = stream;
+    *consumed = 0;
+
+    if (*p == 'E') {
+        /* memcached return 'ERROR CRLF' */
+        rc = ngx_memcache_process_error (stream, size, wq, consumed);
+    } else if (*p == 'C' ) {
+        /* memcached return 'CLIENT_ERROR <message> CRLF' */
+        rc = ngx_memcache_process_client_error (stream, size, wq, consumed);
+    } else if (*p == 'S') {
+        /* memcached return 'SERVER_ERROR <message> CRLF'
+         * if it's a valid SERVER_ERROR, we still have
+         * to return NGX_ERROR to close the connection to current
+         * channel and purge the queue. Therefore, all the buffered bytes
+         * has to be chomped here.
+         */
+        rc = ngx_memcache_process_server_error (stream, size, wq, consumed);
+        if (rc == NGX_OK) {
+            /* chomp all the received raw bytes in buffer */
+            *consumed = size;
+            ngx_str_t log_output;
+            log_output.data = stream;
+            log_output.len = *consumed;
+            ngx_log_error (NGX_LOG_ERR, ngx_cycle->log, 0,
+                    "memcached returns SERVER_ERROR, "
+                    "chomp all %d bytes in buffer: %V",
+                    *consumed, &log_output);
+            return NGX_ERROR;
+        }
+    }
+
+    if (rc == NGX_OK || rc == NGX_AGAIN) {
+        return rc;
+    } else  {
+        /* the response is unrecognized,
+         * chomp all the received raw bytes in buffer */
+        *consumed = size;
+
+        ngx_str_t log_output;
+        log_output.data = stream;
+        log_output.len = size;
+        ngx_log_error (NGX_LOG_ERR, ngx_cycle->log, 0,
+                "memcached returns unrecognized response, "
+                "chomp all %d bytes in buffer: %V",
+                *consumed, &log_output);
+        return NGX_ERROR;
+    }
+}
+
+/* process response to any memcached command
+   with the advent of more supported operations, we need more context in
+   order to process the response to a previously submitted command
+   that is because responses to some memcached commands are identical
+
+   see docs/MEMCACHE-PROTOCOL for details
+ */
+ngx_int_t ngx_memcache_process_any_response
+    (u_char *stream, size_t size, mc_workqueue_t *wq, size_t *consumed)
+{
+    mcp_handler         handler;
+    mc_request_code_t   op;
+
+    *consumed = 0;
+    if (size == 0) { return NGX_AGAIN; }
+
+    op = wq->w.request_code;
+
+    switch (op)
+    {
+        case mcreq_add:
+            switch (*stream)
+            {
+                case 'S':   /* STORED */
+                    handler = ngx_memcache_process_add_ok;
+                    break;
+                case 'N':   /* NOT_STORED */
+                    handler = ngx_memcache_process_add_failed;
+                    break;
+                case 'C':   /* CLIENT_ERROR msg<CR><LF>ERROR<CR><LF> */
+                    handler = ngx_memcache_process_add_invalid;
+                    break;
+                default:
+                    handler = ngx_memcache_process_error_line;
+                    break;
+            }
+            break;
+        case mcreq_get:
+            switch (*stream)
+            {
+                case 'V':   /* VALUE */
+                    handler = ngx_memcache_process_get_ok;
+                    break;
+                case 'E':   /* END */
+                    handler = ngx_memcache_process_get_failed;
+                    break;
+                default:
+                    handler = ngx_memcache_process_error_line;
+                    break;
+            }
+            break;
+        case mcreq_delete:
+            switch (*stream)
+            {
+                case 'D':   /* DELETED */
+                    handler = ngx_memcache_process_delete_ok;
+                    break;
+                case 'N':   /* NOT_FOUND */
+                    handler = ngx_memcache_process_delete_failed;
+                    break;
+                default:
+                    handler = ngx_memcache_process_error_line;
+                    break;
+            }
+            break;
+        case mcreq_incr:
+            if (*stream == 'N') /* NOT_FOUND */ {
+                handler = ngx_memcache_process_incr_failed;
+            } else {
+                handler = ngx_memcache_process_incr_ok;
+            }
+            break;
+        case mcreq_decr:
+            if (*stream == 'N') /* NOT_FOUND */ {
+                handler = ngx_memcache_process_decr_failed;
+            } else {
+                handler = ngx_memcache_process_decr_ok;
+            }
+            break;
+        default:
+            handler = ngx_memcache_process_error_line;
+            break;
+    }
+
+    return handler (stream, size, wq, consumed);
+}
+
+static void ngx_memcache_dummy_write_handler (ngx_event_t *wev)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, wev->log, 0,
+                   "dummy memcache write-event handler");
+}
+
+/* Generic memcache response event handler (see docs/MEMCACHE-PROTOCOL) */
+static void ngx_memcache_any_read_handler(ngx_event_t *rev)
+{
+    ngx_connection_t                *c;
+    mc_context_t                    *ctx;
+    size_t                           available, consumed;
+    ssize_t                          n;
+    ngx_buf_t                       *readbuffer;
+    /* volatile */ mc_workqueue_t   *wq_head;
+    mc_workqueue_t                  *wq_entry;
+    ngx_int_t                        rc;
+    ngx_flag_t                       reclaim;
+
+    c           = rev->data;
+    ctx         = c->data;
+    readbuffer  = ctx->readbuffer;
+    wq_head     = &ctx->wq_head;
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
+                "memcached read event:%V", ctx->srvconn->name);
+
+    if (ctx->status == mcchan_bad) {
+        ngx_log_error (NGX_LOG_ERR, ngx_cycle->log, 0,
+                "ngx_memcache_any_read_handler should always be "
+                "callback when channel status is \"good\" or "
+                "\"reconnect\"");
+    }
+
+    /* nginx buffer
+
+       [[s]......[p]......[l].......[e]]
+
+       s = start
+       p = pos
+       l = last
+       e = end
+
+     */
+
+    /* TODO Why here is not locked ??? */
+    available = readbuffer->end - readbuffer->last;
+
+    if (available == 0)
+    {
+        /* no space in circular buffer to read the responses */
+
+        ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
+            "recycle circular buffer:%d bytes",
+            readbuffer->pos - readbuffer->start
+        );
+
+        memmove (readbuffer->start, readbuffer->pos,
+                    readbuffer->last - readbuffer->pos);
+
+        readbuffer->last -= (readbuffer->pos - readbuffer->start);
+        readbuffer->pos = readbuffer->start;
+
+        available = readbuffer->end - readbuffer->last;
+
+        if (available == 0)
+        {
+            ngx_log_error (NGX_LOG_CRIT, ngx_cycle->log, 0,
+                "cannot recycle circular buffer");
+
+            /* TODO how to recover ? */
+            return;
+        }
+
+        /* note: recursive call has been removed */
+    }
+
+    if (ngx_log_tid && ctx->lock == ngx_log_tid) {
+        ngx_log_error (NGX_LOG_CRIT, ngx_cycle->log, 0,
+            "memcached loop");
+        return;
+    } else {
+        ngx_spinlock(&ctx->lock, ngx_log_tid, 40);
+    }
+
+    if (rev->timedout)
+    {
+        /* read timed out */
+        ngx_log_error (NGX_LOG_INFO, ngx_cycle->log, 0,
+            "memcached channel:%V timed out", ctx->srvconn->name);
+
+        ctx->status = mcchan_bad;
+        ngx_memcache_close_connection (ctx->srvconn);
+        ngx_memcache_purge_connection_workqueue (ctx, mcres_failure_again);
+        ngx_memcache_prepare_reconnection (ctx); // schedule reconnection event
+
+        ngx_unlock(&ctx->lock);
+        return;
+    }
+
+    n = ngx_recv (c, readbuffer->last, available);
+
+    if (rev->eof)
+    {
+        /* recv() zero bytes implies peer orderly shutdown (recv(2)) */
+        ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+            "memcached channel:%V orderly shutdown", ctx->srvconn->name);
+
+        /* channel was hitherto good, don't reconnect immediately, rather
+           wait for cxn_interval before reconnecting
+         */
+        ctx->status = mcchan_bad;
+        ngx_memcache_close_connection (ctx->srvconn);
+        ngx_memcache_purge_connection_workqueue (ctx, mcres_failure_again);
+        ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, ngx_cycle->log, 0,
+            "bad memcached channel:%V, reconnect:%d ms",
+            ctx->srvconn->name, ctx->cxn_interval);
+        ngx_memcache_prepare_reconnection(ctx);
+
+        if (rev->timer_set) {
+            ngx_del_timer (rev);
+        }
+        ngx_unlock(&ctx->lock);
+        return;
+
+    }
+    else if (n == NGX_AGAIN)
+    {
+        /* EAGAIN should have resulted in a timeout which has been
+           handled previously
+         */
+        ngx_log_error (NGX_LOG_WARN, ngx_cycle->log, 0,
+            "ignoring *AGAIN on memcached channel %V", ctx->srvconn->name);
+
+        ngx_unlock(&ctx->lock);
+        return;
+
+    }
+    else if (n == NGX_ERROR)
+    {
+        /* After trying to reconnection, and then reach here, it indicates
+         * that the reconnection fails because target server is not available
+         */
+        if (ctx->status == mcchan_reconnect) {
+            ctx->status = mcchan_bad;
+            ngx_log_error (NGX_LOG_ERR, ngx_cycle->log, 0,
+                    "reconnect to memcached channel %V fails", ctx->srvconn->name);
+            ngx_memcache_close_connection (ctx->srvconn);
+            ngx_memcache_prepare_reconnection(ctx);
+            ngx_unlock(&ctx->lock);
+            return;
+        }
+        /* There was an error reading from this socket */
+        ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
+            "memcached channel %V:error in recv, purging queue",
+            ctx->srvconn->name
+            );
+        ctx->status = mcchan_bad;
+        ngx_memcache_close_connection (ctx->srvconn);
+        ngx_memcache_purge_connection_workqueue (ctx, mcres_failure_again);
+        ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, ngx_cycle->log, 0,
+            "bad memcached channel:%V, reconnect:%d ms",
+            ctx->srvconn->name, ctx->cxn_interval);
+        ngx_memcache_prepare_reconnection(ctx);
+        if (rev->timer_set) {
+            ngx_del_timer (rev);
+        }
+        ngx_unlock(&ctx->lock);
+        return;
+    }
+
+    readbuffer->last += n;
+
+    if (rev->timer_set) {
+        ngx_del_timer (rev);
+    }
+
+    if (ngx_memcache_wq_isempty (wq_head))
+    {
+        ctx->readbuffer->pos = ctx->readbuffer->last;
+        ngx_unlock(&ctx->lock);
+        ngx_log_error (NGX_LOG_WARN, ngx_cycle->log, 0,
+          "memcached channel %V:discard %d bytes(bad data), reset buffer",
+          ctx->srvconn->name, n);
+
+        return;
+    }
+
+    while ((!ngx_memcache_wq_isempty (wq_head)) && ((readbuffer->last - readbuffer->pos) > 0))
+    {
+        wq_entry = ngx_memcache_wq_front (wq_head);
+        consumed = 0;
+
+        rc = ngx_memcache_process_any_response (
+                readbuffer->pos,
+                readbuffer->last - readbuffer->pos,
+                wq_entry,
+                &consumed);
+
+        ngx_log_debug2 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
+            "memcache proto-handler consumed:%d,rc:%d", consumed, rc
+            );
+
+        if (rc == NGX_OK)
+        {
+            readbuffer->pos += consumed;
+
+            /* correct response, so dequeue entry */
+            wq_entry = ngx_memcache_wq_dequeue (wq_head);
+
+            reclaim = wq_entry->reclaim;
+            ngx_memcache_callback (&wq_entry->w);
+            if (reclaim) { // free the memory if allocated from memcache request pool
+                ngx_destroy_pool(wq_entry->pool);
+            }
+        }
+        else if (rc == NGX_ERROR)
+        {
+            readbuffer->pos += consumed;
+
+            /* wrong response, purge all the entries (including the current one) */
+            ctx->status = mcchan_bad;
+            ngx_memcache_close_connection (ctx->srvconn);
+            ngx_memcache_purge_connection_workqueue
+                (ctx, mcres_failure_again);
+            ngx_memcache_prepare_reconnection(ctx);
+        }
+        else if (rc == NGX_AGAIN)
+        {
+            /* The response handler has indicated that there isn't sufficient
+               space to read the data, so we must move bytes over to the start
+             */
+
+            ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
+                "proto-handler got partial response, recycling [pos=%d]",
+                readbuffer->pos - readbuffer->start
+            );
+
+            memmove (readbuffer->start, readbuffer->pos,
+                        readbuffer->last - readbuffer->pos);
+
+            readbuffer->last -= (readbuffer->pos - readbuffer->start);
+            readbuffer->pos = readbuffer->start;
+
+            ngx_unlock(&ctx->lock);
+            ngx_memcache_any_read_handler (rev);
+            ngx_spinlock(&ctx->lock, ngx_log_tid, 40);
+
+            break;
+        }
+    } /* while */
+
+    if (!ngx_memcache_wq_isempty (wq_head)) {
+        ngx_add_timer (rev, ctx->timeout);
+    }
+
+    ngx_unlock(&ctx->lock);
+}
+
+/* purge all outstanding connections from memcached work-queue */
+
+static void ngx_memcache_purge_connection_workqueue (mc_context_t *mcctx, mc_response_code_t res)
+{
+    mc_workqueue_t             *head, *entry;
+    ngx_flag_t                  reclaim;
+    ngx_uint_t                  count;
+
+    head = &mcctx->wq_head;
+    if (ngx_memcache_wq_isempty(head))
+        return;
+
+    /*the mcchannel status of current context has to be set as
+      "mcchan_bad" before this function's invoke because the user
+      in the upper layer may retry connection. If status is
+      mcchan_good, the retry may incur an endless recursion */
+    if (mcctx->status == mcchan_good)
+        mcctx->status = mcchan_bad;
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
+        "memcached channel:%V, purging all entries",
+        mcctx->srvconn->name);
+
+    count = 0;
+    while (!ngx_memcache_wq_isempty(head)) {
+        entry = ngx_memcache_wq_dequeue (head);
+        reclaim = entry->reclaim;
+        entry->w.response_code = res;
+        ngx_memcache_callback(&entry->w);
+
+        if (reclaim) {
+            ngx_destroy_pool(entry->pool);
+        }
+        count++;
+    }
+
+    ngx_log_error (NGX_LOG_INFO, ngx_cycle->log, 0,
+        "memcached channel:%V, purged all %d entries",
+        mcctx->srvconn->name, count);
+
+    return;
+}
+
+static inline void ngx_memcache_callback (mc_work_t * w)
+{
+    if (w->ctx != NULL) { //call back only when not ignored
+        if (w->response_code == mcres_success) {
+            w->on_success (w);
+        } else {
+            w->on_failure (w);
+        }
+    }
+}
+
+static inline void ngx_memcache_close_connection (ngx_peer_connection_t * pc) {
+    ngx_close_connection (pc->connection);
+    pc->connection = NULL;
+}
+
+/* This is the routine for re-establishing a memcache connection that has
+   broken down for some reason. Usually, we *expect* this to happen in
+   cases when a memcache server crashes.
+
+   There are interesting effects observed on linux how a connected TCP
+   socket, which is marked in non-blocking mode (as nginx does), behaves
+   when the peer end goes down.
+
+   Firstly, when a connect() is invoked on a socket that's non-blocking,
+   the return code is EINPROGRESS even if the peer is up, or whether it's
+   down at the time (which is the reason why nginx's connection logic
+   in ngx_event_connect_peer explicitly checks for EINPROGRESS, and why we
+   explicitly ignore it)
+
+   Now, there are two very distinct fates of the subsequent send() and recv()
+   calls on the socket, in case something goes(or went) wrong with the peer:
+
+   (*) In the case when the peer was down at the time of connect(), then any
+       send() and recv() immediately fails with ECONNREFUSED.
+
+   (*) In the case when the peer went down at some point after the connect(),
+       then the first send() after this time *appears* to succeed, whereas
+       subsequent send()s fail with EPIPE (broken pipe). recv(), however, as
+       usual, succeeds, but with 0 bytes read
+
+   What this means for us, is that if a memcache connection goes sour because
+   of peer problems, then we can expect ngx_send()s to start failing with
+   EPIPE, whereas our ngx_recv(), which is indirectly invoked via the event
+   handling mechanism, will receive 0 bytes from ngx_recv()
+
+   In both cases, we need to purge the corresponding work queues ASAP, because
+   these may contain pending cache-get requests. A pending cache-get request
+   corresponds to a email connection freshly initiated by a client, and which
+   is requesting for upstream server information in order to initiate the proxy.
+   This is a high priority request, because the proxy initiation is waiting for
+   the result of this operation.
+
+   On the other hand, a pending cache-add request corresponds to a proxy session
+   already initiated (and possibly, already finished), which just needs to cache
+   the upstream info, which was previously retrieved from the http-auth servers.
+   In this situation, no client is really waiting for the add operation to
+   complete, but the memory still needs to be freed. Hence, it's lower priority.
+
+   So, purging a work queue is an action that is highest priority, and must be
+   triggered whenever anything goes amiss with the ngx_send() or ngx_recv().
+
+   On the other hand, we don't need to be very aggressive in trying to re-
+   establish the connection to a broken peer, as long as we mark that memcache
+   connection as `bad', so that our memcache server hashing algorithm is smart
+   enough to ignore the bad connection.
+
+   We can just maintain a counter, which will signify the number of times that
+   a connection could have been used, but was ignored because the server was
+   down. This counter will start at 0, and will be incremented whenever any
+   ngx_send() or ngx_recv() failed, or whenever the hashing algorithm
+   originally selected that channel, but selected another because the channel
+   was marked as `bad'.
+
+   A channel is `bad' when the counter is greater than zero, and it is good if
+   the counter is 0.
+
+   The counter is incremented by one (and the channel is marked bad) whenever
+   there is an error on ngx_send and/or ngx_recv, and it is also incremented by
+   one whenever the hashing algorithm elects the channel, but finds it bad.
+
+   The counter is reset to zero (and the channel marked good), after we re-
+   establish the connection. The re-establishment is attempted when the counter
+   reaches the config-file-defined threshold. A threshold of 1 indicates
+   aggressive re-connection, whereas larger values signify more lethargic
+   attempts at re-connection
+
+   (important note)
+   As an alternative to the channel ageing algorithm used above, we can use
+   a simple timeout to indicate how long nginx will do without a bad memcache
+   connection before attempting to reconnect. Therefore, all references to
+   memcache channel age are superseded by the `reconnect interval'
+
+ */
+static void ngx_memcache_reestablish_connection (mc_context_t *mcctx)
+{
+    ngx_int_t       rc;
+
+    if (mcctx->srvconn->connection) {
+        ngx_memcache_close_connection (mcctx->srvconn);
+    }
+
+    ngx_memzero (mcctx->srvconn, sizeof (ngx_peer_connection_t));
+
+    mcctx->srvconn->sockaddr    =  mcctx->srvaddr->sockaddr;
+    mcctx->srvconn->socklen     =  mcctx->srvaddr->socklen;
+    mcctx->srvconn->name        = &mcctx->srvaddr->name;
+    mcctx->srvconn->get         =  ngx_event_get_peer;
+    mcctx->srvconn->log         =  ngx_cycle->log;
+    mcctx->srvconn->log_error   = NGX_ERROR_ERR;
+
+    rc = ngx_event_connect_peer (mcctx->srvconn);
+
+    if (mcctx->srvconn->connection)
+    {
+        mcctx->srvconn->connection->read->handler = ngx_memcache_any_read_handler;
+        mcctx->srvconn->connection->write->handler = ngx_memcache_dummy_write_handler;
+        mcctx->srvconn->connection->data = mcctx;
+        mcctx->srvconn->connection->log = ngx_cycle->log;
+    }
+
+    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {
+        ngx_log_error (NGX_LOG_WARN, ngx_cycle->log, 0,
+            "cannot re-establish connection to memcached channel %V",
+            mcctx->srvconn->name);
+        mcctx->status = mcchan_bad;
+    } else {
+        /* In this case, the connection may return NGX_AGAIN (-2).
+         * If Then the read event is comming and recv return NGX_ERROR (-1),
+         * the reconnection fails. Otherwise, the reconnection is successful.
+         */
+        ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+            "reconnect to memcached channel %V (rc: %d)",
+            mcctx->srvconn->name, rc);
+        mcctx->status = mcchan_reconnect;
+        setsockopt(mcctx->srvconn->connection->fd, SOL_SOCKET, SO_SNDBUF,
+        (void *) &mc_sndbuf_len, sizeof (mc_sndbuf_len));
+    }
+}
+
+/* mc_hash
+ *
+ * hash an opaque key onto an available memcached channel number
+ * if the memcached channel is currently bad, then fail-over to the next
+ * server in declarative order, until all channels are exhausted
+ *
+ * return MC_INVALID_HASH on failure
+ */
+static ngx_uint_t ngx_memcache_hash (u_char *key, size_t len)
+{
+    ngx_uint_t               h, r, i;
+    mc_context_t            *mcctx;
+    ngx_memcache_conf_t     *mcf;
+
+    mcf = (ngx_memcache_conf_t*) ngx_get_conf(ngx_cycle->conf_ctx, ngx_memcache_module);
+
+    if (mcf->contexts.nelts == 0) {
+        r = MC_INVALID_HASH;
+    } else {
+        h = ngx_memcache_perl_hash (key, len);
+        r = h % mcf->contexts.nelts;
+        i = r;
+
+        do {
+            mcctx = ((mc_context_t *)mcf->contexts.elts) + i;
+
+            if (mcctx->status == mcchan_bad) {
+                i = (i + 1) % mcf->contexts.nelts;
+            }
+        } while ((mcctx->status == mcchan_bad) && (i != r));
+
+        if (mcctx->status == mcchan_bad)
+            r = MC_INVALID_HASH;
+        else
+            r = i;
+    }
+
+    return r;
+}
+
+static ngx_uint_t ngx_memcache_perl_hash (u_char *key, size_t len)
+{
+    size_t          i;
+    ngx_uint_t      h;
+    u_char          *p;
+
+    p = key;
+    i = len;
+    h = 0;
+
+    while (i--)
+    {
+        h += *p++;
+        h += (h << 10);
+        h ^= (h >> 6);
+    }
+
+    h += (h << 3);
+    h ^= (h >> 11);
+    h += (h << 15);
+
+    return h;
+}
+
+static inline void
+ngx_memcache_prepare_reconnection (mc_context_t * mcctx) {
+    ngx_event_t * ev = mcctx->reconnect_ev;
+    ev->data = mcctx;
+
+    if (!ev->timer_set) {
+        ngx_add_timer(ev, mcctx->cxn_interval);
+        ngx_log_error (NGX_LOG_NOTICE, ngx_cycle->log, 0,
+               "memcached channel:%V down, reconnect after:%d ms",
+               mcctx->srvconn->name, mcctx->cxn_interval);
+    }
+}
+
+static void
+ngx_memcache_reconnection_handler (ngx_event_t * ev) {
+    mc_context_t * ctx = (mc_context_t *) ev->data;
+
+    if (ctx->status == mcchan_good) return;
+
+    ev->timedout = 0;
+    //ev->timer_set has been set to 0 before this handler are invoked.
+
+    /* unconditionally re-connect bad channel if this event is fired */
+    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, ngx_cycle->log, 0,
+        "reconnect to %V right now",
+        ctx->srvconn->name);
+
+    ngx_memcache_reestablish_connection (ctx);
+    ngx_unlock(&ctx->lock);
+
+    if (ctx->status == mcchan_bad) { //schedule next retry
+        ngx_memcache_prepare_reconnection (ctx);
+    }
+
+    return;
+}
+
+static u_char *
+ngx_memcache_hexstr(unsigned char *buf, int len)
+{
+     const char *set = "0123456789abcdef";
+     static u_char str[65], *tmp;
+     unsigned char *end;
+     if (len > 32)
+         len = 32;
+     end = buf + len;
+     tmp = &str[0];
+     while (buf < end)
+     {
+         *tmp++ = set[ (*buf) >> 4 ];
+         *tmp++ = set[ (*buf) & 0xF ];
+         buf ++;
+     }
+     *tmp = '\0';
+     return str;
+}
+
+/*
+ * generate memcache post data unit (pdu)
+ * the value's usage depends on the request command:
+ * 1. for "get", "delete", value is useless. you can set it to null
+ * 2. for "add", value is the value to be added
+ * 3. for "incr" or "decr", value is the number to increase or decrease. You
+ *    have to ensure it's an integer.
+ *
+ * If the ttl is set to "-1", the memcache conf's ttl will be used; otherwise
+ * use the specified one. ttl is only effective for the "add" command.
+ */
+static ngx_str_t ngx_memcache_create_pdu(ngx_pool_t *pool, mc_work_t *w,
+        ngx_str_t key, ngx_str_t value, ngx_str_t ttl, ngx_log_t * log) {
+
+    ngx_str_t                  pdu;
+    size_t                     l, ll, len;
+    u_char                    *p;
+    ngx_memcache_conf_t       *mcf;
+
+    len = 0, ll = 0;
+
+    /* check key validity */
+    if (key.len > NGX_MAX_KEY_LENGTH) {
+        ngx_str_t md5_key;
+        u_char * md5 = ngx_pnalloc(pool, MD5_DIGEST_LENGTH);
+        MD5(key.data, key.len, md5);
+        md5_key.data = ngx_memcache_hexstr(md5, MD5_DIGEST_LENGTH);
+        md5_key.len = strlen((const char *)md5_key.data);
+
+        ngx_log_debug2 (NGX_LOG_DEBUG_ZIMBRA, log, 0,
+                "the memcache request key %V is too long, use "
+                "its MD5 digest string %V as the key",
+                &key, &md5_key);
+
+        key = md5_key;
+    }
+
+    switch (w->request_code) {
+        case mcreq_get:
+            l = sizeof("get ") - 1 + key.len + sizeof(CRLF) - 1;
+            break;
+        case mcreq_add:
+            ll = 0;
+            len = value.len;
+            do {
+                len /= 10;
+                ll++;
+            } while (len != 0);
+
+            mcf = (ngx_memcache_conf_t*) ngx_get_conf(ngx_cycle->conf_ctx, ngx_memcache_module);
+
+            if (ngx_strncmp(ttl.data, "-1", 2) == 0) {
+                ttl = mcf->ttl_text;
+            }
+
+            l = sizeof("add ") - 1 + key.len + sizeof(" ") - 1 +
+                sizeof("0 ") - 1 + ttl.len + sizeof(" ") - 1 +
+                ll + sizeof(CRLF) - 1 + value.len + sizeof(CRLF) - 1;
+            break;
+        case mcreq_incr:
+            l = sizeof("incr ") - 1 + key.len + sizeof(" ") - 1 + value.len + sizeof(CRLF) - 1;
+            break;
+        case mcreq_decr:
+            l = sizeof("decr ") - 1 + key.len + sizeof(" ") - 1 + value.len + sizeof(CRLF) - 1;
+            break;
+        case mcreq_delete:
+            l = sizeof("delete ") - 1 + key.len + sizeof(CRLF) - 1;
+            break;
+        default:
+            ngx_log_error (NGX_LOG_ERR, log, 0,
+                    "unkown command for the memcache key: %V", &key);
+            ngx_str_null(&pdu);
+            return pdu;
+    }
+
+    pdu.data = ngx_palloc(pool, l);
+
+    if (pdu.data == NULL) {
+        ngx_str_null(&pdu);
+        return pdu;
+    }
+
+    p = pdu.data;
+
+    switch (w->request_code) {
+        case mcreq_get:
+            ngx_sprintf(p, "get %V" CRLF, &key);
+            break;
+        case mcreq_add:
+            ngx_sprintf(p, "add %V 0 %V %d" CRLF "%V" CRLF, &key,
+                    &ttl, value.len, &value);
+            break;
+        case mcreq_incr:
+            ngx_sprintf(p, "incr %V %V" CRLF, &key, &value);
+            break;
+        case mcreq_decr:
+            ngx_sprintf(p, "decr %V %V" CRLF, &key, &value);
+            break;
+        case mcreq_delete:
+            ngx_sprintf(p, "delete %V" CRLF, &key);
+            break;
+        default:
+            /* impossible to reach here */
+            return pdu;
+    }
+
+    pdu.len = l;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_ZIMBRA, log, 0,
+            "generate pdu %V", &pdu);
+
+    return pdu;
+}
diff --git a/src/core/ngx_memcache.h b/src/core/ngx_memcache.h
new file mode 100644
index 000000000..d402d8d0f
--- /dev/null
+++ b/src/core/ngx_memcache.h
@@ -0,0 +1,157 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#ifndef _NGX_MEMCACHE_H_INCLUDED_
+#define _NGX_MEMCACHE_H_INCLUDED_
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+
+#define NGX_MEMCACHE_CONF        0x02000000
+#define NGX_MAX_KEY_LENGTH       250
+
+typedef struct {
+    ngx_pool_t      *cpool;         /* main pool where self resides */
+    ngx_log_t       *log;
+    ngx_array_t     contexts;       /* mc_context_t[] */
+    ngx_array_t     servers;        /* ngx_addr_t*[] */
+    ngx_msec_t      timeout;
+    ngx_msec_t      reconnect;
+    ngx_msec_t      ttl;
+    ngx_str_t       ttl_text;       /* in second, ttl / 1000 */
+    ngx_flag_t      allow_unqualified;
+} ngx_memcache_conf_t;
+
+/* supported memcache request codes */
+typedef enum {
+    mcreq_noop,
+    mcreq_get,
+    mcreq_add,
+    mcreq_delete,
+    mcreq_incr,
+    mcreq_decr
+} mc_request_code_t;
+
+/* memcache response codes */
+typedef enum {
+    mcres_unknown,
+    mcres_success,
+    mcres_failure_normal,     /* memcached server response with failure info,
+                                 such as NOT_FOUND, NOT_STORED, ...             */
+    mcres_failure_input,      /* failures triggered by the user input, such as
+                                 invalid key or command                         */
+    mcres_failure_again,      /* failures that might be recovered by retry, such as
+                                 one of many memcached servers is down; or the
+                                 message replied can't be parsed correctly      */
+    mcres_failure_unavailable /* failures of no memcache servers are available,
+                                 or other failures that make memcache service
+                                 unavailable                                    */
+} mc_response_code_t;
+
+/* memcache channel status */
+typedef enum {
+    mcchan_good,
+    mcchan_bad,
+    mcchan_reconnect /* temp status in reconnection */
+} mc_channel_status_t;
+
+/* additional data returned by a memcache operation */
+typedef ngx_str_t mc_data_t;
+
+struct mc_work_s;
+/* prototype for sucess/failure handler */
+typedef void (*mc_chain_handler) (struct mc_work_s *w);
+
+/* workqueue entry representing an outstanding memcache request
+ */
+struct mc_work_s
+{
+    mc_request_code_t   request_code;   /* op request code */
+    mc_response_code_t  response_code;  /* op response status */
+    void               *ctx;            /* op context */
+    mc_data_t           payload;        /* op response payload */
+    mc_chain_handler    on_success;     /* success handler */
+    mc_chain_handler    on_failure;     /* failure handler */
+};
+
+typedef struct mc_work_s mc_work_t;
+
+
+/* a queue of memcache entries representing all outstanding memcache 
+   requests for a particular connection to a memcache server
+ */
+
+typedef struct mc_workqueue_s mc_workqueue_t;
+
+struct mc_workqueue_s {
+    mc_work_t           w;              /* payload of the workqueue entry */
+    ngx_pool_t          *pool;          /* pool in which this node resides */
+    ngx_flag_t          reclaim;        /* reclaim the pool? (default:0) */
+    mc_workqueue_t      *prev;          /* previous node in the queue */
+    mc_workqueue_t      *next;          /* next node in the queue */
+};
+
+/* a `memcache context' data structure that completely represents the 
+   state of a particular connection to a memcached server
+ */
+
+typedef struct {
+    ngx_buf_t               *readbuffer;    /* circular buffer for recv() */
+    mc_workqueue_t          wq_head;        /* head of outstanding requests */
+    ngx_addr_t              *srvaddr;       /* address of memcached server */
+    ngx_peer_connection_t   *srvconn;       /* active connection to server */
+    mc_channel_status_t     status;         /* connection status */
+    ngx_msec_t              timeout;        /* read/write timeout */
+    ngx_msec_t              cxn_interval;   /* timeout for reconnection */
+    ngx_event_t             *reconnect_ev;  /* event for reconnection */
+    ngx_atomic_t            lock;           /* concurrent access lock */
+} mc_context_t;
+
+/* Functions to manipulate the memcache work queue */
+mc_workqueue_t *ngx_memcache_wq_enqueue (mc_workqueue_t *head, mc_workqueue_t *wq);
+mc_workqueue_t *ngx_memcache_wq_dequeue (mc_workqueue_t *head);
+
+/* Post a memcache operation request onto an available channel */
+void ngx_memcache_post (
+     mc_work_t      *w,
+     ngx_str_t       key,
+     ngx_str_t       value,
+     ngx_pool_t     *p,
+     ngx_log_t      *l
+    );
+
+/*
+ * Post a memcache operation request onto an available channel
+ * custom ttl. (Only "add" is supported)
+ */
+void ngx_memcache_post_with_ttl (
+     mc_work_t       *w,
+     ngx_str_t        key,
+     ngx_str_t        value,
+     ngx_str_t        ttl,
+     ngx_pool_t      *p,
+     ngx_log_t       *l
+    );
+
+extern ngx_str_t NGX_EMPTY_STR; /* for dummy value */
+
+/* Ignore a work entry in the queue whose ctx is equal to
+ * the specified one.
+ */
+void ngx_memcache_ignore_work_by_ctx (void * ctx);
+
+#endif
diff --git a/src/core/ngx_string.c b/src/core/ngx_string.c
index 468e9600c..aebab06c9 100644
--- a/src/core/ngx_string.c
+++ b/src/core/ngx_string.c
@@ -4,6 +4,9 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -84,6 +87,25 @@ ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src)
     return dst;
 }
 
+ngx_str_t *
+ngx_pstrcpy(ngx_pool_t *pool, ngx_str_t *src) {
+    ngx_str_t * dst;
+
+    dst = ngx_pnalloc(pool, sizeof(ngx_str_t));
+    if (dst == NULL) {
+        return NULL;
+    }
+
+    dst->data = ngx_pnalloc(pool, src->len);
+    if (dst->data == NULL) {
+        return NULL;
+    }
+
+    ngx_memcpy(dst->data, src->data, src->len);
+    dst->len = src->len;
+    return dst;
+}
+
 
 /*
  * supported formats:
diff --git a/src/core/ngx_string.h b/src/core/ngx_string.h
index 0fb9be72e..1d13249af 100644
--- a/src/core/ngx_string.h
+++ b/src/core/ngx_string.h
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #ifndef _NGX_STRING_H_INCLUDED_
 #define _NGX_STRING_H_INCLUDED_
@@ -150,6 +154,7 @@ ngx_copy(u_char *dst, u_char *src, size_t len)
 
 u_char *ngx_cpystrn(u_char *dst, u_char *src, size_t n);
 u_char *ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src);
+ngx_str_t *ngx_pstrcpy(ngx_pool_t *pool, ngx_str_t *src);
 u_char * ngx_cdecl ngx_sprintf(u_char *buf, const char *fmt, ...);
 u_char * ngx_cdecl ngx_snprintf(u_char *buf, size_t max, const char *fmt, ...);
 u_char * ngx_cdecl ngx_slprintf(u_char *buf, u_char *last, const char *fmt,
diff --git a/src/core/ngx_zm_lookup.c b/src/core/ngx_zm_lookup.c
new file mode 100644
index 000000000..165f85854
--- /dev/null
+++ b/src/core/ngx_zm_lookup.c
@@ -0,0 +1,2283 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#include <ngx_zm_lookup.h>
+#include <ngx_memcache.h>
+
+static char * ngx_zm_lookup_handlers(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+
+/* lookup from memcache */
+static void ngx_zm_lookup_account_from_cache(ngx_zm_lookup_ctx_t *ctx);
+static void ngx_zm_lookup_account_from_cache_success_handler(mc_work_t *work);
+static void ngx_zm_lookup_account_from_cache_failure_handler(mc_work_t *work);
+static void ngx_zm_lookup_route_from_cache(ngx_zm_lookup_ctx_t *ctx);
+static void ngx_zm_lookup_route_from_cache_success_handler(mc_work_t *work);
+static void ngx_zm_lookup_route_from_cache_failure_handler(mc_work_t *work);
+static void ngx_zm_lookup_cache_alias(ngx_zm_lookup_ctx_t *ctx,
+        ngx_str_t alias, ngx_str_t account_name);
+static void ngx_zm_lookup_cache_route(ngx_zm_lookup_ctx_t *ctx,
+        ngx_str_t user, ngx_str_t route);
+static void ngx_zm_lookup_cache_dummy_handler(mc_work_t *work);
+static void ngx_zm_lookup_delete_cache_handler(mc_work_t *work);
+
+/* memcache key creation */
+static ngx_str_t
+ngx_zm_lookup_get_user_route_key(ngx_pool_t *pool, ngx_log_t *log,
+        ngx_str_t proto, ngx_str_t account_name, ngx_str_t client_ip);
+static ngx_str_t ngx_zm_lookup_get_id_route_key(ngx_pool_t *pool,
+        ngx_log_t *log, ngx_str_t proto, ngx_str_t id, ngx_flag_t isAdmin);
+
+/* lookup from route lookup servlet */
+static void ngx_zm_lookup_dummy_handler(ngx_event_t *ev);
+static void ngx_zm_lookup_connect_handler(ngx_event_t *ev);
+static void ngx_zm_lookup_connect(ngx_zm_lookup_ctx_t * ctx);
+static ngx_int_t ngx_zm_lookup_parse_response_headers(ngx_zm_lookup_ctx_t * ctx);
+static ngx_int_t ngx_zm_lookup_create_request(ngx_zm_lookup_ctx_t *ctx);
+static ngx_str_t ngx_zm_lookup_get_local_socket_addr_text (ngx_pool_t *pool,
+        ngx_socket_t s);
+static void ngx_zm_lookup_process_response(ngx_zm_lookup_ctx_t *ctx);
+static void ngx_zm_lookup_process_response_headers(ngx_zm_lookup_ctx_t *ctx);
+static void ngx_zm_lookup_send_request_handler(ngx_event_t *wev);
+static void ngx_zm_lookup_recv_response_handler(ngx_event_t *rev);
+static ngx_int_t ngx_zm_lookup_retrieve_route(ngx_pool_t * pool,
+        ngx_str_t * addr_text, ngx_str_t * port_text, ngx_addr_t * route);
+static void ngx_zm_lookup_close_connection(ngx_zm_lookup_ctx_t * ctx);
+
+/* module configuration */
+static void * ngx_zm_lookup_create_conf(ngx_cycle_t *cycle);
+static char * ngx_zm_lookup_init_conf(ngx_cycle_t *cycle, void *conf);
+static char *ngx_zm_lookup_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+/* utility */
+static const u_char * ngx_zm_strchr (ngx_str_t str, int chr);
+
+static ngx_command_t ngx_zm_lookup_commands[] =
+{
+    { ngx_string("zm_lookup"),
+      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_zm_lookup_block,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("zm_lookup_handlers"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_1MORE,
+      ngx_zm_lookup_handlers,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("zm_lookup_handler_retry_interval"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, retry_interval),
+      NULL },
+
+    { ngx_string("zm_lookup_timeout"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, timeout),
+      NULL },
+
+    { ngx_string("zm_lookup_buffer_size"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, buffer_size),
+      NULL },
+
+    { ngx_string("zm_lookup_master_auth_username"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, master_auth_username),
+      NULL },
+
+    { ngx_string("zm_lookup_master_auth_password"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, master_auth_password),
+      NULL },
+
+    { ngx_string("zm_lookup_caching"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, caching),
+      NULL },
+
+    { ngx_string("zm_lookup_allow_unqualified"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, allow_unqualified),
+      NULL },
+
+    { ngx_string("zm_prefix_url"),
+      NGX_ZM_LOOKUP_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_zm_lookup_conf_t, url),
+      NULL },
+
+    ngx_null_command
+};
+
+static ngx_core_module_t ngx_zm_lookup_module_ctx =
+{
+    ngx_string("ngx_zm_lookup"),
+    ngx_zm_lookup_create_conf,
+    ngx_zm_lookup_init_conf
+};
+
+/*static const u_char * LOGIN_FAILED = (u_char *)"login failed";*/
+
+static const ngx_str_t ZM_PROTO[] = {
+        ngx_string("unknown"),
+        ngx_string("http"),
+        ngx_string("httpssl"),
+        ngx_string("pop3"),
+        ngx_string("pop3ssl"),
+        ngx_string("imap"),
+        ngx_string("imapssl")
+};
+
+static const ngx_str_t ZM_AUTHMETH[] = {
+        ngx_string("username"),
+        ngx_string("gssapi"),
+        ngx_string("zimbraId"),
+        ngx_string("certauth")
+};
+
+static const ngx_str_t ERRMSG[] = {
+        ngx_string("success"),
+        ngx_string("mem alloc err"),
+        ngx_string("error occurs when writing lookup request to handler"),
+        ngx_string("error occurs when reading lookup response from handler"),
+        ngx_string("timeout occurs when writing lookup request to handler"),
+        ngx_string("timeout occurs when reading lookup response from handler"),
+        ngx_string("no valid lookup handlers"),
+        ngx_string("invalid route is returned"),
+        ngx_string("LOGIN failed"),
+        ngx_string("invalid response from lookup handler"),
+        ngx_string("client connection is closed"),
+        ngx_string("dummy")
+};
+
+/*There is no need to send real password for now */
+static const ngx_str_t
+ngx_zm_lookup_password_placeholder = ngx_string("_password_");
+
+static const ngx_str_t
+ngx_zm_prefix_url = ngx_string("/");
+
+ngx_module_t ngx_zm_lookup_module =
+{
+    NGX_MODULE_V1,
+    &ngx_zm_lookup_module_ctx,          /* module context */
+    ngx_zm_lookup_commands,             /* module directives */
+    NGX_CORE_MODULE,                    /* module type */
+    NULL,                               /* init master */
+    NULL,                               /* init module */
+    NULL,                               /* init process */
+    NULL,                               /* init thread */
+    NULL,                               /* exit thread */
+    NULL,                               /* exit process */
+    NULL,                               /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+static char *ngx_zm_lookup_block(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf)
+{
+    ngx_conf_t  ocf;
+    char        *rc;
+
+    ocf = *cf;
+
+    cf->ctx = cf->cycle->conf_ctx;
+    cf->module_type = NGX_CORE_MODULE;
+    cf->cmd_type = NGX_ZM_LOOKUP_CONF;
+
+    rc = ngx_conf_parse(cf, NULL);
+
+    *cf = ocf;
+
+    return rc;
+}
+
+static void *
+ngx_zm_lookup_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_zm_lookup_conf_t *zlcf;
+    ngx_pool_t          *pool;
+    ngx_log_t           *log;
+
+    log = cycle->log;
+    pool = ngx_create_pool (8 * ngx_pagesize, cycle->log);
+
+    zlcf = ngx_pcalloc (pool, sizeof(ngx_zm_lookup_conf_t));
+    if (zlcf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    zlcf->pool = pool;
+    zlcf->log = log;
+
+#if (NGX_SSL)
+
+    ngx_pool_cleanup_t    *cln;
+    zlcf->ssl = ngx_pcalloc(pool, sizeof(ngx_ssl_t));
+
+    if (zlcf->ssl == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    zlcf->ssl->log = log;
+
+    // don't support SSLv2 anymore
+    if (ngx_ssl_create(zlcf->ssl, ~(NGX_SSL_SSLv2|NGX_SSL_SSLv3), NULL)
+            != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(zlcf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_ssl_cleanup_ctx;
+    cln->data = zlcf->ssl;
+
+#endif
+
+    if(ngx_array_init (&zlcf->handlers, zlcf->pool, 4,
+            sizeof(ngx_zm_lookup_handler_t)) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    zlcf->retry_interval = NGX_CONF_UNSET;
+    zlcf->buffer_size = NGX_CONF_UNSET_SIZE;
+    zlcf->timeout = NGX_CONF_UNSET;
+    zlcf->caching = NGX_CONF_UNSET;
+    zlcf->allow_unqualified = NGX_CONF_UNSET;
+    ngx_str_null(&zlcf->master_auth_username);
+    ngx_str_null(&zlcf->master_auth_password);
+    ngx_str_null(&zlcf->url);
+    ngx_log_error(NGX_LOG_DEBUG_ZIMBRA, cycle->log, 0,
+        "zm lookup configuration created");
+    return zlcf;
+}
+
+static char *
+ngx_zm_lookup_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_zm_lookup_conf_t *zlcf = conf;
+
+    // set default value of timeout
+    if (zlcf->retry_interval == NGX_CONF_UNSET_UINT) {
+        zlcf->retry_interval = 60000;
+    }
+
+    if (zlcf->caching == NGX_CONF_UNSET) {
+        zlcf->caching = 1;
+    }
+
+    if (zlcf->allow_unqualified == NGX_CONF_UNSET) {
+        zlcf->allow_unqualified = 0;
+    }
+
+    if (zlcf->buffer_size == NGX_CONF_UNSET_SIZE) {
+        zlcf->buffer_size = 1024;
+    }
+
+    if (zlcf->timeout == NGX_CONF_UNSET_UINT) {
+        zlcf->timeout = 15000;
+    }
+
+    if (zlcf->master_auth_username.data == NULL) {
+        zlcf->master_auth_username = ngx_zm_lookup_password_placeholder;
+    }
+
+    if (zlcf->master_auth_password.data == NULL) {
+        zlcf->master_auth_password = ngx_zm_lookup_password_placeholder;
+    }
+
+    if (zlcf->url.data == NULL) {
+        zlcf->url = ngx_zm_prefix_url;
+    }
+
+    ngx_log_error(NGX_LOG_DEBUG_ZIMBRA,cycle->log, 0,
+        "zm lookup - initialized config defaults");
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_zm_lookup_handlers(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_zm_lookup_conf_t       *zlcf = conf;
+    ngx_zm_lookup_handler_t    *handler;
+    ngx_url_t                   u;
+    ngx_uint_t                  i;
+    ngx_uint_t                  add;
+
+    /* parse each url specified against directive "zm_lookup_handlers" */
+    for(i = 1; i < cf->args->nelts; ++i)
+    {
+        ngx_memzero(&u, sizeof(ngx_url_t));
+        u.url = ((ngx_str_t*)cf->args->elts)[i];
+        u.default_port = 7072;
+        u.uri_part = 1;
+        add = 0;
+
+       if (ngx_strncasecmp(u.url.data, (u_char *) "http://", 7) == 0) {
+           add = 7;
+       } else if (ngx_strncasecmp(u.url.data, (u_char *) "https://", 8) == 0) {
+if (NGX_SSL)
+           add = 8;
+else
+           ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                              "https protocol requires SSL support");
+           return NGX_CONF_ERROR;
+endif
+       } else {
+           ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "invalid URL prefix");
+           return NGX_CONF_ERROR;
+       }
+       u.url.len -= add;
+       u.url.data += add;
+
+       if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+            if (u.err) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "%s in zm lookup handlers \"%V\"", u.err, &u.url);
+            }
+            return NGX_CONF_ERROR;
+        }
+
+        handler = ngx_array_push(&zlcf->handlers);
+        if (handler == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        handler->peer = u.addrs;
+        handler->host = u.host;
+        handler->uri = u.uri;
+        handler->failure_time = 0;
+
+        if (add == 7) {
+          handler->ssl = 0;
+        } else if (add == 8) {
+          handler->ssl = 1;
+        }
+
+        ngx_conf_log_error(NGX_LOG_INFO, cf, 0,
+                    "add zimbra route lookup handler %V", &u.url);
+    }
+
+    if (zlcf->handlers.nelts == 0) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "zero valid zmauth route handlers");
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+static ngx_int_t
+ngx_zm_lookup_elect_handler(ngx_zm_lookup_ctx_t *ctx, ngx_zm_lookup_conf_t *zlcf)
+{
+    ngx_zm_lookup_handler_t * handler;
+    time_t now = time(NULL);
+
+    if (zlcf->handlers.nelts == 0) {
+        return NGX_ERROR;
+    }
+    /* so the loop below can start from zlcf->handler_index rather than
+       zlcf->handler_index + 1
+     */
+    ctx->handler_index = zlcf->handler_index - 1;
+    zlcf->handler_index = (zlcf->handler_index + 1) % zlcf->handlers.nelts;
+    do {
+        if (ctx->tries >= zlcf->handlers.nelts) {
+           ngx_log_error (NGX_LOG_ERR, ctx->log, 0,
+                   "All nginx lookup handlers are unavailable");
+           return NGX_ERROR;
+
+        } else {
+            ctx->handler_index = (ctx->handler_index + 1) % zlcf->handlers.nelts;
+            ctx->tries ++;
+
+            handler = ((ngx_zm_lookup_handler_t*)zlcf->handlers.elts) + ctx->handler_index;
+            if (handler->failure_time != 0) {
+                if((now < handler->failure_time ||
+                (now - handler->failure_time) < (time_t)(zlcf->retry_interval / 1000))) {
+                    continue;
+                } else {
+                    handler->failure_time = 0; // mark it as available and try to connect it
+                }
+            }
+            ctx->handler = handler;
+            break;
+        }
+    } while (1);
+
+    return NGX_OK;
+}
+
+/* portal API */
+void
+ngx_zm_lookup(ngx_zm_lookup_work_t * work)
+{
+    ngx_zm_lookup_ctx_t          *ctx;
+    ngx_zm_lookup_conf_t         *zlcf;
+
+    zlcf = (ngx_zm_lookup_conf_t *)
+            ngx_get_conf (ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    ctx = ngx_pcalloc(work->pool, sizeof(ngx_zm_lookup_ctx_t));
+    if (ctx == NULL) {
+        work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+        work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+        work->on_failure(work);
+        return;
+    }
+    ctx->pool = work->pool;
+    ctx->log = work->log;
+    ctx->work = work;
+    ctx->tries = 0;
+    ctx->handler = NULL;
+    ctx->state = 0;
+    work->ctx = ctx;
+
+    if (ctx->work->auth_method == ZM_AUTHMETH_GSSAPI ||
+        ctx->work->auth_method == ZM_AUTHMETH_CERTAUTH) {
+        /* These methods should never be cached */
+        ngx_zm_lookup_connect(ctx);
+        return;
+    }
+
+    if (zlcf->caching) {
+
+        if (work->auth_method == ZM_AUTHMETH_ZIMBRAID) {
+            ngx_zm_lookup_route_from_cache(ctx);
+            return;
+        }
+
+        if (work->alias_check_stat == ZM_ALIAS_NOT_CHECKED) {
+            ngx_zm_lookup_account_from_cache(ctx);
+        } else {
+            ngx_zm_lookup_route_from_cache(ctx);
+        }
+
+    } else {
+        ngx_zm_lookup_connect(ctx);
+    }
+}
+
+/*
+ * Consider current user name is an alias and lookup its
+ * corresponding account name, such 'john' --> 'john@test.com'
+ */
+static void
+ngx_zm_lookup_account_from_cache (ngx_zm_lookup_ctx_t * ctx)
+{
+    ngx_zm_lookup_work_t                    *work;
+    ngx_str_t                                key;
+    ngx_log_t                               *log;
+    mc_work_t                                mc;
+    ngx_pool_t                              *pool;
+
+    log = ctx->log;
+    pool = ctx->pool;
+    work = ctx->work;
+
+    if (work->alias_key.len > 0) {
+        key = work->alias_key;
+    } else {
+        if (IS_PROTO_WEB(work->protocol)) {
+            key = ngx_zm_lookup_get_http_alias_key
+                    (pool, log, work->username, work->virtual_host);
+        } else {
+            key = ngx_zm_lookup_get_mail_alias_key
+                    (pool, log, work->username, work->connection->addr_text);
+        }
+
+        if (key.len == 0) {    /* NOMEM */
+            work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+            work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+            work->on_failure(work);
+            return;
+        }
+
+        work->alias_key = key;
+    }
+
+    mc.ctx = ctx;
+    mc.request_code = mcreq_get;
+    mc.response_code = mcres_unknown;
+    mc.on_success = ngx_zm_lookup_account_from_cache_success_handler;
+    mc.on_failure = ngx_zm_lookup_account_from_cache_failure_handler;
+
+    ctx->wait_memcache = 1;
+    ngx_memcache_post(&mc, key, NGX_EMPTY_STR,/* pool */ NULL, log);
+}
+
+static void
+ngx_zm_lookup_account_from_cache_success_handler (mc_work_t *mc)
+{
+    ngx_zm_lookup_ctx_t          *ctx;
+    ngx_str_t                     account_name;
+
+    ctx = (ngx_zm_lookup_ctx_t *)mc->ctx;
+    ctx->wait_memcache = 0;
+
+    account_name.data = ngx_pstrdup(ctx->pool, &mc->payload);
+    if (account_name.data != NULL)
+    {
+        account_name.len = mc->payload.len;
+        ctx->work->account_name = account_name;
+
+        ngx_log_debug2 (NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+            "zm lookup: user:%V aliased to account name:%V",
+            &ctx->work->username, &account_name
+            );
+
+        ctx->work->alias_check_stat = ZM_ALIAS_FOUND;
+        ngx_zm_lookup_route_from_cache(ctx);
+    }
+}
+
+static void
+ngx_zm_lookup_account_from_cache_failure_handler(mc_work_t *work)
+{
+    ngx_zm_lookup_ctx_t          *ctx;
+
+    ctx = (ngx_zm_lookup_ctx_t *)work->ctx;
+    ctx->wait_memcache = 0;
+    ctx->work->alias_check_stat = ZM_ALIAS_NOT_FOUND;
+    /* If account name is not found, take username as the account name */
+    ctx->work->account_name = ctx->work->username;
+
+    ngx_zm_lookup_route_from_cache(ctx);
+}
+
+/* lookup route by zimbra id/account name in memcache */
+static void
+ngx_zm_lookup_route_from_cache (ngx_zm_lookup_ctx_t *ctx)
+{
+    ngx_pool_t                     *pool;
+    ngx_log_t                      *log;
+    ngx_str_t                       key;
+    mc_work_t                       mc;
+    ngx_zm_lookup_work_t           *work;
+    ngx_zm_lookup_conf_t           *zlcf;
+    ngx_str_t                       username;
+
+    zlcf = (ngx_zm_lookup_conf_t *)
+            ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    pool = ctx->pool;
+    log = ctx->log;
+    work = ctx->work;
+
+    if (work->auth_method == ZM_AUTHMETH_ZIMBRAID) {
+        key = ngx_zm_lookup_get_id_route_key(pool, log,
+                ZM_PROTO[work->protocol], work->username, work->isAdmin);
+    } else {
+        if (work->alias_check_stat == ZM_ALIAS_FOUND) {
+            username = work->account_name;
+        } else {
+            username = work->username;
+        }
+
+        if (zlcf->allow_unqualified == 0 && !is_login_qualified(username)) {
+            key = ngx_zm_lookup_get_user_route_key(pool, log, ZM_PROTO[work->protocol],
+                    username, work->connection->addr_text);
+        } else {
+            key = ngx_zm_lookup_get_user_route_key(pool, log, ZM_PROTO[work->protocol],
+                    username, NGX_EMPTY_STR);
+        }
+    }
+
+    if (key.len == 0) {   /* NOMEM */
+        work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+        work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+        work->on_failure(work);
+        return;
+    }
+
+    ctx->work->route_key = key;
+
+    mc.ctx = ctx;
+    mc.request_code = mcreq_get;
+    mc.response_code = mcres_unknown;
+    mc.on_success = ngx_zm_lookup_route_from_cache_success_handler;
+    mc.on_failure = ngx_zm_lookup_route_from_cache_failure_handler;
+
+    ctx->wait_memcache = 1;
+    ngx_memcache_post(&mc, key, NGX_EMPTY_STR,/* pool */ NULL, log);
+}
+
+static void
+ngx_zm_lookup_route_from_cache_success_handler (mc_work_t *mc)
+{
+    ngx_zm_lookup_ctx_t                     *ctx;
+    ngx_str_t                                route_text;
+    ngx_url_t                                u;
+
+    ctx = (ngx_zm_lookup_ctx_t *)mc->ctx;
+    ctx->wait_memcache = 0;
+
+    route_text.data = ngx_pstrdup(ctx->pool, &mc->payload);
+
+    if (route_text.data == NULL) {
+        ctx->work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+        ctx->work->on_failure(ctx->work);
+        return;
+    } else {
+        route_text.len = mc->payload.len;
+
+        ngx_log_debug2 (NGX_LOG_DEBUG_HTTP, ctx->log,0,
+            "zm lookup: fetch cached route:%V for user:%V",
+            &route_text, &ctx->work->username
+            );
+
+        ngx_memzero(&u, sizeof(u));
+        u.url = route_text;
+        u.listen = 1;
+
+        if (ngx_parse_url(ctx->pool, &u) != NGX_OK) {
+            ctx->work->result = ZM_LOOKUP_INVALID_ROUTE;
+            ctx->work->on_failure(ctx->work);
+            return;
+        }
+
+        ctx->work->route = ngx_palloc(ctx->pool, sizeof(ngx_addr_t));
+        if (ctx->work->route == NULL) {
+            ctx->work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+            ctx->work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+            ctx->work->on_failure(ctx->work);
+            return;
+        }
+        ctx->work->route->name = route_text;
+        ctx->work->route->socklen = u.socklen;
+        ctx->work->route->sockaddr = ngx_palloc(ctx->pool, u.socklen);
+        if(ctx->work->route->sockaddr == NULL) {
+            ctx->work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+            ctx->work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+            ctx->work->on_failure(ctx->work);
+            return;
+        }
+        ngx_memcpy(ctx->work->route->sockaddr, &u.sockaddr, u.socklen);
+        ctx->work->result = ZM_LOOKUP_SUCCESS;
+        ctx->work->on_success(ctx->work);
+        return;
+    }
+}
+
+static void
+ngx_zm_lookup_route_from_cache_failure_handler(mc_work_t *mc)
+{
+    ngx_zm_lookup_ctx_t          *ctx;
+    ctx = (ngx_zm_lookup_ctx_t *) mc->ctx;
+    ctx->wait_memcache = 0;
+
+    /* if alias-->account lookup succeeds, but route lookup fails,
+     * ignore the found account. Still use what user initial input
+     * do the route lookup. (bug 49283)
+     */
+    if (ctx->work->alias_check_stat == ZM_ALIAS_FOUND) {
+        ctx->work->alias_check_stat = ZM_ALIAS_IGNORED;
+    }
+
+    ngx_zm_lookup_connect (ctx);
+}
+
+#if (NGX_SSL)
+
+static void
+ngx_zm_lookup_ssl_handshake(ngx_connection_t *c)
+{
+    ngx_zm_lookup_ctx_t *ctx = c->data;
+
+    if (c->ssl->handshaked) {
+        c->read->handler = ngx_zm_lookup_dummy_handler;
+        c->write->handler = ngx_zm_lookup_connect_handler;
+        ngx_reusable_connection(c, 1);
+        c->write->handler(c->write);
+        ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+                 "zm lookup: ngx_zm_lookup_ssl_handshake set fd:%d", c->fd);
+    } else {
+        /* when handshake fails, we should close the session */
+        ngx_zm_lookup_close_connection(ctx);
+        ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+                         "zm lookup: ngx_zm_lookup_ssl_handshake unset fd:%d", c->fd);
+    }
+}
+
+static ngx_flag_t
+ngx_zm_lookup_ssl_init_connection(ngx_ssl_t* ssl, ngx_connection_t *c)
+{
+    ngx_int_t   rc;
+    ngx_int_t   marker = 20;
+    ngx_zm_lookup_ctx_t *ctx = c->data;
+
+    if (ngx_ssl_create_connection(ssl, c,
+                                  NGX_SSL_BUFFER|NGX_SSL_CLIENT)
+        != NGX_OK)
+    {
+        ngx_zm_lookup_close_connection(ctx);
+        return;
+    }
+
+    c->log->action = "SSL handshaking to lookup handler";
+
+    do {
+        rc = ngx_ssl_handshake(c);
+        if(rc == NGX_AGAIN)
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_ZIMBRA, c->log, 0,
+                    "zm lookup: ngx_zm_lookup_ssl_init_connection ngx_ssl_handshake returned NGX_AGAIN");
+            ngx_msleep(5);
+        }
+        else if (rc == NGX_ERROR)
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_ZIMBRA, c->log, 0,
+                    "zm lookup: ngx_zm_lookup_ssl_init_connection ssl event failed with NGX_ERROR");
+            ngx_zm_lookup_ssl_handshake(c);
+            return ZM_LOOKUP_SSL_EVENT_FAILED;
+        }
+    }while (rc == NGX_AGAIN && --marker > 0);
+
+    if( 0 == marker )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_ZIMBRA, c->log, 0,
+                "zm lookup: ngx_zm_lookup_ssl_init_connection marker reached");
+        ngx_zm_lookup_ssl_handshake(c);
+        return ZM_LOOKUP_SSL_EVENT_FAILED;
+    }
+
+    ngx_log_debug0 (NGX_LOG_DEBUG_ZIMBRA, c->log, 0,
+            "zm lookup: ngx_zm_lookup_ssl_init_connection before call to ngx_zm_lookup_ssl_handshake");
+    ngx_zm_lookup_ssl_handshake(c);
+    return ZM_LOOKUP_SSL_EVENT_SUCCESS;
+}
+
+#endif
+
+static void
+ngx_zm_lookup_connect (ngx_zm_lookup_ctx_t * ctx)
+{
+    ngx_zm_lookup_conf_t         *zlcf;
+    ngx_zm_lookup_handler_t      *handler;
+    ngx_int_t                     rc;
+
+    zlcf = (ngx_zm_lookup_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+         "zm lookup: elected route handler #%d", ctx->handler_index);
+     if (ngx_zm_lookup_elect_handler(ctx, zlcf) != NGX_OK) {
+         ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+              "zm lookup: all lookup handlers exhausted");
+         ctx->work->result = ZM_LOOKUP_NO_VALID_HANDLER;
+         ctx->work->err = ERRMSG[ZM_LOOKUP_NO_VALID_HANDLER];
+         ctx->work->on_failure(ctx->work);
+         return;
+     }
+
+     handler = ctx->handler;
+     ctx->peer.sockaddr = handler->peer->sockaddr;
+     ctx->peer.socklen = handler->peer->socklen;
+     ctx->peer.name = &handler->peer->name;
+     ctx->peer.get = ngx_event_get_peer;
+     ctx->peer.log = ctx->log;
+     ctx->peer.log_error = NGX_ERROR_ERR;
+
+     rc = ngx_event_connect_peer(&ctx->peer);
+
+     if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {
+         ngx_log_debug2(NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+             "zm lookup: connect to lookup handler failed, host:%V, uri:%V",
+             ctx->peer.name, &handler->uri);
+         ngx_zm_lookup_close_connection(ctx);
+
+         /* try again */
+         ngx_log_error(NGX_LOG_WARN, ctx->log, 0, "zm lookup: "
+                       "connect lookup handle error, fail over to the next one");
+         ngx_zm_lookup_connect(ctx);
+         return;
+
+     }
+
+     ctx->peer.connection->data = ctx;
+     ctx->peer.connection->pool = ctx->pool;
+     ctx->peer.connection->log = ctx->log;
+     ctx->peer.connection->read->handler = ngx_zm_lookup_dummy_handler;
+     ctx->peer.connection->write->handler = ngx_zm_lookup_connect_handler;
+     ngx_add_timer(ctx->peer.connection->read, zlcf->timeout);
+     ngx_add_timer(ctx->peer.connection->write, zlcf->timeout);
+
+#if (NGX_SSL)
+
+    if (ctx->handler->ssl && ctx->peer.connection->ssl == NULL) {
+        if(ngx_zm_lookup_ssl_init_connection(zlcf->ssl, ctx->peer.connection) == ZM_LOOKUP_SSL_EVENT_FAILED)
+        {
+            ngx_log_error(NGX_LOG_WARN, ctx->log, 0, "zm lookup: ngx_zm_lookup_connect "
+                    "connect lookup handle error for host:%V, uri:%V, fail over to the next one",ctx->peer.name, &handler->uri);
+            ngx_zm_lookup_connect(ctx);
+        }
+        return;
+    }
+
+#endif
+
+    ctx->peer.connection->read->handler = ngx_zm_lookup_dummy_handler;
+    ctx->peer.connection->write->handler = ngx_zm_lookup_connect_handler;
+}
+
+static void
+ngx_zm_lookup_dummy_handler(ngx_event_t *ev)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_ZIMBRA, ev->log, 0,
+        "ngx_zm_lookup_dummy_handler()");
+}
+
+static void
+ngx_zm_lookup_connect_handler(ngx_event_t *ev)
+{
+    ngx_connection_t                    *c;
+    ngx_zm_lookup_ctx_t                 *ctx;
+    int                                  sockerr;
+    socklen_t                            sockerr_len;
+    struct timeval                       tv;
+
+    c = ev->data;
+    ctx = c->data;
+
+    /* Add health checked as auth http? */
+
+    sockerr = 0;
+    sockerr_len = sizeof(sockerr);
+    getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &sockerr, &sockerr_len);
+
+    if(sockerr == EINPROGRESS) {
+        /* expect to be reinvoked */
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+            "zm lookup: connect to route handler in progress");
+        return;
+    } else if (sockerr != 0) {
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+            "zm lookup: connect to route handler error:%d, will re-elect",
+            sockerr);
+        ngx_gettimeofday(&tv);
+        ctx->handler->failure_time = tv.tv_sec;
+        ngx_close_connection(c);
+        ctx->peer.connection = NULL;
+
+        /* try again */
+        ngx_log_error(NGX_LOG_WARN, c->log, sockerr, "zm lookup: "
+                      "connect lookup handle error, fail over to the next one");
+        ngx_zm_lookup_connect(ctx);
+        return;
+    } else {
+
+       if (ngx_zm_lookup_create_request(ctx) != NGX_OK) {
+           ctx->work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+           ctx->work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+           ctx->work->on_failure(ctx->work);
+           return;
+       }
+
+        ngx_log_debug0(NGX_LOG_DEBUG_ZIMBRA, c->log, 0,
+            "zm lookup: begin zm lookup");
+        ctx->peer.connection->write->handler = ngx_zm_lookup_send_request_handler;
+        ctx->peer.connection->read->handler = ngx_zm_lookup_recv_response_handler;
+        ctx->lookup_response_handler = ngx_zm_lookup_process_response;
+        ctx->peer.connection->write->handler(ctx->peer.connection->write);
+        return;
+    }
+}
+
+static void
+ngx_zm_lookup_send_request_handler(ngx_event_t *wev)
+{
+    ngx_connection_t             *c;
+    ngx_zm_lookup_ctx_t          *ctx;
+    ngx_zm_lookup_work_t         *work;
+    ngx_zm_lookup_conf_t         *zlcf;
+    ssize_t                       size, n;
+
+    c = wev->data;
+    ctx = c->data;
+    work = ctx->work;
+    zlcf = (ngx_zm_lookup_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    if (wev->timedout) {
+        ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,
+            "zm lookup: route handler timed out, failing over to the next one");
+        ngx_zm_lookup_close_connection(ctx);
+
+        /* try again */
+        ngx_zm_lookup_connect(ctx);
+        return;
+    }
+
+    size = ctx->lookup_req->last - ctx->lookup_req->pos;
+
+    n = c->send(c, ctx->lookup_req->pos, size);
+
+    if (n == NGX_ERROR) {
+        work->result = ZM_LOOKUP_WRITE_ERROR;
+        ngx_zm_lookup_close_connection(ctx);
+        work->on_failure(work);
+        return;
+    }
+    if (n > 0) {
+        ctx->lookup_req->pos += n;
+        if (n == size) {
+            wev->handler = ngx_zm_lookup_dummy_handler;
+            if (wev->timer_set) {
+                ngx_del_timer(wev);
+            }
+            if (ngx_handle_write_event(wev, 0) == NGX_ERROR) {
+                work->result = ZM_LOOKUP_WRITE_ERROR;
+                ngx_zm_lookup_close_connection(ctx);
+                work->on_failure(work);
+                return;
+            }
+        }
+    }
+    if (!wev->timer_set) {
+        ngx_add_timer(wev, zlcf->timeout);
+    }
+}
+
+static ngx_int_t
+ngx_zm_lookup_create_request(ngx_zm_lookup_ctx_t *ctx)
+{
+    ngx_buf_t                           *b;
+    size_t                               len;
+    ngx_pool_t                          *pool;
+    ngx_zm_lookup_conf_t                *zlcf;
+    ngx_zm_lookup_work_t                *work;
+    ngx_str_t                            proxy_ip, username;
+    zlcf = (ngx_zm_lookup_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+    pool = ctx->pool;
+    work = ctx->work;
+
+    if(work->alias_check_stat == ZM_ALIAS_FOUND) {
+        username = work->account_name;
+    } else {
+        username = work->username;
+    }
+
+    proxy_ip = ngx_zm_lookup_get_local_socket_addr_text (pool, work->connection->fd);
+
+    len = sizeof("GET ") - 1 + ctx->handler->uri.len + sizeof(" HTTP/1.0" CRLF) - 1
+        + sizeof("Host: ") - 1 + ctx->handler->host.len + sizeof(CRLF) - 1
+        + sizeof("Auth-Method: ") - 1 + ZM_AUTHMETH[work->auth_method].len + sizeof(CRLF) - 1
+        + sizeof("Auth-User: ") - 1 + username.len + sizeof(CRLF) - 1
+        + sizeof("Auth-Pass: ") - 1 + ngx_zm_lookup_password_placeholder.len + sizeof(CRLF) - 1
+        + sizeof("Auth-Protocol: ") - 1 + ZM_PROTO[work->protocol].len + sizeof(CRLF) - 1
+        + sizeof("Auth-Login-Attempt: ") - 1 + NGX_INT_T_LEN + sizeof(CRLF) - 1
+        + sizeof ("X-Proxy-IP: ") - 1 + proxy_ip.len + sizeof(CRLF) - 1
+        + sizeof ("Client-IP: ") - 1 + work->connection->addr_text.len + sizeof(CRLF) - 1;
+
+    if (work->type == zmauth_admin_console) {
+        len += sizeof ("Auth-Zimbra-Admin: True" CRLF) - 1;
+    } else if (work->type == zmauth_zx) {
+        len += sizeof ("Auth-Zimbra-Zx: True" CRLF) - 1;
+    }
+
+    if (IS_PROTO_WEB(work->protocol)) {
+        len += sizeof("X-Proxy-Host: ") - 1 + work->virtual_host.len + sizeof(CRLF) - 1;
+    }
+
+    if (work->auth_method == ZM_AUTHMETH_CERTAUTH ||
+        work->auth_method == ZM_AUTHMETH_GSSAPI) {
+        len += sizeof ("Auth-Admin-User: ") - 1 + zlcf->master_auth_username.len + sizeof(CRLF) - 1;
+        len += sizeof ("Auth-Admin-User: ") - 1 + zlcf->master_auth_password.len + sizeof(CRLF) - 1;
+
+        if (work->auth_method == ZM_AUTHMETH_GSSAPI) {
+            len += sizeof ("Auth-ID: ") - 1 + work->auth_id.len + sizeof(CRLF) - 1;
+        }
+    }
+
+    len += sizeof(CRLF) - 1;
+
+    b = ngx_create_temp_buf(pool, len);
+
+    if (b == NULL) {
+        return NGX_ERROR;
+    }
+
+    b->last = ngx_sprintf(b->last, "GET %V HTTP/1.0" CRLF, &ctx->handler->uri);
+    b->last = ngx_sprintf(b->last, "Host: %V" CRLF, &ctx->handler->host);
+    b->last = ngx_sprintf(b->last, "Auth-Method: %V" CRLF, &ZM_AUTHMETH[work->auth_method]);
+    b->last = ngx_sprintf(b->last, "Auth-User: %V" CRLF, &username);
+    b->last = ngx_sprintf(b->last, "Auth-Pass: %V" CRLF, &ngx_zm_lookup_password_placeholder);
+    b->last = ngx_sprintf(b->last, "Auth-Protocol: %V" CRLF, &ZM_PROTO[work->protocol]);
+    if (IS_PROTO_WEB(work->protocol)) {
+        work->login_attempts = 0; /* for web, login attempts is always 0 */
+    }
+    b->last = ngx_sprintf(b->last, "Auth-Login-Attempt: %d" CRLF, work->login_attempts);
+    b->last = ngx_sprintf(b->last, "X-Proxy-IP: %V" CRLF, &proxy_ip);
+    b->last = ngx_sprintf(b->last, "Client-IP: %V" CRLF, &work->connection->addr_text);
+   if (work->type == zmauth_admin_console) {
+       b->last = ngx_cpymem(b->last, "Auth-Zimbra-Admin: True" CRLF, sizeof("Auth-Zimbra-Admin: True" CRLF) - 1);
+   } else if (work->type == zmauth_zx) {
+       b->last = ngx_cpymem(b->last, "Auth-Zimbra-Zx: True" CRLF, sizeof("Auth-Zimbra-Zx: True" CRLF) - 1);
+   }
+
+    if (IS_PROTO_WEB(work->protocol)) {
+        b->last = ngx_sprintf(b->last, "X-Proxy-Host: %V" CRLF, &work->virtual_host);
+    }
+
+    if (work->auth_method == ZM_AUTHMETH_CERTAUTH||
+        work->auth_method == ZM_AUTHMETH_GSSAPI) {
+        b->last = ngx_sprintf(b->last, "Auth-Admin-User: %V" CRLF, &zlcf->master_auth_username);
+        b->last = ngx_sprintf(b->last, "Auth-Admin-Pass: %V" CRLF, &zlcf->master_auth_password);
+
+        if (work->auth_method == ZM_AUTHMETH_GSSAPI) {
+            b->last = ngx_sprintf(b->last, "Auth-ID: %V" CRLF, &work->auth_id);
+        }
+    }
+
+    b->last = ngx_cpymem(b->last, CRLF, sizeof(CRLF) - 1);
+
+    ctx->lookup_req = b;
+
+#if (NGX_DEBUG)
+    ngx_str_t temp;
+    temp.data = b->pos;
+    temp.len = b->last - b->pos;
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+            "send lookup request:\n%V", &temp);
+#endif
+
+    return NGX_OK;
+}
+
+static void
+ngx_zm_lookup_recv_response_handler(ngx_event_t *rev)
+{
+    ngx_connection_t         *c;
+    ngx_zm_lookup_ctx_t      *ctx;
+    ngx_zm_lookup_work_t     *work;
+    ngx_zm_lookup_conf_t     *zlcf;
+    ssize_t                   n, size;
+
+    c = rev->data;
+    ctx = c->data;
+    work = ctx->work;
+    zlcf = (ngx_zm_lookup_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    if(rev->timedout) {
+        ngx_log_debug2(NGX_LOG_DEBUG_ZIMBRA, rev->log, 0,
+            "zm_route_lookup_module: lookup handler timed out, host:%V, uri:%V",
+            &ctx->handler->peer->name, &ctx->handler->uri);
+
+        ngx_zm_lookup_close_connection(ctx);
+        work->result = ZM_LOOKUP_READ_TIMEOUT;
+        work->err = ERRMSG[ZM_LOOKUP_READ_TIMEOUT];
+        work->on_failure(work);
+        return;
+    }
+
+    if(ctx->lookup_resp == NULL) {
+        ctx->lookup_resp = ngx_create_temp_buf(ctx->pool, zlcf->buffer_size);
+
+        if (ctx->lookup_resp == NULL) {
+            ngx_zm_lookup_close_connection(ctx);
+            work->ctx = NULL;
+            work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+            work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+            work->on_failure(work);
+            return;
+        }
+    }
+
+    size = ctx->lookup_resp->end - ctx->lookup_resp->last;
+    n = c->recv(c, ctx->lookup_resp->pos, size);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_ZIMBRA, rev->log, 0,
+            "zm lookup: ngx_recv() returned %d bytes", n);
+
+    if(n > 0) {
+        ctx->lookup_resp->last += n;
+        ctx->lookup_response_handler (ctx);
+        return;
+    }
+
+    if(n == NGX_AGAIN) {
+        ngx_log_debug0(NGX_LOG_DEBUG_ZIMBRA, rev->log, 0,
+                "zm lookup: ngx_recv() returned NGX_AGAIN");
+        return;
+    }
+
+    ngx_zm_lookup_close_connection(ctx);
+    work->ctx = NULL;
+    work->result = ZM_LOOKUP_READ_ERROR;
+    work->err = ERRMSG[ZM_LOOKUP_READ_ERROR];
+    work->on_failure(work);
+}
+
+static void
+ngx_zm_lookup_process_response(ngx_zm_lookup_ctx_t *ctx)
+{
+    u_char                              *p, ch, *code_start;
+    ngx_int_t                           code;
+    ngx_flag_t                          error;
+    ngx_str_t                           errmsg;
+
+    enum  {
+        sw_start = 0,
+        sw_H,
+        sw_HT,
+        sw_HTT,
+        sw_HTTP,
+        sw_HTTPVER,
+        sw_code,
+        sw_skip,
+        sw_almost_done
+    } state;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+                   "zm lookup: process route discovery HTTP status");
+
+    state = ctx->state;
+
+    error = 0;
+
+    for (p = ctx->lookup_resp->pos; p < ctx->lookup_resp->last; p++)
+    {
+        ch = *p;
+
+        switch (state) {
+
+        /* "HTTP/" */
+        case sw_start:
+            if (ch == 'H') {
+                state = sw_H;
+                break;
+            }
+            goto next;
+
+        case sw_H:
+            if (ch == 'T') {
+                state = sw_HT;
+                break;
+            }
+            goto next;
+
+        case sw_HT:
+            if (ch == 'T') {
+                state = sw_HTT;
+                break;
+            }
+            goto next;
+
+        case sw_HTT:
+            if (ch == 'P') {
+                state = sw_HTTP;
+                break;
+            }
+            goto next;
+
+        case sw_HTTP:
+            if (ch == '/') {
+                state = sw_HTTPVER;
+                break;
+            }
+            goto next;
+
+        case sw_HTTPVER:
+            if (ch == ' ') {
+                state = sw_code;
+                code_start = p + 1;
+                break;
+            }
+
+            if ((ch >= '0' && ch <= '9') || ch == '.') {
+                break;
+            }
+            goto next;
+
+        case sw_code:
+            switch (ch)  {
+            case ' ':
+               code = ngx_atoi(code_start, p - code_start);
+               if (code != 200) {
+                   error = 1;
+               }
+               state = sw_skip;
+               break;
+            case CR:
+                state = sw_almost_done;
+                break;
+            case LF:
+                goto done;
+            }
+            break;
+
+        /* any text until end of line */
+        case sw_skip:
+            switch (ch) {
+            case CR:
+                state = sw_almost_done;
+                break;
+            case LF:
+                goto done;
+            }
+            break;
+
+        /* end of status line */
+        case sw_almost_done:
+            if (ch == LF) {
+                goto done;
+            }
+
+            ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                          "zm lookup: lookup handler %V sent invalid response",
+                          ctx->peer.name);
+            ngx_zm_lookup_close_connection(ctx);
+            ctx->work->result = ZM_LOOKUP_INVALID_RESPONSE;
+            ctx->work->on_failure(ctx->work);
+            return;
+        }
+    }
+
+    ctx->lookup_resp->pos = p;
+    ctx->state = state;
+
+    return;
+
+next:
+
+    p = ctx->lookup_resp->start - 1;
+
+done:
+
+    if (error) {
+        errmsg.data = code_start;
+        errmsg.len = p - code_start + 1;
+        /* trim the trailing CR LF */
+        while (((*p) == CR || (*p) == LF) && p >= ctx->lookup_resp->start) {
+            errmsg.len--;
+            p--;
+        }
+
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                      "zm lookup: lookup handler %V sent error response: %V",
+                      ctx->peer.name, &errmsg);
+        ngx_zm_lookup_close_connection(ctx);
+        ctx->work->result = ZM_LOOKUP_INVALID_RESPONSE;
+        ctx->work->on_failure(ctx->work);
+        return;
+    }
+
+    ctx->lookup_resp->pos = p + 1;
+    ctx->state = 0;
+    ctx->lookup_response_handler = ngx_zm_lookup_process_response_headers;
+    ctx->lookup_response_handler (ctx);
+}
+
+static ngx_int_t
+ngx_zm_lookup_parse_response_headers(ngx_zm_lookup_ctx_t *ctx)
+{
+    u_char      c, ch, *p;
+    enum {
+        sw_start = 0,
+        sw_name,
+        sw_space_before_value,
+        sw_value,
+        sw_space_after_value,
+        sw_almost_done,
+        sw_header_almost_done
+    } state;
+
+    state = ctx->state;
+
+    for (p = ctx->lookup_resp->pos; p < ctx->lookup_resp->last; p++) {
+        ch = *p;
+
+        switch (state) {
+
+        /* first char */
+        case sw_start:
+
+            switch (ch) {
+            case CR:
+                ctx->header_end = p;
+                state = sw_header_almost_done;
+                break;
+            case LF:
+                ctx->header_end = p;
+                goto header_done;
+            default:
+                state = sw_name;
+                ctx->header_name_start = p;
+
+                c = (u_char) (ch | 0x20);
+                if (c >= 'a' && c <= 'z') {
+                    break;
+                }
+
+                if (ch >= '0' && ch <= '9') {
+                    break;
+                }
+
+                return NGX_ERROR;
+            }
+            break;
+
+        /* header name */
+        case sw_name:
+            c = (u_char) (ch | 0x20);
+            if (c >= 'a' && c <= 'z') {
+                break;
+            }
+
+            if (ch == ':') {
+                ctx->header_name_end = p;
+                state = sw_space_before_value;
+                break;
+            }
+
+            if (ch == '-') {
+                break;
+            }
+
+            if (ch >= '0' && ch <= '9') {
+                break;
+            }
+
+            if (ch == CR) {
+                ctx->header_name_end = p;
+                ctx->header_start = p;
+                ctx->header_end = p;
+                state = sw_almost_done;
+                break;
+            }
+
+            if (ch == LF) {
+                ctx->header_name_end = p;
+                ctx->header_start = p;
+                ctx->header_end = p;
+                goto done;
+            }
+
+            return NGX_ERROR;
+
+        /* space* before header value */
+        case sw_space_before_value:
+            switch (ch) {
+            case ' ':
+                break;
+            case CR:
+                ctx->header_start = p;
+                ctx->header_end = p;
+                state = sw_almost_done;
+                break;
+            case LF:
+                ctx->header_start = p;
+                ctx->header_end = p;
+                goto done;
+            default:
+                ctx->header_start = p;
+                state = sw_value;
+                break;
+            }
+            break;
+
+        /* header value */
+        case sw_value:
+            switch (ch) {
+            case ' ':
+                ctx->header_end = p;
+                state = sw_space_after_value;
+                break;
+            case CR:
+                ctx->header_end = p;
+                state = sw_almost_done;
+                break;
+            case LF:
+                ctx->header_end = p;
+                goto done;
+            }
+            break;
+
+        /* space* before end of header line */
+        case sw_space_after_value:
+            switch (ch) {
+            case ' ':
+                break;
+            case CR:
+                state = sw_almost_done;
+                break;
+            case LF:
+                goto done;
+            default:
+                state = sw_value;
+                break;
+            }
+            break;
+
+        /* end of header line */
+        case sw_almost_done:
+            switch (ch) {
+            case LF:
+                goto done;
+            default:
+                return NGX_ERROR;
+            }
+
+        /* end of header */
+        case sw_header_almost_done:
+            switch (ch) {
+            case LF:
+                goto header_done;
+            default:
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    ctx->lookup_resp->pos = p;
+    ctx->state = state;
+
+    return NGX_AGAIN;
+
+done:
+
+    ctx->lookup_resp->pos = p + 1;
+    ctx->state = sw_start;
+
+    return NGX_OK;
+
+header_done:
+
+    ctx->lookup_resp->pos = p + 1;
+    ctx->state = sw_start;
+
+    return NGX_DONE;
+}
+
+static void
+ngx_zm_lookup_process_response_headers(ngx_zm_lookup_ctx_t *ctx)
+{
+    ngx_zm_lookup_conf_t         *zlcf;
+
+    size_t                        len;
+    ngx_int_t                     rc, n;
+    ngx_zm_lookup_work_t         *work;
+    ngx_str_t                     addr; /* route ipaddr */
+    ngx_str_t                     port; /* route port   */
+    ngx_flag_t                    isCacheAlias;  /* whether to cache alias for the auth account */
+
+    zlcf = (ngx_zm_lookup_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    work = ctx->work;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+                   "zm lookup: process route discovery HTTP headers");
+
+    for (;;)
+    {
+        rc = ngx_zm_lookup_parse_response_headers(ctx);
+
+        if (rc == NGX_OK)
+        {
+
+#if (NGX_DEBUG)
+            {
+            ngx_str_t  key, value;
+
+            key.len = ctx->header_name_end - ctx->header_name_start;
+            key.data = ctx->header_name_start;
+            value.len = ctx->header_end - ctx->header_start;
+            value.data = ctx->header_start;
+
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ctx->log, 0,
+                           "zm_ngx_lookup_module: zm lookup http header: \"%V: %V\"",
+                           &key, &value);
+            }
+#endif
+
+            len = ctx->header_name_end - ctx->header_name_start;
+
+            if (len == sizeof("Auth-Status") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Status",
+                                   sizeof("Auth-Status") - 1)
+                   == 0)
+            {
+                len = ctx->header_end - ctx->header_start;
+
+                if (len == 2
+                    && ctx->header_start[0] == 'O'
+                    && ctx->header_start[1] == 'K')
+                {
+                    continue;
+                }
+
+                if (len == 4
+                    && ctx->header_start[0] == 'W'
+                    && ctx->header_start[1] == 'A'
+                    && ctx->header_start[2] == 'I'
+                    && ctx->header_start[3] == 'T')
+                {
+                    /* NginxLookup never return "Auth-Status: WAIT" */
+                    continue;
+                }
+
+                /* Accept error msg like "Auth-Status: login failed" */
+                work->err.len = len;
+                work->err.data = ctx->header_start;
+
+                continue;
+            }
+
+            if (len == sizeof("Auth-Server") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Server",
+                                   sizeof("Auth-Server") - 1)
+                    == 0)
+            {
+                addr.len = ctx->header_end - ctx->header_start;
+                addr.data = ctx->header_start;
+
+                continue;
+            }
+
+            if (len == sizeof("Auth-Port") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Port",
+                                   sizeof("Auth-Port") - 1)
+                   == 0)
+            {
+                port.len = ctx->header_end - ctx->header_start;
+                port.data = ctx->header_start;
+
+                continue;
+            }
+
+            if (len == sizeof("Auth-Cache-Alias") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Cache-Alias",
+                                   sizeof("Auth-Cache-Alias") - 1)
+                   == 0)
+            {
+                len = ctx->header_end - ctx->header_start;
+
+                if (len == 4
+                    && ctx->header_start[0] == 'T'
+                    && ctx->header_start[1] == 'R'
+                    && ctx->header_start[2] == 'U'
+                    && ctx->header_start[3] == 'E')
+                {
+                    /* cache the alias if True*/
+                    isCacheAlias = 1;
+                } else {
+                    isCacheAlias = 0;
+                }
+                continue;
+            }
+            if (len == sizeof("Auth-User") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-User",
+                                   sizeof("Auth-User") - 1)
+                   == 0)
+            {
+                work->account_name.len = ctx->header_end - ctx->header_start;
+                work->account_name.data = ctx->header_start;
+
+                continue;
+            }
+
+            if (len == sizeof("Auth-Pass") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Pass",
+                                   sizeof("Auth-Pass") - 1)
+                   == 0)
+            {
+                /* client cert auth will return zm_auth_token in
+                   Auth-Pass
+                 */
+                if (work->auth_method == ZM_AUTHMETH_GSSAPI ||
+                    work->auth_method == ZM_AUTHMETH_CERTAUTH) {
+                    work->zm_auth_token.len = ctx->header_end - ctx->header_start;
+                    work->zm_auth_token.data = ctx->header_start;
+                }
+
+                continue;
+            }
+
+            if (len == sizeof("Auth-ID") - 1
+                    && ngx_strncasecmp(ctx->header_name_start,
+                                 (u_char *) "Auth-ID",
+                                 sizeof("Auth-ID") - 1)
+                 == 0)
+            {
+                /* just for GSSAPI */
+                if (work->auth_method == ZM_AUTHMETH_GSSAPI) {
+                    work->auth_id.len = ctx->header_end - ctx->header_start;
+                    work->auth_id.data = ctx->header_start;
+                }
+
+                continue;
+            }
+
+
+            if (len == sizeof("Auth-Wait") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Wait",
+                                   sizeof("Auth-Wait") - 1)
+                   == 0)
+            {
+                n = ngx_atoi(ctx->header_start,
+                             ctx->header_end - ctx->header_start);
+
+                if (n != NGX_ERROR) {
+                    work->wait_time = n;
+                }
+
+                continue;
+            }
+
+
+            if (len == sizeof("Auth-Error-Code") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Auth-Error-Code",
+                                   sizeof("Auth-Error-Code") - 1)
+                   == 0)
+            {
+               /* NginxLookup never return this header */
+            }
+
+            continue;
+        }
+
+        if (rc == NGX_AGAIN ) {
+            return;
+        }
+
+        /* close connection to the lookup handler */
+        ngx_zm_lookup_close_connection(ctx);
+        work->ctx = NULL; /* avoid duplicate clean up */
+
+        if (rc == NGX_DONE){
+            ngx_log_debug0(NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+                           "zm lookup: done processing lookup headers");
+            if (work->err.len) {
+                /* Login failed */
+                ngx_log_error(NGX_LOG_ERR, ctx->log, 0, "zm lookup: an error is "
+                                       "returned by zimbra lookup handler: %V", &work->err);
+                work->result = ZM_LOOKUP_LOGIN_FAILED;
+                work->on_failure(work);
+                return;
+
+            } else {
+                if (IS_LOOKUP_ROUTE(work->auth_method)) {
+
+                    ngx_log_debug3(NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+                             "zm lookup: lookup handler %V sent route %V:%V",
+                             ctx->peer.name, &addr, &port);
+                   if (addr.len == 0 || port.len == 0) {
+                       work->result = ZM_LOOKUP_INVALID_ROUTE;
+                       work->on_failure(work);
+                       return;
+                   } else {
+                       /* retrieve route */
+                       work->route = ngx_palloc(ctx->pool, sizeof(ngx_addr_t));
+                       if (work->route == NULL) { /* NO MEM */
+                           work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+                           work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+                           work->on_failure(work);
+                           return;
+                       }
+                       if (ngx_zm_lookup_retrieve_route (ctx->pool,
+                              &addr, &port, work->route) == NGX_ERROR) {
+
+                           /* route retrival error */
+                           ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                                  "Error occurs when retrieve route info from lookup handler, "
+                                  "addr=%V, port=%V", &addr, &port);
+                           work->result = ZM_LOOKUP_INVALID_ROUTE;
+                           work->err = ERRMSG[ZM_LOOKUP_INVALID_ROUTE];
+                           work->on_failure(work);
+                           return;
+                       } else {
+
+                           /* route retrival succeed */
+                           if (zlcf->caching &&
+                               ctx->work->auth_method != ZM_AUTHMETH_GSSAPI &&
+                               ctx->work->auth_method != ZM_AUTHMETH_CERTAUTH) {
+                               /* add alias-->account && account-->route caching */
+                               if (ctx->work->alias_check_stat != ZM_ALIAS_FOUND &&
+                                   ctx->work->alias_check_stat != ZM_ALIAS_IGNORED && isCacheAlias) {
+                                   /* only cache alias-->account when the account is unavailable from cache */
+                                   /* cache alias-->account with default domain */
+                                   ngx_zm_lookup_cache_alias(ctx, work->username, work->account_name);
+                               }
+
+                               if (work->account_name.len > 0) {
+                                   ngx_zm_lookup_cache_route(ctx, work->account_name, work->route->name);
+                               } else {
+                                   ngx_zm_lookup_cache_route(ctx, work->username, work->route->name);
+                               }
+                           }
+                           work->result = ZM_LOOKUP_SUCCESS;
+                           work->on_success(work);
+                           return;
+                       }
+                   }
+                } else {
+                    /* non-route lookup, such as certauth */
+                    work->result = ZM_LOOKUP_SUCCESS;
+                    work->on_success(work);
+                    return;
+                }
+            }
+        }
+
+        /* rc == NGX_ERROR */
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+              "zm lookup: route handler %V sent invalid header in response",
+              ctx->peer.name);
+
+        return;
+    }
+}
+
+
+static ngx_int_t
+ngx_zm_lookup_retrieve_route (ngx_pool_t * pool, ngx_str_t * addr_text,
+            ngx_str_t * port_text, ngx_addr_t * route)
+{
+    ngx_int_t                rc;
+    size_t                   i;
+    ngx_flag_t               ipv6, domainName;
+    ngx_url_t                u;
+    u_char                   c;
+
+    ipv6 = 0, domainName = 0;
+    for (i = 0; i < addr_text->len; i++) {
+        c = addr_text->data[i];
+        if (c == ':') {
+            /* an addr containing ":" may be IPv6 */
+            domainName = 0;
+            ipv6 = 1;
+            break;
+        } else if (c >= 'A' && c != '.') {
+            domainName = 1;
+            // try to look for ":". if found it must be ipv6
+        }
+    }
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+    u.uri_part = 0;
+
+    if(ipv6) {
+        u.url.len = addr_text->len + port_text->len + 3;
+        u.url.data = ngx_palloc(pool, u.url.len);
+        ngx_sprintf(u.url.data, "[%V]:%V", addr_text, port_text);
+    } else { /* ipv4 or domain name */
+        u.url.len = addr_text->len + port_text->len + 1;
+        u.url.data = ngx_palloc(pool, u.url.len);
+        ngx_sprintf(u.url.data, "%V:%V", addr_text, port_text);
+    }
+
+    if(!domainName) {
+        u.listen = 1; // set this will only parse the IP but not resolve addr
+    }
+
+    rc = ngx_parse_url(pool, &u);
+
+    if(rc != NGX_OK) {
+        return rc;
+    }
+
+    route->name = u.url;
+    route->socklen = u.socklen;
+    route->sockaddr = ngx_palloc(pool, route->socklen);
+    ngx_memcpy(route->sockaddr, &u.sockaddr, route->socklen);
+
+    return NGX_OK;
+}
+
+static void
+ngx_zm_lookup_close_connection(ngx_zm_lookup_ctx_t * ctx) {
+    if (ctx->peer.connection) {
+        ngx_log_debug2 (NGX_LOG_DEBUG_ZIMBRA, ctx->log, 0,
+               "close connection %p to nginx lookup handler %V",
+               ctx->peer.connection, ctx->peer.name);
+#if (NGX_SSL)
+
+        if (ctx->handler->ssl && ctx->peer.connection->ssl) {
+            ctx->peer.connection->ssl->no_wait_shutdown = 1;
+            ngx_ssl_shutdown(ctx->peer.connection);
+        }
+
+#endif
+        ngx_close_connection(ctx->peer.connection);
+        ctx->peer.connection = NULL;
+    }
+}
+
+void
+ngx_zm_lookup_finalize(ngx_zm_lookup_work_t * work)
+{
+    ngx_zm_lookup_ctx_t  *ctx;
+
+    if (work == NULL) {
+        return;
+    }
+
+    ctx = work->ctx;
+
+    if(ctx != NULL) {
+        if(ctx->wait_memcache) {
+            ngx_memcache_ignore_work_by_ctx(ctx);
+            work->ctx = NULL;
+            return;
+        }
+
+        ngx_zm_lookup_close_connection(ctx);
+        work->ctx = NULL;
+        return;
+    }
+}
+
+/*
+ * Giving a socket, return its local addr string representation IP. The
+ * string will be allocated on "pool".
+ */
+ngx_str_t
+ngx_zm_lookup_get_local_socket_addr_text (ngx_pool_t *pool, ngx_socket_t s)
+{
+    int family;
+    static ngx_str_t     res;
+    struct sockaddr_in  *sin;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6 *sin6;
+#endif
+    u_char              *p;
+    socklen_t            len, strlen;
+    u_char               sockaddr[NGX_SOCKADDRLEN];
+
+    len = NGX_SOCKADDRLEN;
+    ngx_memzero(sockaddr, len);
+    getsockname(s, (struct sockaddr*)sockaddr, &len);
+
+    family = ((struct sockaddr *)sockaddr)->sa_family;
+    if (family == AF_INET) {
+        sin = (struct sockaddr_in *)sockaddr;
+        p = ngx_palloc(pool, NGX_INET_ADDRSTRLEN);
+        strlen = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                NGX_INET_ADDRSTRLEN);
+
+#if (NGX_HAVE_INET6)
+    } else {
+        sin6 = (struct sockaddr_in6 *)sockaddr;
+        p = ngx_palloc(pool, NGX_INET6_ADDRSTRLEN);
+        strlen = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                p, NGX_INET6_ADDRSTRLEN);
+#endif
+
+    }
+
+    res.data = p;
+    res.len = strlen;
+
+    return res;
+}
+
+/* make the cache "alias-->account" */
+static void
+ngx_zm_lookup_cache_alias(ngx_zm_lookup_ctx_t *ctx, ngx_str_t alias,
+        ngx_str_t account_name) {
+    mc_work_t                                mc;
+    ngx_str_t                                key;
+    ngx_log_t                               *log;
+    ngx_zm_lookup_work_t                    *work;
+    ngx_pool_t                              *pool;
+    const u_char                            *p;
+
+    log = ctx->log;
+    work = ctx->work;
+    pool = ctx->pool;
+
+    if (alias.len == account_name.len &&
+        ngx_memcmp(alias.data, account_name.data, alias.len) == 0
+       ) {
+        /* bug 66469, try to take the part before '@' as alias */
+        p = ngx_zm_strchr(alias, '@');
+        if (p == NULL) {
+            return;
+        }
+
+        alias.len = p - alias.data;
+
+        if (work->alias_key.len > 0) {
+            ngx_str_null(&work->alias_key); /* reset it and force regeneration later */
+        }
+    }
+
+    if (work->alias_key.len > 0) {
+            key = work->alias_key;
+
+    } else {
+        if (IS_PROTO_WEB(work->protocol)) {
+            key = ngx_zm_lookup_get_http_alias_key
+                    (pool, log, alias, work->virtual_host);
+        } else {
+            key = ngx_zm_lookup_get_mail_alias_key
+                    (pool, log, alias, work->connection->addr_text);
+        }
+
+        if (key.len == 0) {    /* NOMEM */
+            work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+            work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+            work->on_failure(work);
+            return;
+        }
+
+        work->alias_key = key;
+    }
+
+    mc.ctx = ctx;
+    mc.request_code = mcreq_add;
+    mc.response_code = mcres_unknown;
+    mc.on_success = ngx_zm_lookup_cache_dummy_handler;
+    mc.on_failure = ngx_zm_lookup_cache_dummy_handler;
+
+    //no need to set ctx->wait_memcache_response since w.ctx won't be
+    //destroyed before response comes
+    ngx_memcache_post(&mc, key, account_name, NULL, log);
+}
+
+/*
+ * make the cache account-->route/id-->route
+ * user: account_name/zimbra id
+ */
+static void
+ngx_zm_lookup_cache_route(ngx_zm_lookup_ctx_t *ctx, ngx_str_t user, ngx_str_t route)
+{
+    mc_work_t                 mc;
+    ngx_log_t                *log;
+    ngx_str_t                 key;
+    ngx_zm_lookup_work_t    *work;
+    ngx_zm_lookup_conf_t    *zlcf;
+
+    zlcf = (ngx_zm_lookup_conf_t *)
+              ngx_get_conf(ngx_cycle->conf_ctx, ngx_zm_lookup_module);
+
+    log = ctx->log;
+    work = ctx->work;
+
+    if (work->auth_method == ZM_AUTHMETH_ZIMBRAID) {
+            key = ngx_zm_lookup_get_id_route_key(
+                    ctx->pool, log,
+                    ZM_PROTO[work->protocol], user, work->type);
+    } else {
+        if (zlcf->allow_unqualified == 0 && !is_login_qualified(user)) {
+            key = ngx_zm_lookup_get_user_route_key(ctx->pool, log,
+                    ZM_PROTO[work->protocol], user, work->connection->addr_text);
+        } else {
+            key = ngx_zm_lookup_get_user_route_key(ctx->pool, log,
+                    ZM_PROTO[work->protocol], user, NGX_EMPTY_STR);
+        }
+    }
+
+    if (key.len == 0) {   /* NOMEM */
+        work->result = ZM_LOOKUP_MEM_ALLOC_ERROR;
+        work->err = ERRMSG[ZM_LOOKUP_MEM_ALLOC_ERROR];
+        work->on_failure(work);
+        return;
+    }
+
+    ctx->work->route_key = key;
+
+    mc.ctx = ctx;
+    mc.request_code = mcreq_add;
+    mc.response_code = mcres_unknown;
+    mc.on_success = ngx_zm_lookup_cache_dummy_handler;
+    mc.on_failure = ngx_zm_lookup_cache_dummy_handler;
+
+    //no need to set ctx->wait_memcache_response because nothing
+    //will be disposed
+    ngx_memcache_post(&mc, key, route, NULL, log);
+}
+
+static void
+ngx_zm_lookup_cache_dummy_handler (mc_work_t *work)
+{
+    /* do nothing */
+}
+
+static ngx_str_t
+ngx_zm_lookup_get_user_route_key(ngx_pool_t *pool, ngx_log_t *log,
+        ngx_str_t proto, ngx_str_t account_name, ngx_str_t client_ip)
+{
+    ngx_str_t        key;
+    size_t           len;
+    u_char          *p;
+
+    len = sizeof("route:") - 1 +
+    sizeof("proto=") - 1 +
+    proto.len +
+    sizeof(";") - 1 +
+    sizeof("user=") - 1 +
+    account_name.len;
+
+    if (client_ip.len > 0) {
+        len += sizeof("@") - 1 + client_ip.len;
+    }
+
+    key.data = ngx_palloc(pool, len);
+    if (key.data == NULL) {
+        key.len = 0;
+        return key;
+    }
+
+    p = key.data;
+    p = ngx_cpymem(p, "route:", sizeof("route:") - 1);
+    p = ngx_cpymem(p, "proto=", sizeof("proto=") - 1);
+    p = ngx_cpymem(p, proto.data, proto.len);
+   *p++ = ';';
+    p = ngx_cpymem(p, "user=", sizeof("user=") - 1);
+    p = ngx_cpymem(p, account_name.data, account_name.len);
+
+    if (client_ip.len > 0) {
+        *p++ = '@';
+        p = ngx_cpymem(p, client_ip.data, client_ip.len);
+    }
+
+    key.len = p - key.data;
+
+    return key;
+}
+
+ngx_str_t
+ngx_zm_lookup_get_mail_alias_key (ngx_pool_t  *pool, ngx_log_t *log,
+    ngx_str_t alias, ngx_str_t ip)
+{
+    ngx_str_t       key;
+    size_t          len;
+    u_char         *p;
+
+    len = sizeof("alias:") - 1 +
+        sizeof("user=") - 1 +
+        alias.len +
+        sizeof(";") - 1 +
+        sizeof("ip=") - 1 +
+        ip.len;
+
+    key.data = ngx_palloc(pool, len);
+    if (key.data == NULL) {
+        key.len = 0;
+        return key;
+    }
+
+    p = key.data;
+    p = ngx_cpymem(p, "alias:", sizeof("alias:") - 1);
+    p = ngx_cpymem(p, "user=", sizeof("user=") - 1);
+    p = ngx_cpymem(p, alias.data, alias.len);
+    *p++ = ';';
+    p = ngx_cpymem(p,"ip=", sizeof("ip=") - 1);
+    p = ngx_cpymem(p, ip.data, ip.len);
+
+    key.len = p - key.data;
+
+    return key;
+}
+
+ngx_str_t
+ngx_zm_lookup_get_http_alias_key (ngx_pool_t *pool, ngx_log_t *log,
+    ngx_str_t alias, ngx_str_t vhost)
+{
+    ngx_str_t       key;
+    size_t          len;
+    u_char         *p;
+
+    len = sizeof("alias:") - 1 +
+        sizeof("user=") - 1 +
+        alias.len +
+        sizeof(";") - 1 +
+        sizeof("vhost=") - 1 +
+        vhost.len;
+
+    key.data = ngx_palloc(pool, len);
+    if (key.data == NULL) {
+        key.len = 0;
+        return key;
+    }
+
+    p = key.data;
+    p = ngx_cpymem(p, "alias:", sizeof("alias:") - 1);
+    p = ngx_cpymem(p, "user=", sizeof("user=") - 1);
+    p = ngx_cpymem(p, alias.data, alias.len);
+    *p++ = ';';
+    p = ngx_cpymem(p, "vhost=", sizeof("vhost=") - 1);
+    p = ngx_cpymem(p, vhost.data, vhost.len);
+
+    key.len = p - key.data;
+
+    return key;
+}
+
+static ngx_str_t
+ngx_zm_lookup_get_id_route_key(ngx_pool_t *pool, ngx_log_t *log,
+        ngx_str_t proto, ngx_str_t id, ngx_http_zmauth_t type)
+{
+    ngx_str_t       key;
+    size_t          len;
+    u_char         *p;
+
+    len = sizeof("route:") - 1 +
+        sizeof("proto=") - 1 +
+        proto.len +
+        sizeof(";") - 1 +
+        sizeof("id=") - 1 +
+        id.len;
+    if (type == zmauth_admin_console) {
+        len += sizeof("admin=1;") - 1;
+    } else if (type == zmauth_zx) {
+        len += sizeof("zx=1;") - 1;
+    }
+
+    key.data = ngx_palloc(pool, len);
+    if (key.data == NULL) {
+        key.len = 0;
+        return key;
+    }
+
+    p = key.data;
+    p = ngx_cpymem(p, "route:", sizeof("route:") - 1);
+    p = ngx_cpymem(p, "proto=", sizeof("proto=") - 1);
+    p = ngx_cpymem(p, proto.data, proto.len);
+    *p++ = ';';
+    if (type == zmauth_admin_console) {
+        p = ngx_cpymem(p, "admin=1;", sizeof("admin=1;") - 1);
+    } else if (type == zmauth_zx) {
+        p = ngx_cpymem(p, "zx=1;", sizeof("zx=1;") - 1);
+    }
+    p = ngx_cpymem(p, "id=", sizeof("id=") - 1);
+    p = ngx_cpymem(p, id.data, id.len);
+
+    key.len = p - key.data;
+
+    return key;
+}
+
+/*
+ * delete alias-->account & account-->route cache from memcache
+ * after auth failure
+ */
+void
+ngx_zm_lookup_delete_cache(ngx_str_t alias_key, ngx_str_t route_key)
+{
+    mc_work_t              w;
+    ngx_log_t             *log;
+    ngx_flag_t             delete_alias_cache, delete_route_cache;
+
+    delete_alias_cache = 0;
+    delete_route_cache = 0;
+
+    if (alias_key.len > 0) {
+        delete_alias_cache = 1;
+    }
+
+    if (route_key.len > 0) {
+        delete_route_cache = 1;
+    }
+
+    if (delete_alias_cache == 0 && delete_route_cache == 0) {
+        return;
+    }
+
+    log = ngx_cycle->log;
+
+    w.request_code = mcreq_delete;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_zm_lookup_delete_cache_handler;
+    w.on_failure = ngx_zm_lookup_delete_cache_handler;
+
+    if (delete_alias_cache) {
+        ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, log, 0,
+              "delete cached alias, key:%V", &alias_key);
+        ngx_memcache_post(&w, alias_key, NGX_EMPTY_STR, /* pool */ NULL, log);
+    }
+
+    if (delete_route_cache) {
+        ngx_log_debug1 (NGX_LOG_DEBUG_ZIMBRA, log, 0,
+            "delete cached route, key:%V", &route_key);
+
+        ngx_memcache_post (&w, route_key, NGX_EMPTY_STR, /* pool */ NULL, log);
+    }
+}
+
+static void
+ngx_zm_lookup_delete_cache_handler (mc_work_t *work)
+{
+    /* do nothing */
+}
+
+/* Utility function to check whether a login name is fully qualified
+   Return value is boolean (ngx_flag_t for portability)
+ */
+ngx_flag_t
+is_login_qualified (ngx_str_t login)
+{
+    /* we cannot use the crt strchr because login is not 0 terminated,
+     * neither we have no strnchr to use
+     */
+
+    size_t      i, len;
+    len = login.len - 1; /* if the last symbol is @, it's not qualified */
+
+    for (i = 0; i < len; ++i) {
+        if (login.data[i] == '@') {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+static const u_char *
+ngx_zm_strchr (ngx_str_t str, int chr) {
+    const u_char *end;
+    u_char       *p;
+    u_char        c;
+
+    end = str.data + str.len;
+    p = str.data;
+    c = (u_char)chr;
+    do {
+        if (*p == c) {
+            return p;
+        }
+    } while (++p <= end);
+
+    return NULL;
+}
diff --git a/src/core/ngx_zm_lookup.h b/src/core/ngx_zm_lookup.h
new file mode 100644
index 000000000..3e8a482e5
--- /dev/null
+++ b/src/core/ngx_zm_lookup.h
@@ -0,0 +1,204 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#ifndef _NGX_ZM_LOOKUP_H_INCLUDED_
+#define _NGX_ZM_LOOKUP_H_INCLUDED_
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+
+#define NGX_ZM_LOOKUP_CONF        0x02000000
+
+typedef struct {
+    ngx_addr_t  *peer;
+    ngx_str_t    host;
+    ngx_str_t    uri;
+    time_t       failure_time;     /* the time of last connection failure
+                                      to this handler peer, 0 means the
+                                      peer is now available */
+    ngx_uint_t   ssl;              /* whether handler talks SSL or plain http */
+} ngx_zm_lookup_handler_t;
+
+typedef struct {
+    ngx_pool_t     *pool;           /* main pool where self resides */
+    ngx_log_t      *log;
+    ngx_array_t     handlers;       /* ngx_zm_lookup_handler_t*[] */
+    ngx_uint_t      handler_index;  /* current index of round robin */
+    ngx_msec_t      retry_interval; /* time to retry to connect a handler after a failure (in ms) */
+    ngx_msec_t      timeout;        /* timeout to fetch the result from nginx lookup handler (in ms) */
+    ngx_str_t       master_auth_username;
+    ngx_str_t       master_auth_password;
+    ngx_str_t       url;
+    ngx_flag_t      caching;        /* whether to add and check the alias/route in memcache */
+    ngx_flag_t      allow_unqualified; /* whether to append client ip to the "account-->route" caching key,
+                                          when the alias part is an unqualified name*/
+    size_t          buffer_size;
+    ngx_ssl_t      *ssl;
+} ngx_zm_lookup_conf_t;
+
+struct ngx_zm_lookup_work_s;
+
+typedef void (*ngx_zm_lookup_callback)(struct ngx_zm_lookup_work_s *);
+
+/* zmauth type */
+typedef enum {
+    zmauth_web_client,
+    zmauth_admin_console,
+    zmauth_zx
+} ngx_http_zmauth_t;
+
+struct ngx_zm_lookup_work_s {
+    ngx_pool_t    *pool;
+    ngx_log_t     *log;
+
+    /* input */
+    ngx_str_t      username;        /* the original username given by user */
+    ngx_str_t      auth_id;         /* GSSAPI auth id (principal) */
+    ngx_http_zmauth_t    type;     /* whether is web, admin or /zx/ */
+    ngx_uint_t     protocol:3;      /* protocol               */
+    ngx_uint_t     auth_method:4;   /* auth method            */
+    ngx_uint_t     alias_check_stat:2; /* the alias-->account caching lookup status */
+    ngx_uint_t     login_attempts;  /* only used for mail     */
+    ngx_str_t      virtual_host;    /* only used for web      */
+    ngx_connection_t * connection;  /* client connection      */
+    ngx_str_t      salt;            /* only used for mail     */
+    ngx_str_t      route_key;       /* the key for "account-->route" cache */
+
+    /* output */
+    ngx_addr_t    *route;           /* fetched route */
+    ngx_str_t      err;             /* error message */
+    time_t         wait_time;       /* wait time if login failed */
+
+    /* input & output */
+    ngx_str_t      zm_auth_token;   /* for web route lookup, this will be input;
+                                       for client cert auth, this will be output
+                                     */
+    ngx_str_t      account_name;    /* for mail route lookup, account name is
+                                       always returned
+                                     */
+    ngx_str_t      alias_key;       /* the key for "alias-->account" cache */
+
+    ngx_zm_lookup_callback   on_success;
+    ngx_zm_lookup_callback   on_failure;
+
+    ngx_int_t     result;
+
+    void          *data;            /* context such as http request or mail session */
+    void          *ctx;             /* zm_lookup_ctx */
+};
+
+typedef struct ngx_zm_lookup_work_s ngx_zm_lookup_work_t;
+
+extern ngx_module_t ngx_zm_lookup_module;
+
+struct ngx_zm_lookup_ctx_s;
+
+typedef void (*ngx_zm_lookup_response_handler_t) (struct ngx_zm_lookup_ctx_s * ctx);
+
+struct ngx_zm_lookup_ctx_s {
+    ngx_pool_t              *pool;
+    ngx_log_t               *log;
+
+    /* for lookup handler elect */
+    ngx_uint_t               tries;
+    ngx_uint_t               handler_index;
+
+    ngx_zm_lookup_handler_t *handler; /*current handler to be used */
+    ngx_peer_connection_t    peer;
+
+    /* for request send & response processing */
+    ngx_buf_t               *lookup_req;     /* lookup request buffer  */
+    ngx_buf_t               *lookup_resp;    /* lookup response buffer */
+    ngx_uint_t               state;          /* response parse state   */
+    u_char                  *header_name_start;
+    u_char                  *header_name_end;
+    u_char                  *header_start;
+    u_char                  *header_end;
+    ngx_zm_lookup_response_handler_t  lookup_response_handler;
+
+    ngx_zm_lookup_work_t    *work;
+
+    ngx_uint_t               wait_memcache; /* whether memcache request is
+                                               posted but response doesn't come */
+    ngx_event_t             *wait_ev;
+};
+
+typedef struct ngx_zm_lookup_ctx_s ngx_zm_lookup_ctx_t;
+
+/* lookup result */
+#define ZM_LOOKUP_SUCCESS                 0
+#define ZM_LOOKUP_MEM_ALLOC_ERROR         1
+#define ZM_LOOKUP_WRITE_ERROR             2
+#define ZM_LOOKUP_READ_ERROR              3
+#define ZM_LOOKUP_WRITE_TIMEOUT           4
+#define ZM_LOOKUP_READ_TIMEOUT            5
+#define ZM_LOOKUP_NO_VALID_HANDLER        6
+#define ZM_LOOKUP_INVALID_ROUTE           7
+#define ZM_LOOKUP_LOGIN_FAILED            8
+#define ZM_LOOKUP_INVALID_RESPONSE        9
+#define ZM_LOOKUP_CLIENT_CONNECTION_CLOSE 10
+#define ZM_LOOKUP_OTHER_ERROR             50
+#define ZM_LOOKUP_SSL_EVENT_SUCCESS       0
+#define ZM_LOOKUP_SSL_EVENT_FAILED        1
+
+/* the protocols nginx lookup can serve for */
+#define ZM_PROTO_UNKNOWN 0
+#define ZM_PROTO_HTTP    1
+#define ZM_PROTO_HTTPS   2
+#define ZM_PROTO_POP3    3
+#define ZM_PROTO_POP3S   4
+#define ZM_PROTO_IMAP    5
+#define ZM_PROTO_IMAPS   6
+
+#define IS_PROTO_MAIL(proto) (proto == ZM_PROTO_POP3  || \
+                              proto == ZM_PROTO_POP3S || \
+                              proto == ZM_PROTO_IMAP  || \
+                              proto == ZM_RPOTO_IMAPS)
+
+#define IS_PROTO_WEB(proto) (proto == ZM_PROTO_HTTP || \
+                             proto == ZM_PROTO_HTTPS)
+
+/* alias-->account caching check state */
+#define ZM_ALIAS_NOT_CHECKED 0  /* need to be checked but not done yet     */
+#define ZM_ALIAS_FOUND       1  /* has been checked and found              */
+#define ZM_ALIAS_NOT_FOUND   2  /* has been checked and not found          */
+#define ZM_ALIAS_IGNORED     3  /* has been checked and found, but ignored */
+
+/* the auth method supported */
+#define ZM_AUTHMETH_USERNAME 0  /* get route by user name                  */
+#define ZM_AUTHMETH_GSSAPI   1  /* get route and account id by kerberos v5 */
+#define ZM_AUTHMETH_ZIMBRAID 2  /* get route by zimbra account id          */
+#define ZM_AUTHMETH_CERTAUTH 3  /* get account id by client certificate    */
+
+#define IS_LOOKUP_ROUTE(auth_meth) (!(auth_meth == ZM_AUTHMETH_CERTAUTH))
+
+void ngx_zm_lookup(ngx_zm_lookup_work_t * work);
+void ngx_zm_lookup_delete_cache(ngx_str_t alias_key, ngx_str_t route_key);
+void ngx_zm_lookup_finalize(ngx_zm_lookup_work_t * work);
+ngx_flag_t ngx_zm_lookup_check_broken_connection(ngx_event_t *ev,
+        ngx_zm_lookup_work_t *work);
+
+/* utility */
+ngx_flag_t is_login_qualified (ngx_str_t login);
+
+/* memcache key create */
+ngx_str_t ngx_zm_lookup_get_http_alias_key(ngx_pool_t *pool,
+        ngx_log_t *log, ngx_str_t alias, ngx_str_t vhost);
+ngx_str_t ngx_zm_lookup_get_mail_alias_key(ngx_pool_t *pool,
+        ngx_log_t *log, ngx_str_t user, ngx_str_t ip);
+
+#endif
diff --git a/src/http/modules/ngx_http_upstream_zmauth_module.c b/src/http/modules/ngx_http_upstream_zmauth_module.c
new file mode 100644
index 000000000..fcbb452a6
--- /dev/null
+++ b/src/http/modules/ngx_http_upstream_zmauth_module.c
@@ -0,0 +1,1547 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <ngx_zm_lookup.h>
+#include <ngx_http_upstream_zmauth_module.h>
+#include <ctype.h>
+
+/* zmauth type */
+enum ngx_http_zmauth_type {
+    zmauth_web_client,
+    zmauth_admin_console
+};
+
+static char * ngx_http_upstream_zmauth(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+static char * ngx_http_upstream_zmauth_admin(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+
+static void *ngx_http_upstream_zmauth_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_http_upstream_zmauth_merge_srv_conf(ngx_conf_t *cf,
+        void *parent, void *child);
+
+static ngx_int_t ngx_http_upstream_init_zmauth_peer(ngx_http_request_t *r,
+        ngx_http_upstream_srv_conf_t *us);
+static ngx_int_t ngx_http_upstream_init_admin_zmauth_peer(ngx_http_request_t *r,
+        ngx_http_upstream_srv_conf_t *us);
+static ngx_int_t ngx_http_upstream_do_init_zmauth_peer(ngx_http_request_t *r,
+        ngx_http_upstream_srv_conf_t *us, enum ngx_http_zmauth_type type);
+static ngx_int_t ngx_http_upstream_get_zmauth_peer(ngx_peer_connection_t *pc,
+        void *data);
+static void ngx_http_upstream_free_zmauth_peer(ngx_peer_connection_t *pc,
+        void *data, ngx_uint_t state);
+static void zmauth_lookup_result_handler(ngx_zm_lookup_work_t *work);
+static void ngx_http_upstream_zmauth_cleanup(void *data);
+
+static ngx_http_upstream_rr_peer_t* zmauth_get_current_peer(
+        ngx_http_upstream_zmauth_peer_data_t *zmp);
+static inline void zmauth_set_peer(ngx_peer_connection_t *pc,
+        ngx_http_upstream_zmauth_peer_data_t *zmp);
+
+static ngx_flag_t zmauth_check_rest(ngx_http_request_t *r, void **extra);
+static ngx_flag_t zmauth_check_activesync(ngx_http_request_t *r, void **extra);
+static ngx_flag_t zmauth_check_caldav(ngx_http_request_t *r, void **extra);
+static ngx_flag_t zmauth_check_authtoken(ngx_http_request_t *r, void **extra);
+static ngx_flag_t zmauth_check_admin_authtoken(ngx_http_request_t *r,
+        void **extra);
+static zmroutetype_t zmauth_check_uri(ngx_http_request_t *r, void **extra);
+static zmroutetype_t zmauth_check_admin_uri(ngx_http_request_t *r, void **extra);
+static ngx_flag_t zmauth_find_arg(/* const */ngx_str_t *args, /* const */
+ngx_str_t *arg, ngx_str_t *val);
+
+#ifdef unused
+static ngx_flag_t ngx_http_upstream_zmserver_from_cookie
+(ngx_log_t *log, ngx_pool_t *pool, ngx_table_elt_t *cookie, ngx_addr_t *peer);
+#endif
+
+static void zmauth_translate_activesync_usr(ngx_pool_t *pool, ngx_str_t *src,
+        ngx_str_t *tgt);
+static ngx_flag_t ngx_field_from_zmauthtoken(ngx_log_t *log, ngx_pool_t *pool,
+        ngx_str_t *authtoken, ngx_str_t *field, ngx_str_t *value);
+static ngx_flag_t ngx_get_cookie_value(ngx_log_t *log,
+        ngx_table_elt_t **cookies, ngx_uint_t ncookies, ngx_str_t *name,
+        ngx_str_t *value);
+static ngx_flag_t ngx_get_query_string_arg(ngx_log_t *log, ngx_str_t *args,
+        ngx_str_t *name, ngx_str_t *value);
+
+static ngx_str_t NGX_ZMAUTHTOKEN_ID = ngx_string("id");
+static ngx_str_t NGX_ZMAUTHTOKEN = ngx_string("ZM_AUTH_TOKEN");
+static ngx_str_t NGX_ZMAUTHTOKEN_ADMIN = ngx_string("ZM_ADMIN_AUTH_TOKEN");
+static ngx_str_t NGX_ZAUTHTOKEN = ngx_string("zauthtoken");
+
+static ngx_command_t ngx_http_upstream_zmauth_commands[] =
+{
+    { ngx_string("zmauth"),
+      NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS,
+      ngx_http_upstream_zmauth,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("zmauth_admin"),
+      NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS,
+      ngx_http_upstream_zmauth_admin,
+      0,
+      0,
+      NULL },
+
+    ngx_null_command
+};
+
+static ngx_http_module_t ngx_http_upstream_zmauth_module_ctx = {
+        NULL,                                       /* preconfiguration */
+        NULL,                                       /* postconfiguration */
+        NULL,                                       /* create main configuration */
+        NULL,                                       /* init main configuration */
+        ngx_http_upstream_zmauth_create_srv_conf,   /* create server config */
+        ngx_http_upstream_zmauth_merge_srv_conf,    /* merge server config */
+        NULL,                                       /* create location configuration */
+        NULL                                        /* merge location configuration */
+};
+
+ngx_module_t ngx_http_upstream_zmauth_module = {
+        NGX_MODULE_V1,
+        &ngx_http_upstream_zmauth_module_ctx,
+        ngx_http_upstream_zmauth_commands,
+        NGX_HTTP_MODULE,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NGX_MODULE_V1_PADDING
+};
+
+/* handle the `zmauth' configuration directive in an upstream block
+ */
+static char *
+ngx_http_upstream_zmauth(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_upstream_srv_conf_t *uscf;
+
+    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);
+    uscf->peer.init_upstream = ngx_http_upstream_init_zmauth;
+
+    uscf->flags = NGX_HTTP_UPSTREAM_CREATE | NGX_HTTP_UPSTREAM_MAX_FAILS
+            | NGX_HTTP_UPSTREAM_FAIL_TIMEOUT | NGX_HTTP_UPSTREAM_DOWN;
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_http_upstream_zmauth_admin(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_upstream_srv_conf_t *uscf;
+
+    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);
+    uscf->peer.init_upstream = ngx_http_upstream_init_admin_zmauth;
+
+    uscf->flags = NGX_HTTP_UPSTREAM_CREATE | NGX_HTTP_UPSTREAM_MAX_FAILS
+            | NGX_HTTP_UPSTREAM_FAIL_TIMEOUT | NGX_HTTP_UPSTREAM_DOWN;
+
+    return NGX_CONF_OK;
+}
+
+/* This is the 'init_upstream' routine -- called when the main upstream
+ configuration is initialized -- at this point, all the component servers
+ in the upstream block should already be known, so that data-structures
+ can be initialized here
+ */
+ngx_int_t
+ngx_http_upstream_init_zmauth(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
+{
+    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    us->peer.init = ngx_http_upstream_init_zmauth_peer;
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_http_upstream_init_admin_zmauth(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
+{
+    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    us->peer.init = ngx_http_upstream_init_admin_zmauth_peer;
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_http_upstream_init_zmauth_peer(ngx_http_request_t *r,
+        ngx_http_upstream_srv_conf_t *us)
+{
+    return ngx_http_upstream_do_init_zmauth_peer(r, us, zmauth_web_client);
+}
+
+static ngx_int_t
+ngx_http_upstream_init_admin_zmauth_peer(ngx_http_request_t *r,
+        ngx_http_upstream_srv_conf_t *us)
+{
+    return ngx_http_upstream_do_init_zmauth_peer(r, us, zmauth_admin_console);
+}
+
+/* This function is called when an incoming http request needs to be routed to
+ one of the peers inside the upstream block
+ */
+static ngx_int_t
+ngx_http_upstream_do_init_zmauth_peer(ngx_http_request_t *r,
+        ngx_http_upstream_srv_conf_t *us, enum ngx_http_zmauth_type type)
+{
+    ngx_http_upstream_zmauth_peer_data_t *zmp;
+    struct sockaddr_in                   *sin;
+    struct sockaddr_in6                  *sin6;
+    int                                   i;
+    u_char                               *p, *q;
+    ngx_str_t                             usr, schema;
+    ngx_http_upstream_zmauth_ctx_t       *ctx;
+    ngx_pool_t                           *pool;
+    void                                 *info;
+    ngx_zm_lookup_work_t                 *work;
+
+    ngx_log_debug0 (NGX_LOG_DEBUG_ZIMBRA, r->connection->log, 0,
+            "zmauth: lookup route for web proxy");
+
+    zmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_zmauth_peer_data_t));
+
+    if (zmp == NULL) {
+        return NGX_ERROR;
+    }
+
+    r->upstream->peer.data = &zmp->rrp;
+    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {
+        ngx_log_debug0 (NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                "zmauth: cannot initialize round-robin fallback");
+        return NGX_ERROR;
+    }
+
+    r->upstream->peer.get = ngx_http_upstream_get_zmauth_peer;
+    r->upstream->peer.free = ngx_http_upstream_free_zmauth_peer;
+    zmp->get_rr_peer = ngx_http_upstream_get_round_robin_peer;
+
+    /* initialize data for iphash for cases before AUTH TOKEN (prelogin) */
+    zmp->family = r->connection->sockaddr->sa_family;
+    if (zmp->family == AF_INET6) {
+        sin6 = (struct sockaddr_in6 *) r->connection->sockaddr;
+        p = (u_char *) &sin6->sin6_addr.s6_addr;
+        for (i = 0; i < 16; i++) {
+            zmp->addr[i] = p[i];
+        }
+        q = (u_char *) &sin6->sin6_port;
+    } else {
+        sin = (struct sockaddr_in *) r->connection->sockaddr;
+        p = (u_char *) &sin->sin_addr.s_addr;
+        for (i = 0; i < 4; i++) {
+            zmp->addr[i] = p[i];
+        }
+        q = (u_char *) &sin->sin_port;
+    }
+    zmp->porth = q[0];
+    zmp->portl = q[1];
+
+    zmp->hash = 89;
+    zmp->tries = 0;
+
+    if (type == zmauth_web_client) {
+        zmp->zmroutetype = zmauth_check_uri(r, &info);
+    } else if (type == zmauth_admin_console) {
+        zmp->zmroutetype = zmauth_check_admin_uri(r, &info);
+    } else {
+        zmp->zmroutetype = zmroutetype_fallback;
+    }
+
+    if (zmp->zmroutetype != zmroutetype_fallback) {
+        usr = *((ngx_str_t*) info);
+
+        ngx_log_debug0 (NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                "zmauth: route lookup required to proxy request");
+
+        pool = ngx_create_pool(2048, r->connection->log);
+        if (pool == NULL) {
+            return NGX_ERROR;
+        }
+
+        ctx = ngx_pcalloc(pool, sizeof(ngx_http_upstream_zmauth_ctx_t));
+        if (ctx == NULL) {
+            ngx_destroy_pool(pool);
+            return NGX_ERROR;
+        }
+
+        ngx_http_set_ctx(r, ctx, ngx_http_upstream_zmauth_module);
+
+        ctx->pool = pool;
+        ctx->zmp = zmp;
+
+        //prepare cleanup
+        ngx_http_cleanup_t * cln = ngx_http_cleanup_add(r, 0);
+        cln->handler = ngx_http_upstream_zmauth_cleanup;
+        cln->data = r;
+
+        work = ngx_pcalloc(pool, sizeof(ngx_zm_lookup_work_t));
+        if(work == NULL) {
+            ngx_destroy_pool(pool);
+            return NGX_ERROR;
+        }
+        work->pool = pool;
+        work->log = r->connection->log;
+        work->connection = r->connection;
+        work->data = r;
+        work->username = usr;
+        if (r->headers_in.host != NULL) {
+            work->virtual_host = r->headers_in.host->value;
+        }
+        work->alias_check_stat = ZM_ALIAS_NOT_CHECKED;
+        work->on_success = zmauth_lookup_result_handler;
+        work->on_failure = zmauth_lookup_result_handler;
+
+        schema = r->upstream->schema;
+        if (schema.len == sizeof("http://") - 1
+                && ngx_strncmp(schema.data, (u_char *)"http://", sizeof("http://") - 1) == 0) {
+            work->protocol = ZM_PROTO_HTTP;
+        } else if (schema.len == sizeof("https://") - 1
+                && ngx_strncmp(schema.data, (u_char *) "https://", sizeof("https://") - 1) == 0) {
+            work->protocol = ZM_PROTO_HTTPS;
+        }
+
+        if (zmp->zmroutetype == zmroutetype_authtoken) {
+            work->auth_method = ZM_AUTHMETH_ZIMBRAID;
+        } else {
+            work->auth_method = ZM_AUTHMETH_USERNAME;
+        }
+
+        if (type == zmauth_admin_console) {
+            work->isAdmin = 1;
+        }
+        ctx->work = work;
+        ctx->connect = us->connect;
+
+        ngx_zm_lookup(work);
+
+        return NGX_AGAIN; // return NGX_AGAIN to indicate this is an async peer init
+    }
+    /* otherwise, routetype is fallback, then IPHASH will be used during getting peer */
+
+    return NGX_OK;
+}
+
+/* This method is invoked in order to fill in the sockaddr, socklen, and name
+ parameters of the peer connection data-structure (ngx_peer_connection_t)
+ */
+static ngx_int_t
+ngx_http_upstream_get_zmauth_peer(ngx_peer_connection_t *pc,
+        void *data) {
+    ngx_http_upstream_zmauth_peer_data_t *zmp = data;
+    ngx_http_upstream_rr_peer_t *peer;
+    time_t now;
+    uintptr_t m;
+    ngx_uint_t i, n, p, hash, len;
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, pc->log, 0,
+            "zmauth: prepare upstream connection, try: %d",
+            pc->tries);
+
+    now = ngx_time();
+
+    if (zmp->zmroutetype != zmroutetype_fallback) {
+        zmp->rrp.current = zmauth_get_current_peer(zmp);
+        if (zmp->rrp.current != NGX_INVALID_ARRAY_INDEX) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                    "zmauth: upstream server %d is returned by zmlookup", zmp->rrp.current);
+
+            peer = &zmp->rrp.peers->peer[zmp->rrp.current];
+            if (!peer->down) {
+
+                if (peer->max_fails == 0 || peer->fails < peer->max_fails) {
+                    zmauth_set_peer(pc, zmp);
+                    return NGX_OK;
+                }
+
+                if (now - peer->accessed > peer->fail_timeout) {
+                    peer->fails = 0;
+                    zmauth_set_peer(pc, zmp);
+                    return NGX_OK;
+                }
+            }
+
+            zmp->rrp.current = NGX_INVALID_ARRAY_INDEX;
+            return NGX_BUSY;
+
+        } else {
+            ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                    "zmauth: upstream server %V returned by zmlookup "
+                    "is not defined in upstream block, ignore failure check",
+                    &zmp->zmpeer.name);
+            /* if the peer returned by zmlookup is not found in upstream block, just use it */
+            if (zmp->tries > 0) { /* have tried, won't try again*/
+                return NGX_BUSY;
+            }
+            zmauth_set_peer(pc, zmp);
+            zmp->tries++;
+            return NGX_OK;
+        }
+    }
+
+    /* check whether to use round robin */
+    if (zmp->tries > 20 || zmp->rrp.peers->number == 1) {
+        return zmp->get_rr_peer(pc, &zmp->rrp);
+    }
+
+    pc->cached = 0;
+    pc->connection = NULL;
+
+    hash = zmp->hash;
+
+    for (;;) {
+        /* use all four octets of ipv4 address, plus two bytes of ipv4 port,
+         for computation of ip-hash. this ensures better distribution
+         */
+        len = (zmp->family == AF_INET6) ? 16 : 4;
+        for (i = 0; i < len; ++i) {
+            hash = (hash * 113 + zmp->addr[i]) % 6271;
+        }
+
+	/*
+	 * since client IP PORT can change, client IP PORTS are not
+	 * used to generate HASH
+	 */
+
+        //hash = (hash * 113 + zmp->porth) % 6271;
+        //hash = (hash * 113 + zmp->portl) % 6271;
+
+        zmp->hash = hash;
+
+        p = hash % zmp->rrp.peers->number;
+
+        n = p / (8 * sizeof(uintptr_t));
+        m = 1 << p % (8 * sizeof(uintptr_t));
+
+        if (!(zmp->rrp.tried[n] & m)) {
+
+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,
+                    "get ip hash peer, hash: %ui %04XA", p, m);
+
+            peer = &zmp->rrp.peers->peer[p];
+
+            /* ngx_lock_mutex(iphp->rrp.peers->mutex); */
+
+            if (!peer->down) {
+
+                if (peer->max_fails == 0 || peer->fails < peer->max_fails) {
+                    break;
+                }
+
+                if (now - peer->accessed > peer->fail_timeout) {
+                    peer->fails = 0;
+                    break;
+                }
+            }
+
+            zmp->rrp.tried[n] |= m;
+
+            /* ngx_unlock_mutex(iphp->rrp.peers->mutex); */
+
+            pc->tries--;
+        }
+
+        if (++zmp->tries >= 20) {
+            return zmp->get_rr_peer(pc, &zmp->rrp);
+        }
+    }
+
+    zmp->rrp.current = peer;
+
+    pc->sockaddr = peer->sockaddr;
+    pc->socklen = peer->socklen;
+    pc->name = &peer->name;
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, pc->log, 0,
+            "zmauth: %V elected by iphash", &peer->name);
+
+    /* ngx_unlock_mutex(zmp->rrp.peers->mutex); */
+
+    zmp->rrp.tried[n] |= m;
+    zmp->hash = hash;
+
+    return NGX_OK;
+}
+
+/* clean up zmauth ctx */
+static void
+ngx_http_upstream_zmauth_cleanup(void * data)
+{
+    ngx_http_request_t * r;
+    ngx_http_upstream_zmauth_ctx_t * ctx;
+    r = (ngx_http_request_t *)data;
+    ctx = ngx_http_get_module_ctx(r, ngx_http_upstream_zmauth_module);
+    if (ctx != NULL) {
+        ngx_zm_lookup_finalize(ctx->work);
+        ngx_destroy_pool(ctx->pool);
+        ngx_http_set_ctx(r, NULL, ngx_http_upstream_zmauth_module);
+    }
+}
+
+static void
+zmauth_lookup_result_handler(ngx_zm_lookup_work_t * work) {
+    ngx_http_request_t *r;
+    ngx_http_upstream_zmauth_ctx_t *ctx;
+    ngx_http_upstream_zmauth_peer_data_t *zmp;
+    r = (ngx_http_request_t *) work->data;
+    ctx = ngx_http_get_module_ctx(r, ngx_http_upstream_zmauth_module);
+    zmp = ctx->zmp;
+
+    if (work->result == ZM_LOOKUP_SUCCESS) {
+        /* deep copy route from zmauth pool to r pool */
+        zmp->zmpeer.name = *(ngx_pstrcpy(r->pool, &work->route->name));
+        zmp->zmpeer.socklen = work->route->socklen;
+        zmp->zmpeer.sockaddr = ngx_palloc(r->pool, zmp->zmpeer.socklen);
+        if (zmp->zmpeer.sockaddr == NULL) {
+            return; /* NO MEM */
+        }
+        ngx_memcpy(zmp->zmpeer.sockaddr, work->route->sockaddr, zmp->zmpeer.socklen);
+
+    } else {
+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                "zmauth: an error occurs during zm lookup: %V, fall back to "
+                "IPHASH to get the upstream route",
+                &work->err);
+        /* fallback to IPHASH (bug 54641, bug 52553) */
+        zmp->zmroutetype = zmroutetype_fallback;
+    }
+
+    ngx_destroy_pool(ctx->pool);
+    ngx_http_set_ctx(r, NULL, ngx_http_upstream_zmauth_module);
+
+    /* bug 64775, 62374, we have to invoke "connect" at last statement */
+    ctx->connect(r, r->upstream); /* async invoke ngx_http_upstream_connect */
+}
+
+static void
+ngx_http_upstream_free_zmauth_peer(ngx_peer_connection_t *pc,
+        void *data, ngx_uint_t state) {
+    ngx_http_upstream_zmauth_peer_data_t *zmp = data;
+    /* only handle the case when the upstream returned by zmlookup is within
+     * upstream block in the config file
+     */
+    if (zmp->rrp.current != NULL) {
+        ngx_http_upstream_free_round_robin_peer(pc, &zmp->rrp, state);
+    }
+}
+
+/* examine a single request cookie for ZM_AUTH_TOKEN
+ if present, fill in peer with the ip:port of the decoded mailhost (true)
+ else return false
+ */
+#ifdef unused
+static ngx_flag_t ngx_http_upstream_zmserver_from_cookie
+(ngx_log_t *log, ngx_pool_t *pool, ngx_table_elt_t *cookie, ngx_addr_t *peer)
+{
+    ngx_str_t *cv = &cookie->value;
+    u_char *p, *q, *start, *end;
+    ngx_int_t z;
+    ngx_str_t enc_token, enc_zmdata, dec_zmdata, ip, line;
+    ngx_int_t part1, part2, part3;
+    size_t i,j,qlen;
+    ngx_flag_t ret;
+    u_char *ZM_AUTH_TOKEN = (u_char *)"ZM_AUTH_TOKEN";
+    const size_t ZMLEN = sizeof("ZM_AUTH_TOKEN")-1;
+
+    ret = 0;
+
+    start = cv->data;
+    end = start + cv->len;
+    p = start;
+
+    /* cv will be of the form name=value; name=value; name=value; ... */
+    while (p < end)
+    {
+        line.data = p;
+        line.len = end - p;
+
+        /* The latter part of the loop will ensure that at this point, `p'
+         points to the start of a "NAME=VALUE" string
+         */
+
+        z = ngx_memn2cmp (p, ZM_AUTH_TOKEN, (size_t)(end-p) > ZMLEN ? ZMLEN : (size_t)(end-p), ZMLEN);
+
+        if (z == 0)
+        {
+            /* match found
+             the value against zm_auth_token is
+             X_YYY_ZZZZZZZZZZ
+             the X and Y parts must be ignored, and the Z part is hex-encoded
+             after decoding the Z part, we can get a string like:
+             id=36:cc00ce85-8c0b-49eb-8e08-a8aab43ce836;exp=13:1196504658160;type=6:zimbra;mailhost=14:127.0.0.1:7070;
+             */
+
+            p = p + ZMLEN;
+
+            if (p < end)
+            {
+                /* There is some value against ZM_AUTH_TOKEN
+
+                 TODO: research the RFC on the cookie header and see if spaces
+                 are allowed between [NAME=VALUE], as in [NAME = VALUE]
+                 */
+                if (*p == '=')
+                {
+                    ++p;
+
+                    /* p is at (ZMAUTH_TOKEN=)VALUE
+                     ^
+                     build up enc_token containing the entire value
+                     */
+
+                    enc_token.data = p;
+
+                    part2 = part3 = -1;
+                    part1 = 0;
+
+                    while (p < end && *p != ';' && !isspace(*p)) {
+                        if (*p == '_') {
+                            if (part2 < 0) {part2 = (p-enc_token.data) +1;}
+                            else if (part3 < 0) {part3 = (p-enc_token.data) +1;}
+                        }
+                        ++p;
+                    }
+
+                    if (part3 < 0) {part3 = 0;}
+
+                    enc_token.len = p - enc_token.data;
+
+                    /* enc_token contains the entire hex-encoded auth-token,
+                     we are interested in only the part after the second
+                     underscore
+                     */
+
+                    enc_zmdata.data = enc_token.data + part3;
+                    enc_zmdata.len = enc_token.len - part3;
+
+                    /* now enc_zmdata contains the hex-encoded auth-token */
+                    if (enc_zmdata.len % 2 == 1) {
+                        ngx_log_error (NGX_LOG_ERR, log, 0,
+                                "zmauth: odd bytes in hex-encoded zmauth: enc=[%V], len=[%d]",
+                                &enc_zmdata, enc_zmdata.len
+                        );
+                    } else {
+                        /* now hex-decode the thingy */
+                        dec_zmdata.data = ngx_palloc (pool, enc_zmdata.len/2 +1); // +1 for null
+                        dec_zmdata.len = enc_zmdata.len/2;
+
+                        for (i =0, j=0; i<enc_zmdata.len; i=i+2, j=j+1) {
+                            if (enc_zmdata.data[i] >= '0' && enc_zmdata.data[i] <= '9') {
+                                dec_zmdata.data[j] = enc_zmdata.data[i] - '0';
+                            } else {
+                                dec_zmdata.data[j] = 10 + tolower (enc_zmdata.data[i]) - 'a';
+                            }
+                            dec_zmdata.data[j] <<= 4;
+                            if (enc_zmdata.data[i+1] >= '0' && enc_zmdata.data[i+1] <= '9') {
+                                dec_zmdata.data[j] += (enc_zmdata.data[i+1] - '0');
+                            } else {
+                                dec_zmdata.data[j] += 10 + tolower (enc_zmdata.data[i+1]) - 'a';
+                            }
+                        }
+
+                        dec_zmdata.data[j] =0;
+
+                        /* The decoded data looks like (on a single line) -
+
+                         id=36:cc00ce85-8c0b-49eb-8e08-a8aab43ce836;
+                         exp=13:1196504658160;
+                         type=6:zimbra;
+                         mailhost=14:127.0.0.1:7070;
+
+                         semicolon separated list of strings of the form
+                         field=len:value
+
+                         */
+
+                        ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                                "zmauth: decode(ZM_AUTH_TOKEN):[%V]", &dec_zmdata
+                        );
+
+                        /* now we set up a loop to locate the mailhost */
+                        q = (u_char *) ngx_strstr (dec_zmdata.data, "mailhost=");
+
+                        if (q != NULL) {
+                            q += sizeof("mailhost=") -1;
+                            // now q will point to the length: portion of the ipaddress:port
+                            qlen = 0;
+                            while (*q != ':') { // XXX: no bounds check - too far in
+                                qlen = (qlen*10) + (*q-'0');
+                                ++q;
+                            }
+                            ++q; // consume ':'
+                            ip.data = q;
+                            ip.len = qlen;
+
+                            /* now ip contains the ip-address:port of the upstream */
+                            ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                                    "zmauth: mailhost(ZM_AUTH_TOKEN):[%V]", &ip
+                            );
+
+                            *peer = *deserialize_peer_ipv4 (ip.data, ip.len, pool);
+                            ret=1;
+                        }
+                    }
+                }
+            }
+
+        } else {
+            while (p < end && *p!=';') {++p;}
+            if (p < end) {
+                ++p; // consume `;'
+                while (p < end && isspace (*p)) {++p;}
+            } else {
+                /* we have reached the end of the cookie string */
+                continue;
+            }
+        }
+    }
+
+    return ret;
+}
+#endif
+
+static ngx_flag_t
+ngx_get_cookie_value(ngx_log_t *log,
+        ngx_table_elt_t **cookies, ngx_uint_t ncookies, ngx_str_t *name,
+        ngx_str_t *value) {
+    ngx_table_elt_t **c;
+    u_char *s, *p, *e;
+    ngx_str_t V, n, v;
+    ngx_flag_t f;
+
+    for (c = cookies, f = 0; c < cookies + ncookies && f == 0; ++c) {
+        V = (*c)->value;
+        /* v is of the form "name=value; name=value;" */
+        s = V.data;
+        e = s + V.len;
+        p = s;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+                "zmauth: examining cookie value:%V",&V);
+
+        while (p < e) {
+            n.data = p;
+            while (p < e && *p != '=') {
+                ++p;
+            }
+            if (p == e) {
+                break;
+            }
+            n.len = p - n.data;
+            ++p; // consume =
+            v.data = p;
+            while (p < e && *p != ';') {
+                ++p;
+            }
+            v.len = p - v.data;
+            if (n.len == name->len && ngx_memcmp(n.data, name->data, n.len)
+                    == 0) {
+                *value = v;
+                f = 1;
+                break;
+            }
+            if (p == e) {
+                break;
+            }
+            ++p; // consume ;
+            while (p < e && (*p == ' ' || *p == '\t')) {
+                ++p;
+            }
+        }
+    }
+
+    return f;
+}
+
+static ngx_flag_t ngx_get_query_string_arg(ngx_log_t *log, ngx_str_t *args,
+        ngx_str_t *name, ngx_str_t *value) {
+    ngx_flag_t f = 0;
+    u_char *f1, *f2, *v1, *v2, *s, *e, *p;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP,log,0,
+            "zmauth: examing query-string %V for field:%V", args, name);
+
+    s = args->data;
+    e = s + args->len;
+
+    for (p = s; p < e;) {
+        f1 = f2 = v1 = v2 = p;
+
+        /* we are at the start of name=value */
+
+        while (*p != '=' && p < e) {
+            ++p;
+        }
+
+        f2 = p;
+        if (p == e) {
+            break;
+        }
+        ++p;
+
+        v1 = p;
+        v2 = v1;
+        if (p == e) {
+            break;
+        }
+
+        while (*p != '&' && p < e) {
+            ++p;
+        }
+
+        v2 = p;
+
+        if (f2 == f1 + name->len && ngx_memcmp(f1, name->data, f2 - f1) == 0) {
+            value->data = v1;
+            value->len = v2 - v1;
+            ngx_log_debug3(NGX_LOG_DEBUG_HTTP,log,0,
+                    "zmauth: found value:%V against arg:%V in query-string:%V",
+                    value, name, args);
+            f = 1;
+            break;
+        }
+
+        if (p == e) {
+            break;
+        }
+
+        ++p;
+    }
+
+    return f;
+}
+
+/* extract a field from ZM_AUTH_TOKEN */
+static ngx_flag_t
+ngx_field_from_zmauthtoken(ngx_log_t *log, ngx_pool_t *pool,
+        ngx_str_t *authtoken, ngx_str_t *field, ngx_str_t *value) {
+    ngx_str_t T2, t2;
+    u_char *p, *s, *e;
+    ngx_uint_t t;
+    ngx_flag_t f;
+    ngx_str_t F, V;
+    ngx_uint_t i, j, l;
+
+    s = authtoken->data;
+    e = s + authtoken->len;
+
+    p = s;
+
+    for (p = s, t = 0, f = 0; p < e && f == 0; ++p) {
+        if (*p == '_') {
+            if (t == 1) {
+                T2.data = p + 1;
+                T2.len = e - T2.data;
+                f = 1;
+            } else {
+                ++t;
+            }
+        }
+    }
+
+    if (f == 0) {
+        ngx_log_error(NGX_LOG_INFO,log,0,
+                "zmauth: auth-token:%V does not contain 3 fields",
+                authtoken);
+
+        return 0;
+    }
+
+    /* hex-decode T2 to t2 */
+
+    if (T2.len % 2 != 0) {
+        ngx_log_error(NGX_LOG_INFO, log, 0,
+                "zmauth: auth-token(#2):%V is invalid hex",
+                &T2);
+
+        return 0;
+    }
+
+    t2.len = T2.len / 2;
+    t2.data = ngx_palloc(pool, t2.len);
+
+    if (t2.data == NULL) {
+        /* nomem */
+        return 0;
+    }
+
+    for (i = 0, j = 0; i < T2.len; i = i + 2, j = j + 1) {
+        if (T2.data[i] >= '0' && T2.data[i] <= '9') {
+            t2.data[j] = T2.data[i] - '0';
+        } else {
+            t2.data[j] = 10 + tolower(T2.data[i]) - 'a';
+        }
+        t2.data[j] <<= 4;
+        if (T2.data[i + 1] >= '0' && T2.data[i + 1] <= '9') {
+            t2.data[j] += (T2.data[i + 1] - '0');
+        } else {
+            t2.data[j] += (10 + tolower(T2.data[i + 1]) - 'a');
+        }
+    }
+
+    /* t2 now contains the entire decoded portion #2 of the auth token */
+
+    ngx_log_debug1(NGX_LOG_DEBUG_ZIMBRA, log, 0,
+            "zmauth: decoded(auth-token(#2)): %V",
+            &t2);
+
+    /* now we need to search for the named field
+     the decoded portion of the authtoken(#2) looks like
+     field=len:value;field=len:value;...
+     */
+
+    s = t2.data;
+    e = s + t2.len;
+    f = 0;
+    p = s;
+
+    while (p < e) {
+        F.data = p;
+        while (p < e && *p != '=') {
+            ++p;
+        }
+        if (p == e) {
+            break;
+        }
+        F.len = p - F.data;
+        l = 0;
+        ++p; // consume =
+        while (p < e && (*p >= '0' && *p <= '9')) {
+            l = (l * 10) + (*p - '0');
+            ++p;
+        }
+        if (p == e) {
+            break;
+        }
+        if (*p != ':') {
+            break;
+        }
+        ++p; // consume :
+        V.data = p;
+        while (p < e && p < V.data + l) {
+            ++p;
+        }
+        if (p != V.data + l) {
+            break;
+        }
+        V.len = l;
+
+        if (F.len == field->len && ngx_memcmp(field->data, F.data, F.len) == 0) {
+            f = 1;
+            *value = V;
+            ngx_log_debug3(NGX_LOG_DEBUG_ZIMBRA, log, 0,
+                    "zmauth: auth-token(field=%V,len=%d,value=%V)", &F, V.len,
+                    &V);
+            break;
+        }
+
+        if (p < e) {
+            ++p;
+        } // consume ;
+    }
+
+    return f;
+}
+
+static void *
+ngx_http_upstream_zmauth_create_srv_conf(ngx_conf_t *cf) {
+    ngx_http_upstream_zmauth_srv_conf_t *zscf;
+
+    zscf = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_zmauth_srv_conf_t));
+    if (zscf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    return zscf;
+}
+
+static char *
+ngx_http_upstream_zmauth_merge_srv_conf(ngx_conf_t *cf, void *parent,
+        void *child) {
+    ngx_http_upstream_zmauth_srv_conf_t *prev = parent;
+    ngx_http_upstream_zmauth_srv_conf_t *conf = child;
+
+    ngx_conf_merge_value(conf->dummy, prev->dummy, 0);
+
+    return NGX_CONF_OK;
+}
+
+/* examine the request uri for zimbra REST patterns
+ currently supported patterns -
+
+ /home/user/content
+ /home/~/content
+ /home/~user/content
+ /service/home/user/content
+ /service/home/~/content
+ /service/home/~user/content
+
+ return true(1) if indeed the request URI matches a REST pattern
+ also fill in usr with the correct usr if so
+
+ usr is blanked out before processing begins
+ refer ZimbraServer/docs/rest.txt for details
+ */
+static ngx_flag_t
+zmauth_check_rest(ngx_http_request_t *r, void **extra) {
+    ngx_flag_t f;
+    u_char *p;
+    ngx_log_t *log;
+    ngx_pool_t *pool;
+    ngx_str_t ausr, *usr;
+
+    f = 0;
+    pool = r->pool;
+    log = r->connection->log;
+
+    ausr.data = (u_char*) "";
+    ausr.len = 0;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, log, 0,
+            "zmauth: examining uri:%V for REST", &r->uri);
+
+    if (r->uri.len >= sizeof("/home/~/") - 1
+            && ngx_memcmp(r->uri.data,"/home/~/", sizeof("/home/~/") - 1) == 0) {
+        f = 0; /* for /home/~/ route will be discovered from the zm_auth_token */
+    } else if (r->uri.len >= sizeof("/home/~") - 1
+            && ngx_memcmp(r->uri.data,"/home/~", sizeof("/home/~") - 1) == 0) {
+        ausr.data = r->uri.data + (sizeof("/home/~") - 1);
+        for (p = ausr.data; p < r->uri.data + r->uri.len; ++p) {
+            if (*p == '/') {
+                f = 1;
+                break;
+            }
+        }
+        ausr.len = p - ausr.data;
+    } else if (r->uri.len >= sizeof("/home/") - 1
+            && ngx_memcmp(r->uri.data,"/home/",sizeof("/home/") - 1) == 0) {
+        ausr.data = r->uri.data + (sizeof("/home/") - 1);
+        for (p = ausr.data; p < r->uri.data + r->uri.len; ++p) {
+            if (*p == '/') {
+                f = 1;
+                break;
+            }
+        }
+        ausr.len = p - ausr.data;
+    } else if (r->uri.len >= sizeof("/service/home/~/") - 1
+            && ngx_memcmp(r->uri.data,"/service/home/~/", sizeof("/service/home/~/") - 1)
+                    == 0) {
+        f = 0; /* for /service/home/~/ route will be discovered from the zm_auth_token */
+    } else if (r->uri.len >= sizeof("/service/home/~") - 1
+            && ngx_memcmp(r->uri.data,"/service/home/~", sizeof("/service/home/~") - 1)
+                    == 0) {
+        ausr.data = r->uri.data + (sizeof("/service/home/~") - 1);
+        for (p = ausr.data; p < r->uri.data + r->uri.len; ++p) {
+            if (*p == '/') {
+                f = 1;
+                break;
+            }
+        }
+        ausr.len = p - ausr.data;
+    } else if (r->uri.len >= sizeof("/service/home/") - 1
+            && ngx_memcmp(r->uri.data, "/service/home/", sizeof("/service/home/") - 1)
+                    == 0) {
+        ausr.data = r->uri.data + (sizeof("/service/home/") - 1);
+        for (p = ausr.data; p < r->uri.data + r->uri.len; ++p) {
+            if (*p == '/') {
+                f = 1;
+                break;
+            }
+        }
+        ausr.len = p - ausr.data;
+    }
+
+    if (f) {
+        if (ausr.len == 0) {
+            f = 0;
+        }
+    }
+
+    if (f) {
+        usr = ngx_palloc(pool, sizeof(ngx_str_t));
+        if (usr == NULL) {
+            f = 0;
+        } else {
+            *usr = ausr;
+            *extra = usr;
+        }
+    }
+
+    if (f) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP,log,0,
+                "uri:%V matched a REST pattern, user:%V", &r->uri, &ausr);
+    }
+
+    return f;
+}
+
+static ngx_flag_t
+zmauth_check_activesync(ngx_http_request_t *r, void **extra) {
+    ngx_log_t *log;
+    ngx_pool_t *pool;
+    ngx_str_t authval, cred64, cred, credusr, *usr;
+    u_char *p;
+    ngx_flag_t rc;
+    ngx_str_t userArg = ngx_string("User");
+
+    rc = 0;
+    log = r->connection->log;
+    pool = r->pool;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP,log,0,
+            "zmauth: examining uri:%V for ActiveSync", &r->uri);
+
+    if (r->uri.len >= sizeof("/Microsoft-Server-ActiveSync") - 1
+            && ngx_memcmp(r->uri.data,"/Microsoft-Server-ActiveSync",sizeof("/Microsoft-Server-ActiveSync")-1)
+                    == 0) {
+        if (r->headers_in.authorization != NULL
+                && r->headers_in.authorization->value.data != NULL) {
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP,log,0,
+                    "ActiveSync: Found RFC 2617 authorization header: %V",
+                    &r->headers_in.authorization->value);
+            authval = r->headers_in.authorization->value;
+            if (authval.len >= sizeof("Basic ") - 1
+                    && ngx_memcmp(authval.data,"Basic ",sizeof("Basic ")-1)
+                            == 0) {
+                cred64 = authval;
+                cred64.data += (sizeof("Basic ") - 1);
+                cred64.len -= (sizeof("Basic ") - 1);
+                cred.len = ngx_base64_decoded_length(cred64.len);
+                cred.data = ngx_palloc(pool, cred.len);
+                if (cred.data != NULL) {
+                    if (ngx_decode_base64(&cred, &cred64) == NGX_OK) {
+
+#if (NGX_DEBUG_HTTP_PASSWD)
+     ngx_log_debug1(NGX_LOG_DEBUG_HTTP,log,0,
+                    "ActiveSync: found auth basic credentials: %V", &cred);
+#endif
+
+                        /* (RFC 2617)
+
+                         basic-credentials = base64-user-pass
+                         base64-user-pass  = <base64 [4] encoding of user-pass,
+                         except not limited to 76 char/line>
+                         user-pass   = userid ":" password
+                         userid      = *<TEXT excluding ":">
+                         password    = *TEXT
+                         */
+
+                        credusr.data = cred.data;
+                        p = cred.data;
+                        while (p < cred.data + cred.len && *p != ':') {
+                            ++p;
+                        }
+                        credusr.len = p - cred.data;
+                        usr = ngx_palloc(pool, sizeof(ngx_str_t));
+
+                        if (usr != NULL) {
+                            zmauth_translate_activesync_usr(pool, &credusr, usr);
+                            ngx_log_debug2(NGX_LOG_DEBUG_HTTP,log,0,
+                                    "ActiveSync: user:%V translated to user:%V for route discovery",
+                                    &credusr,usr);
+
+                            *extra = usr;
+                            rc = 1;
+                        }
+                    }
+                }
+            }
+
+        } else {
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP,log,0,
+                    "ActiveSync: No authorization header, examine args: [%V]",
+                    &r->args);
+
+            usr = ngx_palloc(pool, sizeof(ngx_str_t));
+            if (usr != NULL && zmauth_find_arg(&r->args, &userArg, usr) != 0) {
+                ngx_log_debug1(NGX_LOG_DEBUG_HTTP,log,0,
+                        "ActiveSync: fallback to HTTP argument User1:%V",
+                        usr);
+
+                *extra = usr;
+                rc = 1;
+            }
+        }
+    }
+
+    return rc;
+}
+
+static ngx_flag_t
+zmauth_check_caldav(ngx_http_request_t *r, void **extra) {
+    ngx_log_t *log;
+    ngx_pool_t *pool;
+    ngx_str_t *usr, ausr = ngx_string("");
+    u_char *p;
+    ngx_flag_t f;
+
+    f = 0;
+    log = r->connection->log;
+    pool = r->pool;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP,log,0,
+            "zmauth: examining uri:%V for caldav", &r->uri);
+
+    if (r->uri.len >= sizeof("/dav/") - 1
+            && ngx_memcmp(r->uri.data,"/dav/",sizeof("/dav/") - 1) == 0) {
+        ausr.data = r->uri.data + (sizeof("/dav/") - 1);
+        for (p = ausr.data; p < r->uri.data + r->uri.len; ++p) {
+            if (*p == '/') {
+                f = 1;
+                break;
+            }
+        }
+        ausr.len = p - ausr.data;
+    } else if (r->uri.len >= sizeof("/principals/users/") - 1
+            && ngx_memcmp(r->uri.data,"/principals/users/", sizeof("/principals/users/") - 1)
+                    == 0) {
+        ausr.data = r->uri.data + (sizeof("/principals/users/") - 1);
+        for (p = ausr.data; p < r->uri.data + r->uri.len; ++p) {
+            if (*p == '/') {
+                f = 1;
+                break;
+            }
+        }
+        ausr.len = p - ausr.data;
+    }
+
+    if (f) {
+        if (ausr.len == 0) {
+            f = 0;
+        }
+    }
+
+    if (f) {
+        usr = ngx_palloc(pool, sizeof(ngx_str_t));
+        if (usr == NULL) {
+            f = 0;
+        } else {
+            *usr = ausr;
+            *extra = usr;
+        }
+    }
+
+    if (f) {
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP,log,0,
+                "uri:%V matched caldav, user:%V", &r->uri,&ausr);
+    }
+
+    return f;
+}
+
+/* examine request cookies for ZM_AUTH_TOKEN and extract route if so */
+static ngx_flag_t
+zmauth_check_authtoken(ngx_http_request_t *r, void **extra) {
+    ngx_pool_t *pool;
+    ngx_log_t *log;
+    ngx_str_t token, id, *pid;
+    ngx_flag_t f;
+
+    pool = r->pool;
+    log = r->connection->log;
+
+    ngx_log_debug0 (NGX_LOG_DEBUG_HTTP, log, 0,
+            "zmauth: search for ZM_AUTH_TOKEN");
+
+    /* look for auth token in the request cookie(s) */
+    f = ngx_get_cookie_value(log,
+            (ngx_table_elt_t **) r->headers_in.cookies.elts,
+            r->headers_in.cookies.nelts, &NGX_ZMAUTHTOKEN, &token);
+
+    if (!f) {
+        /* if not found, then look in the zauthtoken= query string arg */
+        f = ngx_get_query_string_arg(log, &r->args, &NGX_ZAUTHTOKEN, &token);
+    }
+
+    if (f) {
+        ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                "zmauth: found ZM_AUTH_TOKEN:%V",
+                &token);
+
+        f = ngx_field_from_zmauthtoken(log, pool, &token, &NGX_ZMAUTHTOKEN_ID,
+                &id);
+
+        if (f) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                    "zmauth: got id:%V from ZM_AUTH_TOKEN",
+                    &id);
+            if (id.len > 0) {
+                pid = ngx_palloc(pool, sizeof(ngx_str_t));
+                if (pid == NULL) {
+                    f = 0;
+                } else {
+                    pid->data = ngx_pstrdup(pool, &id); /* TODO: shallowcopy? */
+                    if (pid->data == NULL) {
+                        f = 0;
+                    } else {
+                        pid->len = id.len;
+                        *((ngx_str_t**) extra) = pid;
+                    }
+                }
+            } else {
+                f = 0;
+            }
+        } else {
+            ngx_log_debug0 (NGX_LOG_DEBUG_HTTP, log, 0,
+                    "zmauth: no id in ZM_AUTH_TOKEN"
+            )   ;
+        }
+
+    } else {
+        ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                "zmauth: no ZM_AUTH_TOKEN",
+                &token);
+    }
+
+    return f;
+}
+
+/* examine request cookies for ZM_ADMIN_AUTH_TOKEN and extract route if so */
+static ngx_flag_t
+zmauth_check_admin_authtoken(ngx_http_request_t *r,
+        void **extra) {
+    ngx_pool_t *pool;
+    ngx_log_t *log;
+    ngx_str_t token, id, *pid;
+    ngx_flag_t f;
+
+    pool = r->pool;
+    log = r->connection->log;
+
+    ngx_log_debug0 (NGX_LOG_DEBUG_HTTP, log, 0,
+            "zmauth: search for ZM_ADMIN_AUTH_TOKEN");
+
+    /* look for auth token in the request cookie(s) */
+    f = ngx_get_cookie_value(log,
+            (ngx_table_elt_t **) r->headers_in.cookies.elts,
+            r->headers_in.cookies.nelts, &NGX_ZMAUTHTOKEN_ADMIN, &token);
+
+    if (f) {
+        ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                "zmauth: found ZM_AUTH_TOKEN:%V",
+                &token);
+
+        f = ngx_field_from_zmauthtoken(log, pool, &token, &NGX_ZMAUTHTOKEN_ID,
+                &id);
+
+        if (f) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                    "zmauth: got id:%V from ZM_AUTH_TOKEN",
+                    &id);
+            if (id.len > 0) {
+                pid = ngx_palloc(pool, sizeof(ngx_str_t));
+                if (pid == NULL) {
+                    f = 0;
+                } else {
+                    pid->data = ngx_pstrdup(pool, &id); /* TODO: shallowcopy? */
+                    if (pid->data == NULL) {
+                        f = 0;
+                    } else {
+                        pid->len = id.len;
+                        *((ngx_str_t**) extra) = pid;
+                    }
+                }
+            } else {
+                f = 0;
+            }
+        } else {
+            ngx_log_debug0 (NGX_LOG_DEBUG_HTTP, log, 0,
+                    "zmauth: no id in ZM_ADMIN_AUTH_TOKEN"
+            )   ;
+        }
+
+    } else {
+        ngx_log_debug1 (NGX_LOG_DEBUG_HTTP, log, 0,
+                "zmauth: no ZM_ADMIN_AUTH_TOKEN",
+                &token);
+    }
+
+    return f;
+}
+
+static zmroutetype_t
+zmauth_check_uri(ngx_http_request_t *r, void **extra) {
+    zmroutetype_t rtype;
+
+    rtype = zmroutetype_fallback;
+    if (zmauth_check_rest(r, extra)) {
+        rtype = zmroutetype_rest;
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP,r->connection->log,0,
+                "zmauth: routing for REST");
+    } else if (zmauth_check_activesync(r, extra)) {
+        rtype = zmroutetype_activesync;
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP,r->connection->log,0,
+                "zmauth: routing for ActiveSync");
+    } else if (zmauth_check_caldav(r, extra)) {
+        rtype = zmroutetype_caldav;
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP,r->connection->log,0,
+                "zmauth: routing for caldav");
+    } else if (zmauth_check_authtoken(r, extra)) {
+        rtype = zmroutetype_authtoken;
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP,r->connection->log,0,
+                "zmauth: routing by ZM_AUTH_TOKEN");
+    } else {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP,r->connection->log,0,
+                "zmauth: routing by iphash");
+    }
+    return rtype;
+}
+
+static zmroutetype_t
+zmauth_check_admin_uri(ngx_http_request_t *r, void **extra) {
+    zmroutetype_t rtype;
+
+    rtype = zmroutetype_fallback;
+    if (zmauth_check_admin_authtoken(r, extra)) {
+        rtype = zmroutetype_authtoken;
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP,r->connection->log,0,
+                "zmauth: routing by ZM_ADMIN_AUTH_TOKEN");
+    }
+    return rtype;
+}
+
+/* translate an activesync user rep to zimbra user rep
+ domain\user becomes user@domain
+ others remain identical
+ */
+static void
+zmauth_translate_activesync_usr(ngx_pool_t *pool, ngx_str_t *src,
+        ngx_str_t *tgt) {
+    u_char *p, *q;
+
+    tgt->data = ngx_pstrdup(pool, src);
+    if (tgt->data == NULL) {
+        *tgt = *src;
+        return;
+    }
+
+    tgt->len = src->len;
+    p = src->data;
+
+    while (p < src->data + src->len) {
+        if (*p == '\\') {
+            q = ngx_cpymem(tgt->data, p + 1, src->len - (p - src->data) - 1);
+            *q++ = '@';
+            q = ngx_cpymem(q, src->data, p - src->data);
+            break;
+        }
+        ++p;
+    }
+
+    return;
+}
+
+/* extract an argument from query string args of the form n1=v1&n2=v2&n3=v3 */
+static ngx_flag_t
+zmauth_find_arg(/* const */ngx_str_t *args, /* const */
+ngx_str_t *arg, ngx_str_t *val) {
+    ngx_flag_t rc;
+    u_char *p, *s, *e;
+    ngx_str_t n, v;
+
+    rc = 0;
+    s = args->data;
+    e = s + args->len;
+    p = s;
+
+    while (p < e) {
+        n.data = p;
+        while (p < e && *p != '=') {
+            ++p;
+        }
+        if (p == e) {
+            break;
+        }
+        n.len = p - n.data;
+
+        ++p;
+        v.data = p;
+
+        while (p < e && *p != '&') {
+            ++p;
+        }
+        if (p == e) {
+            break;
+        }
+
+        v.len = p - v.data;
+        ++p;
+
+        if (n.len == arg->len && ngx_memcmp(n.data, arg->data, n.len) == 0) {
+            *val = v;
+            rc = 1;
+            break;
+        }
+    }
+
+    return rc;
+}
+
+/* find the upstream server returned by zmlookup in upstream block,
+ * return pointer if found or null if not found */
+static ngx_http_upstream_rr_peer_t *
+zmauth_get_current_peer(
+        ngx_http_upstream_zmauth_peer_data_t *zmp) {
+    struct sockaddr_in *zmaddr, *peeraddr;
+    struct sockaddr_in6 *zmaddr6, *peeraddr6;
+    ngx_http_upstream_rr_peer_t *peer;
+    ngx_uint_t i;
+
+    for (i = 0; i < zmp->rrp.peers->number; i++) {
+        peer = &zmp->rrp.peers->peer[i];
+
+        if (zmp->zmpeer.sockaddr->sa_family != peer->sockaddr->sa_family) {
+            continue;
+        }
+
+        if (zmp->zmpeer.sockaddr->sa_family == AF_INET) {
+            zmaddr = (struct sockaddr_in *) zmp->zmpeer.sockaddr;
+            peeraddr = (struct sockaddr_in *) peer->sockaddr;
+
+            if (ngx_memcmp(&zmaddr->sin_addr, &peeraddr->sin_addr, 4) == 0
+                    && zmaddr->sin_port == peeraddr->sin_port) {
+                return peer;
+            }
+        } else { /* AF_INET6 */
+            zmaddr6 = (struct sockaddr_in6 *) zmp->zmpeer.sockaddr;
+            peeraddr6 = (struct sockaddr_in6 *) peer->sockaddr;
+
+            if (ngx_memcmp(&zmaddr6->sin6_addr, &peeraddr6->sin6_addr, 16) == 0
+                    && zmaddr6->sin6_port == peeraddr6->sin6_port) {
+                return peer;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+/* set the peer from zmlookup to peer connection */
+static inline void
+zmauth_set_peer(ngx_peer_connection_t *pc,
+        ngx_http_upstream_zmauth_peer_data_t *zmp) {
+    pc->sockaddr = zmp->zmpeer.sockaddr;
+    pc->socklen = zmp->zmpeer.socklen;
+    pc->name = &zmp->zmpeer.name;
+}
diff --git a/src/http/modules/ngx_http_upstream_zmauth_module.h b/src/http/modules/ngx_http_upstream_zmauth_module.h
new file mode 100644
index 000000000..9bc5999ae
--- /dev/null
+++ b/src/http/modules/ngx_http_upstream_zmauth_module.h
@@ -0,0 +1,70 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#if !defined(_NGX_HTTP_UPSTREAM_ZMAUTH_H_INCLUDED_)
+#define _NGX_HTTP_UPSTREAM_ZMAUTH_H_INCLUDED_
+
+typedef enum {
+    zmroutetype_fallback = 0,
+    zmroutetype_authtoken,
+    zmroutetype_rest,
+    zmroutetype_activesync,
+    zmroutetype_caldav
+} zmroutetype_t;
+
+typedef struct {
+    /* the round robin data must be first */
+    ngx_http_upstream_rr_peer_data_t    rrp;
+
+    /* IPHASH */
+    ngx_uint_t                          hash;
+#if (NGX_HAVE_INET6)
+    int                                 family;
+    u_char                              addr[16];   /* both AF_INET and AF_INET6 */
+#else
+    u_char                              addr[4];    /* AF_INET addr */
+#endif
+    u_char                              porth;      /* AF_INET port-hi */
+    u_char                              portl;      /* AF_INET port-lo */
+    u_char                              tries;
+
+    ngx_event_get_peer_pt               get_rr_peer;
+    zmroutetype_t                       zmroutetype;
+    ngx_addr_t                          zmpeer;
+} ngx_http_upstream_zmauth_peer_data_t;
+
+typedef struct {
+    ngx_flag_t           dummy; /* just for place holder */
+} ngx_http_upstream_zmauth_srv_conf_t;
+
+typedef void (*ngx_http_upstream_zmauth_handler_pt)(ngx_http_request_t *r);
+
+typedef struct {
+    ngx_pool_t                                 *pool;
+    ngx_log_t                                  *log;
+    ngx_zm_lookup_work_t                       *work;
+    ngx_str_t                                   err;
+    ngx_http_upstream_zmauth_peer_data_t       *zmp;
+    void (*connect) (ngx_http_request_t *, ngx_http_upstream_t *);
+} ngx_http_upstream_zmauth_ctx_t;
+
+ngx_int_t ngx_http_upstream_init_zmauth(ngx_conf_t *cf,
+        ngx_http_upstream_srv_conf_t *us);
+
+ngx_int_t ngx_http_upstream_init_admin_zmauth(ngx_conf_t *cf,
+        ngx_http_upstream_srv_conf_t *us);
+
+#endif
+
diff --git a/src/http/modules/ngx_http_zm_sso_module.c b/src/http/modules/ngx_http_zm_sso_module.c
new file mode 100644
index 000000000..52bd62bc8
--- /dev/null
+++ b/src/http/modules/ngx_http_zm_sso_module.c
@@ -0,0 +1,552 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <ngx_http_zm_sso_module.h>
+#include <ngx_zm_lookup.h>
+
+ngx_module_t ngx_http_zm_sso_module;
+
+static ngx_conf_enum_t  ngx_http_zm_sso_types[] = {
+    { ngx_string("certauth"), NGX_ZM_SSO_CERTAUTH },
+    { ngx_string("certauth_admin"), NGX_ZM_SSO_CERTAUTH_ADMIN},
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_int_t ngx_http_zm_sso_handler(ngx_http_request_t *r);
+static char * ngx_http_zm_sso(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+static char * ngx_http_zm_sso_redirect_url(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+static void * ngx_http_zm_sso_create_loc_conf(ngx_conf_t *cf);
+static char * ngx_http_zm_sso_merge_loc_conf(ngx_conf_t *cf,
+        void *parent, void *child);
+static ngx_int_t ngx_http_zm_sso_cert_auth(ngx_http_request_t *r,
+        ngx_zm_lookup_work_t * w);
+static ngx_int_t ngx_http_zm_sso_set_auth_token_and_redirect(
+        ngx_http_request_t *r, ngx_str_t token, ngx_flag_t isAdmin);
+static void ngx_http_zm_sso_finalize_request(ngx_http_request_t *r,
+        ngx_int_t rc);
+static void ngx_http_zm_sso_cleanup (void *data);
+
+static void ngx_http_zm_sso_cert_auth_on_success (ngx_zm_lookup_work_t *w);
+static void ngx_http_zm_sso_cert_auth_on_failure (ngx_zm_lookup_work_t *w);
+
+
+static void ngx_http_zm_sso_rd_check_broken_connection(ngx_http_request_t *r);
+static void ngx_http_zm_sso_wr_check_broken_connection(ngx_http_request_t *r);
+static void ngx_http_zm_sso_check_broken_connection(ngx_http_request_t *r, ngx_event_t *ev);
+
+static ngx_command_t  ngx_http_zm_sso_commands[] = {
+
+    { ngx_string("zm_sso"),
+      NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_zm_sso,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_zm_sso_loc_conf_t, type),
+      &ngx_http_zm_sso_types },
+
+    { ngx_string("zm_sso_redirect_url"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_zm_sso_redirect_url,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("zm_sso_redirect_schema"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_zm_sso_loc_conf_t, redirect_schema),
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_http_module_t  ngx_http_zm_sso_module_ctx = {
+    NULL,                             /* pre configuration */
+    NULL,                             /* post configuration */
+
+    NULL,                             /* create main configuration */
+    NULL,                             /* init main configuration */
+
+    NULL,                             /* create server configuration */
+    NULL,                             /* merge server configuration */
+
+    ngx_http_zm_sso_create_loc_conf,  /* create location configuration */
+    ngx_http_zm_sso_merge_loc_conf    /* merge location configuration */
+};
+
+
+ngx_module_t  ngx_http_zm_sso_module = {
+    NGX_MODULE_V1,
+    &ngx_http_zm_sso_module_ctx,           /* module context */
+    ngx_http_zm_sso_commands,              /* module directives */
+    NGX_HTTP_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+static void *
+ngx_http_zm_sso_create_loc_conf(ngx_conf_t *cf)
+{
+    ngx_http_zm_sso_loc_conf_t  *conf;
+
+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_zm_sso_loc_conf_t));
+    if (conf == NULL) {
+        return NULL;
+    }
+
+    conf->redirect_url = ngx_pcalloc(cf->pool, sizeof(ngx_url_t));
+    if (conf->redirect_url == NULL) {
+        return NULL;
+    }
+
+    ngx_str_null(&conf->redirect_schema);
+
+    conf->type = NGX_CONF_UNSET_UINT;
+    conf->host_index = NGX_CONF_UNSET;
+    conf->ssl_client_s_dn_index = NGX_CONF_UNSET;
+    conf->ssl_client_verify_index = NGX_CONF_UNSET;
+
+    return conf;
+}
+
+static char *
+ngx_http_zm_sso_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_http_zm_sso_loc_conf_t *prev = parent;
+    ngx_http_zm_sso_loc_conf_t *conf = child;
+    ngx_str_t         host_key;
+    ngx_str_t         ssl_client_verify_key;
+    ngx_str_t         ssl_client_s_dn_key;
+
+    ngx_conf_merge_uint_value(conf->type, prev->type, NGX_ZM_SSO_CERTAUTH);
+
+    ngx_conf_merge_str_value(conf->redirect_url->url,
+                              prev->redirect_url->url, "443");
+
+    ngx_conf_merge_str_value(conf->redirect_schema,
+                              prev->redirect_schema, "https");
+
+    conf->redirect_url->no_resolve = 1;
+    conf->redirect_url->listen = 1; /* with this option, the ngx_parse_url accepts
+                                       only port case */
+    if (ngx_parse_url(cf->pool, conf->redirect_url) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (conf->host_index == NGX_CONF_UNSET) {
+        ngx_str_set(&host_key, "host");
+        conf->host_index = ngx_http_get_variable_index(cf, &host_key);
+    }
+
+    if (conf->ssl_client_verify_index == NGX_CONF_UNSET) {
+        ngx_str_set(&ssl_client_verify_key, "ssl_client_verify");
+        conf->ssl_client_verify_index = ngx_http_get_variable_index(cf,
+                &ssl_client_verify_key);
+    }
+
+    if (conf->ssl_client_s_dn_index == NGX_CONF_UNSET) {
+        ngx_str_set(&ssl_client_s_dn_key, "ssl_client_s_dn");
+        conf->ssl_client_s_dn_index = ngx_http_get_variable_index(cf,
+                &ssl_client_s_dn_key);
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_http_zm_sso(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_core_loc_conf_t   *clcf;
+
+    ngx_conf_set_enum_slot(cf, cmd, conf);
+
+    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
+
+    clcf->handler = ngx_http_zm_sso_handler;
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_http_zm_sso_redirect_url(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t        *value;
+
+    value = cf->args->elts;
+
+    ngx_http_zm_sso_loc_conf_t * zlcf = conf;
+
+    zlcf->redirect_url->url = value[1];
+
+    return NGX_CONF_OK;
+}
+
+static ngx_int_t
+ngx_http_zm_sso_handler(ngx_http_request_t *r)
+{
+    ngx_http_zm_sso_loc_conf_t   *zlcf;
+    ngx_http_ssl_srv_conf_t      *hscf;
+    ngx_zm_lookup_work_t         *w;
+
+    zlcf = ngx_http_get_module_loc_conf(r, ngx_http_zm_sso_module);
+    hscf = ngx_http_get_module_srv_conf(r, ngx_http_ssl_module);
+
+    if (hscf->verify == 0) {
+        /* ssl_verify_client is off */
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
+                "client has to enable client cert auth when accessing this url. "
+                "please set this server block's \"ssl_verify_client\" to \"on\" "
+                "or \"optional\"");
+        return NGX_HTTP_FORBIDDEN;
+    }
+
+    w = ngx_pcalloc (r->pool, sizeof(ngx_zm_lookup_work_t));
+    if (w == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    w->data = r;
+    w->pool = r->pool;
+    w->log = r->connection->log;
+
+    if (zlcf->type == NGX_ZM_SSO_CERTAUTH || zlcf->type == NGX_ZM_SSO_CERTAUTH_ADMIN) {
+        return ngx_http_zm_sso_cert_auth(r, w);
+
+    } else {
+        /* Should never execute here */
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+}
+
+static ngx_int_t
+ngx_http_zm_sso_redirect (ngx_http_request_t *r)
+{
+    ngx_http_zm_sso_loc_conf_t   *zlcf;
+    ngx_http_variable_value_t    *host_var;
+    ngx_str_t                     host_value;
+
+    zlcf = ngx_http_get_module_loc_conf(r, ngx_http_zm_sso_module);
+    ngx_table_elt_t * location = ngx_list_push(&r->headers_out.headers);
+    if (location == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    ngx_str_set(&location->key, "Location");
+
+    //redirect to https://<redirect_url>/?ignoreLoginURL=1
+    if (zlcf->redirect_url->wildcard) {
+        //url contain only port, just use $host
+        host_var =
+                ngx_http_get_indexed_variable(r, zlcf->host_index);
+        host_value.data = host_var->data;
+        host_value.len = host_var->len;
+
+        location->value.len = zlcf->redirect_schema.len +
+                              3 +     /* for "://" */
+                              host_var->len +
+                              1 +     /* for ":" */
+                              zlcf->redirect_url->port_text.len +
+                              sizeof ("/?ignoreLoginURL=1") - 1;
+
+        location->value.data = ngx_palloc(r->pool, location->value.len);
+        ngx_sprintf(location->value.data, "%V://%V:%V/?ignoreLoginURL=1",
+                &zlcf->redirect_schema,
+                &host_value,
+                &zlcf->redirect_url->port_text);
+
+    } else {
+        //use schema and redirect url
+        location->value.len = zlcf->redirect_schema.len +
+                              3 + /* for "://" */
+                              zlcf->redirect_url->url.len +
+                              sizeof ("/?ignoreLoginURL=1") - 1;
+
+        location->value.data = ngx_palloc(r->pool, location->value.len);
+        ngx_sprintf(location->value.data, "%V://%V/?ignoreLoginURL=1",
+                        &zlcf->redirect_schema,
+                        &zlcf->redirect_url->url);
+    }
+    location->hash = 1;
+
+    return NGX_HTTP_MOVED_TEMPORARILY;
+}
+
+static ngx_int_t
+ngx_http_zm_sso_set_auth_token_and_redirect (ngx_http_request_t *r,
+        ngx_str_t token, ngx_flag_t isAdmin)
+{
+    ngx_table_elt_t * token_cookie;
+
+    token_cookie = ngx_list_push(&r->headers_out.headers);
+    token_cookie->hash = 1;
+    ngx_str_set(&token_cookie->key, "Set-Cookie");
+
+    if (!isAdmin) {
+        token_cookie->value.len = sizeof("ZM_AUTH_TOKEN=") - 1 + token.len
+                + sizeof(";Path=/") - 1;
+        token_cookie->value.data = ngx_palloc(r->pool, token_cookie->value.len);
+        ngx_sprintf(token_cookie->value.data, "ZM_AUTH_TOKEN=%V;Path=/", &token);
+    } else {
+        /* admin token */
+        token_cookie->value.len = sizeof("ZM_ADMIN_AUTH_TOKEN=") - 1
+                + token.len + sizeof(";Path=/") - 1;
+        token_cookie->value.data = ngx_palloc(r->pool, token_cookie->value.len);
+        ngx_sprintf(token_cookie->value.data, "ZM_ADMIN_AUTH_TOKEN=%V;Path=/", &token);
+    }
+    return ngx_http_zm_sso_redirect(r);
+}
+
+static ngx_int_t
+ngx_http_zm_sso_cert_auth(ngx_http_request_t *r, ngx_zm_lookup_work_t *w)
+{
+
+    ngx_http_variable_value_t    *ssl_client_verify_var;
+    ngx_http_variable_value_t    *ssl_client_s_dn_var;
+    ngx_str_t                     ssl_client_verify_value;
+    ngx_str_t                     ssl_client_s_dn_value;
+    ngx_http_zm_sso_loc_conf_t   *zlcf;
+
+    zlcf = ngx_http_get_module_loc_conf(r, ngx_http_zm_sso_module);
+    w->protocol = ZM_PROTO_HTTP; /* it doesn't matter which protocol is used, for cert auth we don't want route */
+    if (zlcf->type == NGX_ZM_SSO_CERTAUTH) {
+        w->isAdmin = 0;
+    } else if (zlcf->type == NGX_ZM_SSO_CERTAUTH_ADMIN) {
+        w->isAdmin = 1;
+    } else {
+        return NGX_HTTP_FORBIDDEN;
+    }
+
+    ssl_client_verify_var = ngx_http_get_indexed_variable(r,
+            zlcf->ssl_client_verify_index);
+
+    if (!ssl_client_verify_var->valid) {
+        ngx_log_error (NGX_LOG_ERR, r->connection->log, 0,
+                "nginx ssl module return invalid result for "
+                "client cert auth");
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    ssl_client_verify_value.data = ssl_client_verify_var->data;
+    ssl_client_verify_value.len = ssl_client_verify_var->len;
+
+    if (ngx_strncasecmp(ssl_client_verify_value.data, (u_char*)"SUCCESS",
+                sizeof ("SUCCESS") - 1) == 0) {
+        /* get client cert subject dn */
+        ssl_client_s_dn_var = ngx_http_get_indexed_variable(r,
+                zlcf->ssl_client_s_dn_index);
+        if (!ssl_client_s_dn_var->valid) {
+            ngx_log_error (NGX_LOG_ERR, r->connection->log, 0,
+                    "nginx ssl module return invalid subject DN for "
+                    "client cert auth");
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        ssl_client_s_dn_value.data = ssl_client_s_dn_var->data;
+        ssl_client_s_dn_value.len = ssl_client_s_dn_var->len;
+        w->auth_method = ZM_AUTHMETH_CERTAUTH;
+        w->username = ssl_client_s_dn_value;
+        if (r->headers_in.host != NULL) {
+            w->virtual_host = r->headers_in.host->value;
+        }
+        w->login_attempts = 0; /* HTTP is always 0 */
+        w->connection = r->connection;
+        w->on_success = ngx_http_zm_sso_cert_auth_on_success;
+        w->on_failure = ngx_http_zm_sso_cert_auth_on_failure;
+
+        ngx_http_cleanup_t * cln = ngx_http_cleanup_add(r, 0);
+        cln->handler = ngx_http_zm_sso_cleanup;
+        cln->data = w;
+        r->main->count++;
+        r->read_event_handler = ngx_http_zm_sso_rd_check_broken_connection;
+        r->write_event_handler = ngx_http_zm_sso_wr_check_broken_connection;
+        ngx_zm_lookup(w);
+        return NGX_DONE;
+
+    } else if (ngx_strncasecmp(ssl_client_verify_value.data, (u_char*)"NONE",
+                sizeof ("NONE") - 1) == 0) {
+        /* if ssl_verify_client is set to be "on", and the the verification fails,
+         * nginx will return SSL handshake error; in this case, the code here will
+         * never be executed. Only when ssl_verify_client is "optional", and client
+         * doesn't send the cert, here will be executed. That is, directly redirect.
+         */
+        ngx_log_error (NGX_LOG_INFO, r->connection->log, 0,
+                        "doesn't provide client cert, redirect to common https login page "
+                        "to do the username/password login");
+        return ngx_http_zm_sso_redirect (r);
+    } else {
+        ngx_log_error (NGX_LOG_ERR, r->connection->log, 0,
+                "unexpected ssl client cert verification result %V",
+                &ssl_client_verify_value);
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+}
+
+static void
+ngx_http_zm_sso_cert_auth_on_success(ngx_zm_lookup_work_t *w)
+{
+    ngx_int_t rc;
+    ngx_http_request_t *r;
+    r = w->data;
+    ngx_log_error (NGX_LOG_INFO, w->log, 0,
+                    "login succeed for subject dn %V after client cert auth,"
+                    " redirect to common https url", &w->username);
+    rc = ngx_http_zm_sso_set_auth_token_and_redirect (r, w->zm_auth_token,
+            w->isAdmin);
+    ngx_http_zm_sso_finalize_request(r, rc);
+}
+
+static void
+ngx_http_zm_sso_cert_auth_on_failure(ngx_zm_lookup_work_t *w)
+{
+    ngx_http_request_t        *r;
+    ngx_http_ssl_srv_conf_t   *hscf;
+    ngx_int_t                  rc;
+    r = w->data;
+    hscf = ngx_http_get_module_srv_conf(r, ngx_http_ssl_module);
+    if (w->result == ZM_LOOKUP_LOGIN_FAILED) {
+        ngx_log_error (NGX_LOG_WARN, w->log, 0,
+                "login failed for subject dn %V during client cert auth"
+                ", reason:%V", &w->username, &w->err);
+        if (hscf->verify == 1) {
+            // verify client cert mode is on
+            ngx_http_zm_sso_finalize_request(r, NGX_HTTP_FORBIDDEN);
+        } else {
+            // verify client cert mode is optional
+            rc = ngx_http_zm_sso_redirect (r);
+            ngx_http_zm_sso_finalize_request(r, rc);
+        }
+
+    } else {
+        ngx_http_zm_sso_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+    }
+}
+
+static void
+ngx_http_zm_sso_finalize_request(ngx_http_request_t *r, ngx_int_t rc)
+{
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "finalize http zm sso request: %i", rc);
+
+    if (rc == NGX_DECLINED) {
+        return;
+    }
+
+    r->connection->log->action = "sending to client";
+
+    ngx_http_finalize_request(r, rc);
+}
+
+static void ngx_http_zm_sso_cleanup (void *data)
+{
+    ngx_zm_lookup_work_t * w;
+    w = data;
+    ngx_zm_lookup_finalize (w);
+}
+
+static void
+ngx_http_zm_sso_rd_check_broken_connection(ngx_http_request_t *r)
+{
+    ngx_http_zm_sso_check_broken_connection(r, r->connection->read);
+}
+
+
+static void
+ngx_http_zm_sso_wr_check_broken_connection(ngx_http_request_t *r)
+{
+    ngx_http_zm_sso_check_broken_connection(r, r->connection->write);
+}
+
+static void
+ngx_http_zm_sso_check_broken_connection(ngx_http_request_t * r, ngx_event_t *ev)
+{
+    ngx_connection_t            *c;
+    int                          n;
+    char                         buf[1];
+    ngx_err_t                    err;
+    ngx_int_t                    event;
+
+    c = ev->data;
+    r = c->data;
+
+    if (c->error) {
+        if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {
+           event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
+           if (ngx_del_event(ev, event, 0) != NGX_OK) {
+               ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+               return;
+           }
+       }
+       ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);
+       return;
+    }
+
+    n = recv(c->fd, buf, 1, MSG_PEEK);
+
+    err = ngx_socket_errno;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ev->log, err,
+                  "zm sso recv(): %d", n);
+
+    if (ev->write && (n >= 0 || err == NGX_EAGAIN)) {
+        return;
+    }
+
+    if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {
+
+       event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
+
+       if (ngx_del_event(ev, event, 0) != NGX_OK) {
+           ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+           return;
+       }
+   }
+
+   if (n > 0) {
+       return;
+   }
+
+   if (n == -1) {
+       if (err == NGX_EAGAIN) {
+           return;
+       }
+
+       ev->error = 1;
+
+   } else { /* n == 0 */
+       err = 0;
+   }
+
+   ev->eof = 1;
+   c->error = 1;
+
+   ngx_log_error(NGX_LOG_INFO, ev->log, err,
+                 "client closed prematurely connection during sso authentication");
+
+   ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);
+}
diff --git a/src/http/modules/ngx_http_zm_sso_module.h b/src/http/modules/ngx_http_zm_sso_module.h
new file mode 100644
index 000000000..a7faa0f3f
--- /dev/null
+++ b/src/http/modules/ngx_http_zm_sso_module.h
@@ -0,0 +1,48 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#ifndef _NGX_HTTP_ZM_SSO_INCLUDED_
+#define _NGX_HTTP_ZM_SSO_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+typedef struct {
+    ngx_uint_t  type;                     /* the authentication type */
+    ngx_url_t  *redirect_url;             /* if only port is provided, just redirect to $host:port */
+    ngx_str_t   redirect_schema;          /* https or http, https is the default */
+    ngx_int_t   host_index;               /* the index of $host */
+    ngx_int_t   ssl_client_verify_index;  /* the index of $ssl_client_verify */
+    ngx_int_t   ssl_client_s_dn_index;    /* the index of $ssl_client_s_dn */
+} ngx_http_zm_sso_loc_conf_t;
+
+typedef struct {
+    ngx_pool_t            *pool;
+    ngx_log_t             *log;
+    ngx_http_request_t    *r;
+    ngx_flag_t             isAdmin;
+    ngx_str_t              zm_auth_token;
+} ngx_http_zm_sso_ctx_t;
+
+/* SSO type */
+#define NGX_ZM_SSO_CERTAUTH       1           /* client cert authentication */
+#define NGX_ZM_SSO_CERTAUTH_ADMIN 2           /* client cert authentication for admin console */
+
+
+extern ngx_module_t ngx_http_zm_sso_module;
+
+#endif
diff --git a/src/http/ngx_http_parse.c b/src/http/ngx_http_parse.c
index cfc42f9dd..6c1c42255 100644
--- a/src/http/ngx_http_parse.c
+++ b/src/http/ngx_http_parse.c
@@ -538,6 +538,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)
                 return NGX_HTTP_PARSE_INVALID_REQUEST;
             default:
                 state = sw_check_uri;
+		p--;
                 break;
             }
             break;
@@ -590,6 +591,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)
             case '?':
                 r->args_start = p + 1;
                 state = sw_uri;
+		p--;
                 break;
             case '#':
                 r->complex_uri = 1;
diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c
index eb53996b1..8149e26f9 100644
--- a/src/http/ngx_http_request.c
+++ b/src/http/ngx_http_request.c
@@ -3708,6 +3708,11 @@ ngx_http_log_error(ngx_log_t *log, u_char *buf, size_t len)
     u_char              *p;
     ngx_http_request_t  *r;
     ngx_http_log_ctx_t  *ctx;
+    ngx_uint_t          remote_port=0;
+    struct sockaddr_in         *sin;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6        *sin6;
+#endif
 
     if (log->action) {
         p = ngx_snprintf(buf, len, " while %s", log->action);
@@ -3717,15 +3722,32 @@ ngx_http_log_error(ngx_log_t *log, u_char *buf, size_t len)
 
     ctx = log->data;
 
-    p = ngx_snprintf(buf, len, ", client: %V", &ctx->connection->addr_text);
-    len -= p - buf;
-
     r = ctx->request;
-
     if (r) {
+        switch (r->connection->sockaddr->sa_family) {
+    #if (NGX_HAVE_INET6)
+        case AF_INET6:
+            sin6 = (struct sockaddr_in6 *) r->connection->sockaddr;
+            remote_port = ntohs(sin6->sin6_port);
+            break;
+    #endif
+    
+        default: /* AF_INET */
+            sin = (struct sockaddr_in *) r->connection->sockaddr;
+            remote_port = ntohs(sin->sin_port);
+            break;
+        }
+    
+        if (remote_port && remote_port < 65536) {
+          p = ngx_snprintf(buf, len, ", client: %V:%ui", &ctx->connection->addr_text,remote_port);
+        } else {
+          p = ngx_snprintf(buf, len, ", client: %V", &ctx->connection->addr_text);
+        }
+        len -= p - buf;
+    
         return r->log_handler(r, ctx->current_request, p, len);
-
     } else {
+        p = ngx_snprintf(buf, len, ", client: %V", &ctx->connection->addr_text);
         p = ngx_snprintf(p, len, ", server: %V",
                          &ctx->connection->listening->addr_text);
     }
diff --git a/src/http/ngx_http_upstream.c b/src/http/ngx_http_upstream.c
index 89e1319f9..de2cfc96f 100644
--- a/src/http/ngx_http_upstream.c
+++ b/src/http/ngx_http_upstream.c
@@ -8,6 +8,7 @@
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_http.h>
+#include <ngx_zm_lookup.h>
 
 
 #if (NGX_HTTP_CACHE)
@@ -551,6 +552,7 @@ ngx_http_upstream_init_request(ngx_http_request_t *r)
 {
     ngx_str_t                      *host;
     ngx_uint_t                      i;
+    ngx_int_t                       rc;
     ngx_resolver_ctx_t             *ctx, temp;
     ngx_http_cleanup_t             *cln;
     ngx_http_upstream_t            *u;
@@ -789,7 +791,11 @@ found:
     u->ssl_name = uscf->host;
 #endif
 
-    if (uscf->peer.init(r, uscf) != NGX_OK) {
+    rc = uscf->peer.init(r, uscf);
+    if (rc != NGX_OK) {
+
+        if (rc == NGX_AGAIN) return; /* added by zimbra to support async peer init */
+
         ngx_http_upstream_finalize_request(r, u,
                                            NGX_HTTP_INTERNAL_SERVER_ERROR);
         return;
@@ -1675,6 +1681,8 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,
 
     c->sendfile = 0;
     u->output.sendfile = 0;
+    ngx_http_upstream_rr_peer_data_t *rrp = (ngx_http_upstream_rr_peer_data_t *)(u->peer.data);
+
 
     if (u->conf->ssl_server_name || u->conf->ssl_verify) {
         if (ngx_http_upstream_ssl_name(r, u, c) != NGX_OK) {
@@ -1684,7 +1692,7 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,
         }
     }
 
-    if (u->conf->ssl_session_reuse) {
+    if (u->conf->ssl_session_reuse && rrp->current != NGX_INVALID_ARRAY_INDEX) {
         c->ssl->save_session = ngx_http_upstream_ssl_save_session;
 
         if (u->peer.set_session(&u->peer, u->peer.data) != NGX_OK) {
@@ -1752,6 +1760,8 @@ ngx_http_upstream_ssl_handshake(ngx_http_request_t *r, ngx_http_upstream_t *u,
     long  rc;
 
     if (c->ssl->handshaked) {
+        ngx_http_upstream_rr_peer_data_t *rrp = (ngx_http_upstream_rr_peer_data_t *)(u->peer.data);
+
 
         if (u->conf->ssl_verify) {
             rc = SSL_get_verify_result(c->ssl->connection);
@@ -4155,6 +4165,7 @@ ngx_http_upstream_next(ngx_http_request_t *r, ngx_http_upstream_t *u,
 {
     ngx_msec_t  timeout;
     ngx_uint_t  status, state;
+    ngx_zm_lookup_conf_t  *zlcf;
 
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "http next upstream, %xi", ft_type);
@@ -4230,55 +4241,62 @@ ngx_http_upstream_next(ngx_http_request_t *r, ngx_http_upstream_t *u,
         return;
     }
 
-    u->state->status = status;
+    if (status) {
+        u->state->status = status;
+        zlcf = (ngx_zm_lookup_conf_t *)
+                ngx_get_conf (ngx_cycle->conf_ctx, ngx_zm_lookup_module);
 
-    timeout = u->conf->next_upstream_timeout;
+        timeout = u->conf->next_upstream_timeout;
 
-    if (u->request_sent
-        && (r->method & (NGX_HTTP_POST|NGX_HTTP_LOCK|NGX_HTTP_PATCH)))
-    {
-        ft_type |= NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT;
-    }
+        if (u->request_sent
+            && (r->method & (NGX_HTTP_POST|NGX_HTTP_LOCK|NGX_HTTP_PATCH)))
+        {
+            ft_type |= NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT;
+        }
 
-    if (u->peer.tries == 0
-        || ((u->conf->next_upstream & ft_type) != ft_type)
-        || (u->request_sent && r->request_body_no_buffering)
-        || (timeout && ngx_current_msec - u->peer.start_time >= timeout))
-    {
-#if (NGX_HTTP_CACHE)
+        zlcf = (ngx_zm_lookup_conf_t *)
+                ngx_get_conf (ngx_cycle->conf_ctx, ngx_zm_lookup_module);
 
-        if (u->cache_status == NGX_HTTP_CACHE_EXPIRED
-            && ((u->conf->cache_use_stale & ft_type) || r->cache->stale_error))
+        if (u->peer.tries == 0
+            || ((u->conf->next_upstream & ft_type) != ft_type)
+            || (u->request_sent && r->request_body_no_buffering)
+            || (timeout && ngx_current_msec - u->peer.start_time >= timeout)
+            || (ngx_strncasecmp(r->uri.data, zlcf->url.data, zlcf->url.len) == 0))
         {
-            ngx_int_t  rc;
+#if (NGX_HTTP_CACHE)
 
-            rc = u->reinit_request(r);
+            if (u->cache_status == NGX_HTTP_CACHE_EXPIRED
+                && ((u->conf->cache_use_stale & ft_type) || r->cache->stale_error))
+            {
+                ngx_int_t  rc;
 
-            if (rc != NGX_OK) {
-                ngx_http_upstream_finalize_request(r, u, rc);
-                return;
-            }
+                rc = u->reinit_request(r);
 
-            u->cache_status = NGX_HTTP_CACHE_STALE;
-            rc = ngx_http_upstream_cache_send(r, u);
+                if (rc != NGX_OK) {
+                    ngx_http_upstream_finalize_request(r, u, rc);
+                    return;
+                }
 
-            if (rc == NGX_DONE) {
-                return;
-            }
+                u->cache_status = NGX_HTTP_CACHE_STALE;
+                rc = ngx_http_upstream_cache_send(r, u);
 
-            if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) {
-                rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+                if (rc == NGX_DONE) {
+                    return;
+                }
+
+                if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) {
+                    rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+                }
+
+                ngx_http_upstream_finalize_request(r, u, rc);
+                return;
             }
+#endif
 
-            ngx_http_upstream_finalize_request(r, u, rc);
+            ngx_http_upstream_finalize_request(r, u, status);
             return;
         }
-#endif
-
-        ngx_http_upstream_finalize_request(r, u, status);
-        return;
     }
-
     if (u->peer.connection) {
         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                        "close http upstream connection: %d",
@@ -5826,6 +5844,9 @@ ngx_http_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)
         return NGX_CONF_ERROR;
     }
 
+    /* add by zimbra to support async upstream peer choose */
+    uscf->connect = ngx_http_upstream_connect;
+
     return rv;
 }
 
diff --git a/src/http/ngx_http_upstream.h b/src/http/ngx_http_upstream.h
index 6079d7236..5cbfbc82b 100644
--- a/src/http/ngx_http_upstream.h
+++ b/src/http/ngx_http_upstream.h
@@ -73,6 +73,9 @@ typedef struct {
 typedef struct {
     ngx_hash_t                       headers_in_hash;
     ngx_array_t                      upstreams;
+
+    // added by zimbra to support async upstream peer init
+    void (* connect)(ngx_http_request_t *r, ngx_http_upstream_t *u);
                                              /* ngx_http_upstream_srv_conf_t */
 } ngx_http_upstream_main_conf_t;
 
@@ -134,6 +137,9 @@ struct ngx_http_upstream_srv_conf_s {
 #if (NGX_HTTP_UPSTREAM_ZONE)
     ngx_shm_zone_t                  *shm_zone;
 #endif
+
+    // added by zimbra to support async upstream peer init
+    void (* connect)(ngx_http_request_t *r, ngx_http_upstream_t *u);
 };
 
 
@@ -433,5 +439,4 @@ extern ngx_module_t        ngx_http_upstream_module;
 extern ngx_conf_bitmask_t  ngx_http_upstream_cache_method_mask[];
 extern ngx_conf_bitmask_t  ngx_http_upstream_ignore_headers_masks[];
 
-
 #endif /* _NGX_HTTP_UPSTREAM_H_INCLUDED_ */
diff --git a/src/http/ngx_http_upstream_round_robin.c b/src/http/ngx_http_upstream_round_robin.c
index 8e7b4ea8b..fe0243d86 100644
--- a/src/http/ngx_http_upstream_round_robin.c
+++ b/src/http/ngx_http_upstream_round_robin.c
@@ -405,7 +405,7 @@ ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,
     r->upstream->peer.free = ngx_http_upstream_free_round_robin_peer;
     r->upstream->peer.tries = ngx_http_upstream_tries(rrp->peers);
 #if (NGX_HTTP_SSL)
-    r->upstream->peer.set_session = ngx_http_upstream_empty_set_session;
+   r->upstream->peer.set_session = ngx_http_upstream_empty_set_session;
     r->upstream->peer.save_session = ngx_http_upstream_empty_save_session;
 #endif
 
diff --git a/src/mail/ngx_mail.h b/src/mail/ngx_mail.h
index d904f25f1..71c03cc7a 100644
--- a/src/mail/ngx_mail.h
+++ b/src/mail/ngx_mail.h
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #ifndef _NGX_MAIL_H_INCLUDED_
 #define _NGX_MAIL_H_INCLUDED_
@@ -18,7 +22,7 @@
 #include <ngx_mail_ssl_module.h>
 #endif
 
-
+#include <sasl/sasl.h>
 
 typedef struct {
     void                  **main_conf;
@@ -115,6 +119,16 @@ typedef struct {
 
     ngx_str_t               server_name;
 
+    ngx_str_t               master_auth_username;
+    ngx_str_t               master_auth_password;
+
+    ngx_str_t               sasl_app_name;
+    ngx_str_t               sasl_service_name;
+    ngx_flag_t              sasl_host_from_ip;
+
+    ngx_msec_t              auth_wait_intvl;
+
+    ngx_str_t               default_realm;
     u_char                 *file_name;
     ngx_uint_t              line;
 
@@ -130,12 +144,15 @@ typedef struct {
 
 typedef enum {
     ngx_pop3_start = 0,
+    ngx_pop3_xoip,
     ngx_pop3_user,
     ngx_pop3_passwd,
     ngx_pop3_auth_login_username,
     ngx_pop3_auth_login_password,
     ngx_pop3_auth_plain,
+    ngx_pop3_auth_plain_response,
     ngx_pop3_auth_cram_md5,
+    ngx_pop3_auth_gssapi,
     ngx_pop3_auth_external
 } ngx_pop3_state_e;
 
@@ -145,8 +162,11 @@ typedef enum {
     ngx_imap_auth_login_username,
     ngx_imap_auth_login_password,
     ngx_imap_auth_plain,
+    ngx_imap_auth_plain_ir,
     ngx_imap_auth_cram_md5,
     ngx_imap_auth_external,
+    ngx_imap_auth_gssapi,
+    ngx_imap_id,
     ngx_imap_login,
     ngx_imap_user,
     ngx_imap_passwd
@@ -158,9 +178,11 @@ typedef enum {
     ngx_smtp_auth_login_username,
     ngx_smtp_auth_login_password,
     ngx_smtp_auth_plain,
+    ngx_smtp_auth_gssapi,
     ngx_smtp_auth_cram_md5,
     ngx_smtp_auth_external,
     ngx_smtp_helo,
+    ngx_smtp_noxclient,
     ngx_smtp_helo_xclient,
     ngx_smtp_helo_from,
     ngx_smtp_xclient,
@@ -170,12 +192,27 @@ typedef enum {
     ngx_smtp_to
 } ngx_smtp_state_e;
 
+/* sasl auth mechanisms */
+typedef enum {
+    ngx_auth_unknown = 0,
+    ngx_auth_plain,
+    ngx_auth_gssapi,
+} ngx_auth_e;
 
 typedef struct {
     ngx_peer_connection_t   upstream;
     ngx_buf_t              *buffer;
 } ngx_mail_proxy_ctx_t;
 
+typedef void (*ngx_mail_cleanup_pt)(void *data);
+
+typedef struct ngx_mail_cleanup_s  ngx_mail_cleanup_t;
+
+struct ngx_mail_cleanup_s {
+    ngx_mail_cleanup_pt               handler;
+    void                             *data;
+    ngx_mail_cleanup_t               *next;
+};
 
 typedef struct {
     uint32_t                signature;         /* "MAIL" */
@@ -195,6 +232,8 @@ typedef struct {
 
     ngx_uint_t              mail_state;
 
+    ngx_str_t               greetings[3];
+
     unsigned                protocol:3;
     unsigned                blocked:1;
     unsigned                quit:1;
@@ -203,11 +242,24 @@ typedef struct {
     unsigned                no_sync_literal:1;
     unsigned                starttls:1;
     unsigned                esmtp:1;
-    unsigned                auth_method:3;
+    unsigned                auth_method:4;
     unsigned                auth_wait:1;
-
-    ngx_str_t               login;
+    unsigned                sendquitmsg:1;
+    unsigned                vlogin:2; /* vlogin = 0 fqdn is not looked up;
+                                         vlogin = 1 fqdn has been looked up but not found;
+                                         vlogin = 2 fqdn has been looked up and assigned to "login"
+                                       */
+
+    ngx_str_t               login;  /* keep the original user input login */
+
+    ngx_str_t               qlogin; /* initially equal to 'login', then hold account name
+                                       after successful alias cache fetch or route lookup
+                                       this value is finally used to login the upstream
+                                       mail server*/
+    ngx_str_t               zlogin; /* the hack suffix "/wm" or "/ni" or "/tb" */
     ngx_str_t               passwd;
+    ngx_str_t               id_name;    /* the value of "name" field in IMAP ID */
+    ngx_str_t               id_version; /* the value of "version" field in IMAP ID */
 
     ngx_str_t               salt;
     ngx_str_t               tag;
@@ -234,11 +286,32 @@ typedef struct {
     u_char                 *arg_start;
     u_char                 *arg_end;
     ngx_uint_t              literal_len;
+    ngx_uint_t              eargs;          /* expected #args for command */
+
+    /* SASL */
+    ngx_flag_t              usedauth;
+    ngx_flag_t              qualifydauth;
+    ngx_str_t               dusr;
+    ngx_str_t               zusr;
+    ngx_str_t               dpasswd;
+    ngx_auth_e              authmech;
+    ngx_flag_t              saslfr;
+    sasl_conn_t            *saslconn;
+    ngx_str_t               authid;         /* SASL authenticating user */
+
+    /* memcache keys */
+    ngx_str_t               key_alias;
+    ngx_str_t               key_route;
+
+    /* clean up */
+    ngx_mail_cleanup_t    *cleanup;
+
 } ngx_mail_session_t;
 
 
 typedef struct {
     ngx_str_t              *client;
+    ngx_uint_t             client_port;
     ngx_mail_session_t     *session;
 } ngx_mail_log_ctx_t;
 
@@ -265,10 +338,9 @@ typedef struct {
 #define NGX_IMAP_CAPABILITY    3
 #define NGX_IMAP_NOOP          4
 #define NGX_IMAP_STARTTLS      5
-
-#define NGX_IMAP_NEXT          6
-
+#define NGX_IMAP_ID            6
 #define NGX_IMAP_AUTHENTICATE  7
+#define NGX_IMAP_NEXT          8
 
 
 #define NGX_SMTP_HELO          1
@@ -293,18 +365,29 @@ typedef struct {
 #define NGX_MAIL_AUTH_CRAM_MD5          4
 #define NGX_MAIL_AUTH_EXTERNAL          5
 #define NGX_MAIL_AUTH_NONE              6
-
+/* zimbra extension definition */
+#define NGX_MAIL_AUTH_PASSWD            6
+#define NGX_MAIL_AUTH_PLAIN_IR          7
+#define NGX_MAIL_AUTH_GSSAPI            8
+#define NGX_MAIL_AUTH_GSSAPI_IR         9
 
 #define NGX_MAIL_AUTH_PLAIN_ENABLED     0x0002
 #define NGX_MAIL_AUTH_LOGIN_ENABLED     0x0004
 #define NGX_MAIL_AUTH_APOP_ENABLED      0x0008
 #define NGX_MAIL_AUTH_CRAM_MD5_ENABLED  0x0010
 #define NGX_MAIL_AUTH_EXTERNAL_ENABLED  0x0020
+#define NGX_MAIL_AUTH_GSSAPI_ENABLED    0x0020
 #define NGX_MAIL_AUTH_NONE_ENABLED      0x0040
 
+#define NGX_MAIL_PARSE_INVALID_COMMAND   20
+#define NGX_MAIL_PARSE_INVALID_AUTH_MECH 30
+#define NGX_MAIL_AUTH_ABORT              40
+#define NGX_MAIL_AUTH_ARGUMENT           50
+#define NGX_MAIL_AUTH_FAILED             60
+#define NGX_MAIL_LOGIN_FAILED            70
 
-#define NGX_MAIL_PARSE_INVALID_COMMAND  20
-
+#define NGX_MAIL_MAX_LOGIN_LEN           256
+#define NGX_MAIL_MAX_PASSWORD_LEN        1024
 
 typedef void (*ngx_mail_init_session_pt)(ngx_mail_session_t *s,
     ngx_connection_t *c);
@@ -326,6 +409,7 @@ struct ngx_mail_protocol_s {
     ngx_str_t                   internal_server_error;
     ngx_str_t                   cert_error;
     ngx_str_t                   no_cert;
+    ngx_str_t                   quit_msg;
 };
 
 
@@ -341,10 +425,10 @@ typedef struct {
 } ngx_mail_module_t;
 
 
-#define NGX_MAIL_MODULE         0x4C49414D     /* "MAIL" */
+#define NGX_MAIL_MODULE      0x4C49414D     /* "MAIL" */
 
-#define NGX_MAIL_MAIN_CONF      0x02000000
-#define NGX_MAIL_SRV_CONF       0x04000000
+#define NGX_MAIL_MAIN_CONF   0x02000000
+#define NGX_MAIL_SRV_CONF    0x04000000
 
 
 #define NGX_MAIL_MAIN_CONF_OFFSET  offsetof(ngx_mail_conf_ctx_t, main_conf)
@@ -387,13 +471,27 @@ ngx_int_t ngx_mail_auth_cram_md5_salt(ngx_mail_session_t *s,
 ngx_int_t ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c);
 ngx_int_t ngx_mail_auth_external(ngx_mail_session_t *s, ngx_connection_t *c,
     ngx_uint_t n);
+ngx_int_t ngx_mail_auth_gssapi(ngx_mail_session_t *s, ngx_connection_t *c, ngx_str_t * output);
 ngx_int_t ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c);
 
 void ngx_mail_send(ngx_event_t *wev);
 ngx_int_t ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c);
+void ngx_mail_set_imap_parse_state_start(ngx_mail_session_t * s);
+void ngx_mail_set_pop3_parse_state_start(ngx_mail_session_t * s);
+void ngx_mail_set_smtp_parse_state_start(ngx_mail_session_t * s);
+void ngx_mail_set_imap_parse_state_argument(ngx_mail_session_t * s);
+void ngx_mail_set_pop3_parse_state_argument(ngx_mail_session_t * s);
+void ngx_mail_set_smtp_parse_state_argument(ngx_mail_session_t * s);
+void ngx_mail_reset_parse_buffer(ngx_mail_session_t * s);
 void ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c);
+void ngx_mail_do_auth(ngx_mail_session_t *s, ngx_connection_t *c); /* Zimbra mail auth portal */
 void ngx_mail_close_connection(ngx_connection_t *c);
 void ngx_mail_session_internal_server_error(ngx_mail_session_t *s);
+void ngx_mail_end_session(ngx_mail_session_t *s);
+ngx_str_t ngx_mail_session_getquitmsg(ngx_mail_session_t *s);
+ngx_str_t ngx_mail_session_geterrmsg(ngx_mail_session_t *s);
+ngx_str_t ngx_mail_get_socket_local_addr_str (ngx_pool_t *pool, ngx_socket_t s);
+ngx_int_t ngx_mail_decode_auth_plain(ngx_mail_session_t *s, ngx_str_t *encoded);
 u_char *ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len);
 
 
@@ -404,7 +502,9 @@ char *ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
 void ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer);
 void ngx_mail_auth_http_init(ngx_mail_session_t *s);
 /**/
+ngx_mail_cleanup_t * ngx_mail_cleanup_add(ngx_mail_session_t * s, size_t size);
 
+ngx_flag_t ngx_mail_get_proxy_ssl(ngx_mail_session_t *s);
 
 extern ngx_uint_t    ngx_mail_max_module;
 extern ngx_module_t  ngx_mail_core_module;
diff --git a/src/mail/ngx_mail_auth_http_module.c b/src/mail/ngx_mail_auth_http_module.c
index 6b57358b4..ac7c8a10c 100644
--- a/src/mail/ngx_mail_auth_http_module.c
+++ b/src/mail/ngx_mail_auth_http_module.c
@@ -1446,6 +1446,7 @@ ngx_mail_auth_http_merge_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_uint_t        i;
     ngx_table_elt_t  *header;
 
+    /* we have zmauth
     if (conf->peer == NULL) {
         conf->peer = prev->peer;
         conf->host_header = prev->host_header;
@@ -1458,7 +1459,7 @@ ngx_mail_auth_http_merge_conf(ngx_conf_t *cf, void *parent, void *child)
 
             return NGX_CONF_ERROR;
         }
-    }
+    }*/
 
     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);
 
diff --git a/src/mail/ngx_mail_core_module.c b/src/mail/ngx_mail_core_module.c
index e16d70238..f1968d60f 100644
--- a/src/mail/ngx_mail_core_module.c
+++ b/src/mail/ngx_mail_core_module.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -85,6 +89,55 @@ static ngx_command_t  ngx_mail_core_commands[] = {
       offsetof(ngx_mail_core_srv_conf_t, resolver_timeout),
       NULL },
 
+    /*{ ngx_string("master_auth_username"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, master_auth_username),
+      NULL },
+
+    { ngx_string("master_auth_password"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, master_auth_password),
+      NULL },*/
+
+    { ngx_string("sasl_app_name"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, sasl_app_name),
+      NULL },
+
+    { ngx_string("sasl_service_name"),
+      NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, sasl_service_name),
+      NULL },
+
+    { ngx_string("zm_auth_wait"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, auth_wait_intvl),
+      NULL },
+
+    { ngx_string("default_realm"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, default_realm),
+      NULL },
+
+    { ngx_string("sasl_host_from_ip"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_core_srv_conf_t, sasl_host_from_ip),
+      NULL },
+
       ngx_null_command
 };
 
@@ -159,12 +212,13 @@ ngx_mail_core_create_srv_conf(ngx_conf_t *cf)
      *     cscf->protocol = NULL;
      *     cscf->error_log = NULL;
      */
-
+    cscf->protocol = NGX_CONF_UNSET_PTR;
     cscf->timeout = NGX_CONF_UNSET_MSEC;
     cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;
 
     cscf->resolver = NGX_CONF_UNSET_PTR;
-
+    cscf->auth_wait_intvl = NGX_CONF_UNSET_MSEC;
+    cscf->sasl_host_from_ip = NGX_CONF_UNSET;
     cscf->file_name = cf->conf_file->file.name.data;
     cscf->line = cf->conf_file->line;
 
@@ -182,6 +236,27 @@ ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,
                               30000);
 
+    ngx_conf_merge_str_value(
+        conf->sasl_app_name, prev->sasl_app_name, "nginx");
+
+    ngx_conf_merge_str_value(
+        conf->sasl_service_name, prev->sasl_service_name, "");
+/* TO BE HANDLED */
+    if (conf->sasl_service_name.len == 0) {
+        if (conf->protocol->type == NGX_MAIL_IMAP_PROTOCOL) {
+            conf->sasl_service_name.data = (u_char *)"imap";
+            conf->sasl_service_name.len = sizeof("imap") - 1;
+        } else if (conf->protocol->type == NGX_MAIL_POP3_PROTOCOL) {
+            conf->sasl_service_name.data = (u_char *)"pop";
+            conf->sasl_service_name.len = sizeof("pop") - 1;
+        } else if (conf->protocol->type == NGX_MAIL_SMTP_PROTOCOL) {
+            conf->sasl_service_name.data = (u_char *)"smtp";
+            conf->sasl_service_name.len = sizeof("smtp") - 1;
+        } else {
+            conf->sasl_service_name.data = (u_char *)"unknown";
+            conf->sasl_service_name.len = sizeof("unknown") - 1;
+        }
+    }
 
     ngx_conf_merge_str_value(conf->server_name, prev->server_name, "");
 
@@ -204,6 +279,16 @@ ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         }
     }
 
+    /*
+     * master_auth_username and master_auth_password is already set in ngx_zm_lookup module
+     *
+     * ngx_conf_merge_str_value(conf->master_auth_username, prev->master_auth_username, "");
+     * ngx_conf_merge_str_value(conf->master_auth_password, prev->master_auth_password, "");
+     */
+    ngx_conf_merge_msec_value (conf->auth_wait_intvl, prev->auth_wait_intvl, 10000);
+
+    ngx_conf_merge_str_value (conf->default_realm, prev->default_realm,"");
+    ngx_conf_merge_value (conf->sasl_host_from_ip, prev->sasl_host_from_ip, 0);
     ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);
 
     return NGX_CONF_OK;
@@ -676,3 +761,34 @@ ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 
     return NGX_CONF_OK;
 }
+
+ngx_mail_cleanup_t *
+ngx_mail_cleanup_add(ngx_mail_session_t *s, size_t size)
+{
+    ngx_mail_cleanup_t  *cln;
+
+    cln = ngx_palloc(s->connection->pool, sizeof(ngx_mail_cleanup_t));
+    if (cln == NULL) {
+        return NULL;
+    }
+
+    if (size) {
+        cln->data = ngx_palloc(s->connection->pool, size);
+        if (cln->data == NULL) {
+            return NULL;
+        }
+
+    } else {
+        cln->data = NULL;
+    }
+
+    cln->handler = NULL;
+    cln->next = s->cleanup;
+
+    s->cleanup = cln;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                   "mail cleanup add: %p", cln);
+
+    return cln;
+}
diff --git a/src/mail/ngx_mail_handler.c b/src/mail/ngx_mail_handler.c
index 803a247d2..ca34b7c7c 100644
--- a/src/mail/ngx_mail_handler.c
+++ b/src/mail/ngx_mail_handler.c
@@ -10,8 +10,18 @@
 #include <ngx_event.h>
 #include <ngx_mail.h>
 
+#include <sasl/sasl.h>
+#include <sasl/saslplug.h>
+#include <ngx_mail_throttle_module.h>
+#include <ngx_mail_pop3_module.h>
+#include <ngx_mail_smtp_module.h>
+#include <ngx_mail_zmauth_module.h>
 
 static void ngx_mail_init_session(ngx_connection_t *c);
+static void ngx_mail_choke_session(throttle_callback_t *cb);
+static void ngx_mail_allow_session(throttle_callback_t *cb);
+static void ngx_mail_allow_userauth(throttle_callback_t *cb);
+static void ngx_mail_choke_userauth(throttle_callback_t *cb);
 
 #if (NGX_MAIL_SSL)
 static void ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);
@@ -20,13 +30,26 @@ static ngx_int_t ngx_mail_verify_cert(ngx_mail_session_t *s,
     ngx_connection_t *c);
 #endif
 
+static int ngx_mail_create_sasl_context(ngx_connection_t *s);
+static void ngx_mail_dispose_sasl_context(ngx_mail_session_t *s);
+static int ngx_mail_initialize_sasl(ngx_connection_t *c);
+static int ngx_mail_sasl_startstep(ngx_connection_t *c, const char *mech,
+     ngx_str_t  *response, ngx_str_t  *challenge);
+static int ngx_mail_sasl_log(void *context, int level, const char * message);
+static int ngx_mail_sasl_pauthorize(sasl_conn_t *conn, void *context,
+const char *authz, unsigned authzlen, const char *authc, unsigned authclen,
+const char *realm, unsigned rlen, struct propctx *propctx);
+
+static ngx_str_t    krb5_cooked_password = ngx_string("KKK");
+
+static ngx_flag_t sasl_initialized = 0;
 
 void
 ngx_mail_init_connection(ngx_connection_t *c)
 {
-    size_t                     len;
     ngx_uint_t                 i;
     ngx_mail_port_t           *port;
+    ngx_uint_t                remote_port=0;
     struct sockaddr           *sa;
     struct sockaddr_in        *sin;
     ngx_mail_log_ctx_t        *ctx;
@@ -134,14 +157,32 @@ ngx_mail_init_connection(ngx_connection_t *c)
     c->data = s;
     s->connection = c;
 
+    switch (c->sockaddr->sa_family) {
+#if (NGX_HAVE_INET6)
+    case AF_INET6:
+      sin6 = (struct sockaddr_in6 *) c->sockaddr;
+      remote_port = ntohs(sin6->sin6_port);
+      break;
+#endif
+    default:
+      sin = (struct sockaddr_in *) c->sockaddr;
+      remote_port = ntohs(sin->sin_port);
+      break;
+    }
+
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
     ngx_set_connection_log(c, cscf->error_log);
 
-    len = ngx_sock_ntop(c->sockaddr, c->socklen, text, NGX_SOCKADDR_STRLEN, 1);
+    ngx_sock_ntop(c->sockaddr, c->socklen, text, NGX_SOCKADDR_STRLEN, 1);
 
-    ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%uA client %*s connected to %V",
-                  c->number, len, text, s->addr_text);
+    if (remote_port && remote_port < 65536) {
+      ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%ui client %V:%ui connected to %V",
+                    c->number, &c->addr_text, remote_port, s->addr_text);
+    } else {
+      ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%ui client %V connected to %V",
+                    c->number, &c->addr_text, s->addr_text);
+    }
 
     ctx = ngx_palloc(c->pool, sizeof(ngx_mail_log_ctx_t));
     if (ctx == NULL) {
@@ -150,6 +191,7 @@ ngx_mail_init_connection(ngx_connection_t *c)
     }
 
     ctx->client = &c->addr_text;
+    ctx->client_port = remote_port;
     ctx->session = s;
 
     c->log->connection = c->number;
@@ -335,10 +377,13 @@ ngx_mail_init_session(ngx_connection_t *c)
 {
     ngx_mail_session_t        *s;
     ngx_mail_core_srv_conf_t  *cscf;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    throttle_callback_t       *cb;
 
     s = c->data;
 
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
 
     s->protocol = cscf->protocol->type;
 
@@ -348,18 +393,243 @@ ngx_mail_init_session(ngx_connection_t *c)
         return;
     }
 
+    s->cleanup = NULL;
+
+    /* throttle */
+    cb = ngx_pcalloc(c->pool, sizeof(throttle_callback_t));
+    if(cb == NULL) {
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    ngx_memset(cb, 0, sizeof(throttle_callback_t));
+    cb->session = s;
+    cb->connection = c;
+    cb->log = ngx_cycle->log;
+    cb->pool = c->pool;
+    cb->on_allow = ngx_mail_allow_session;
+    cb->on_deny = ngx_mail_choke_session;
+
+    if (tscf->mail_login_ip_max == 0) {
+        cb->on_allow(cb); //unlimited, direct allow session
+    } else {
+        ngx_mail_throttle_ip(c->addr_text, cb);
+    }
+}
+
+static void
+ngx_mail_choke_session(throttle_callback_t *cb)
+{
+    ngx_connection_t             *c;
+    ngx_mail_session_t           *s;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_str_t                     bye, msg;
+    u_char                       *p;
+
+    c = (ngx_connection_t *)cb->connection;
+    s = c->data;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    msg = tscf->mail_login_ip_rejectmsg;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log,0,
+        "ip throttle:%V choking mail session", &c->addr_text);
+
+    if(s->protocol == NGX_MAIL_IMAP_PROTOCOL) {
+        bye.data =
+        ngx_palloc(c->pool,
+            sizeof("* BYE ")- 1 +
+            msg.len +
+            sizeof(CRLF) - 1
+            );
+        if (bye.data == NULL) {
+            ngx_str_set(&bye, "* BYE" CRLF);
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p, "* BYE ", sizeof("* BYE ") - 1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+    } else if(s->protocol == NGX_MAIL_POP3_PROTOCOL) {
+        bye.data = ngx_palloc(c->pool,
+                       sizeof("-ERR ") - 1 +
+                       msg.len +
+                       sizeof(CRLF) - 1);
+        if (bye.data == NULL) {
+            ngx_str_set(&bye, "-ERR" CRLF);
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p,"-ERR ",sizeof("-ERR ") - 1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+    } else {
+        /* TODO SMTP is not (yet) relevant for zimbra, but how do we reject it ? */
+        ngx_str_set(&bye, "");
+    }
+
+    s->out = bye;
+    s->quit = 1;
+
+    ngx_mail_send(c->write);
+
+    return;
+}
+
+static void
+ngx_mail_allow_session(throttle_callback_t *cb)
+{
+    ngx_connection_t            *c;
+    ngx_mail_session_t          *s;
+    ngx_mail_core_srv_conf_t    *cscf;
+
+    c = (ngx_connection_t*)cb->connection;
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
     c->write->handler = ngx_mail_send;
 
     cscf->protocol->init_session(s, c);
 }
 
+static void
+ngx_mail_choke_userauth(throttle_callback_t *cb)
+{
+    ngx_connection_t             *c;
+    ngx_mail_session_t           *s;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_str_t                     bye, msg, umsg;
+    size_t                        l;
+    u_char                       *p;
+
+    c = (ngx_connection_t *)cb->connection;
+    s = c->data;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    msg = tscf->mail_login_user_rejectmsg;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
+        "user throttle:%V choking mail session", &s->login);
+
+    if(s->protocol == NGX_MAIL_IMAP_PROTOCOL)
+    {
+        bye.data = ngx_palloc(c->pool, sizeof("* BYE ") - 1 +
+                              msg.len + sizeof(CRLF) - 1);
+        if (bye.data == NULL) {
+            ngx_str_set(&bye, "* BYE" CRLF);
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p, "* BYE ", sizeof("* BYE ") - 1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+        s->out = bye;
+        s->quit = 0;            /* don't quit just yet */
+        ngx_mail_send(c->write);
+
+        /* for IMAP, we also want to send back a tagged NO response */
+        l = s->tag.len + 1 /*for space*/ +
+            sizeof("NO ") - 1 +
+            sizeof(" failed") - 1 +       /* ?? "failed" or "rejected" ?? */
+            sizeof(CRLF) - 1;
+
+        if (s->command == NGX_IMAP_LOGIN) {
+            l += (sizeof("LOGIN ") - 1);
+        } else if (s->command == NGX_IMAP_AUTHENTICATE) {
+            l += (sizeof("AUTHENTICATE ") - 1);
+        }
+
+        umsg.data = ngx_palloc(c->pool,l);
+
+        if (umsg.data == NULL) {
+            ngx_str_set(&umsg, "");
+        } else {
+            p = umsg.data;
+            p = ngx_cpymem(p, s->tag.data, s->tag.len);
+            *p++=' ';
+            p = ngx_cpymem(p, "NO ", sizeof("NO ") - 1);
+            if (s->command == NGX_IMAP_LOGIN) {
+                p = ngx_cpymem(p, "LOGIN ", sizeof("LOGIN ") - 1);
+            } else if (s->command == NGX_IMAP_AUTHENTICATE) {
+                p = ngx_cpymem(p, "AUTHENTICATE ", sizeof("AUTHENTICATE ") - 1);
+            }
+            p = ngx_cpymem(p, "failed", sizeof("failed") - 1);
+            *p++ = CR;
+            *p++ = LF;
+            umsg.len = p - umsg.data;
+        }
+
+        s->out = umsg;
+        s->quit = 1;
+        ngx_mail_send(c->write);
+
+        return;
+    }
+    else if(s->protocol == NGX_MAIL_POP3_PROTOCOL)
+    {
+        bye.data =
+        ngx_palloc(c->pool,
+        sizeof("-ERR ")-1+msg.len+sizeof(CRLF)-1);
+        if (bye.data == NULL) {
+            bye.data = (u_char*)("-ERR" CRLF);
+            bye.len = sizeof("-ERR" CRLF)-1;
+        } else {
+            p = bye.data;
+            p = ngx_cpymem(p,"-ERR ",sizeof("-ERR ")-1);
+            p = ngx_cpymem(p,msg.data,msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p-bye.data;
+        }
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(c->write);
+        return;
+    }
+    else
+    {
+        /* TODO SMTP is not (yet) relevant for zimbra, but how do we reject it ? */
+        ngx_str_set(&bye, "");
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(c->write);
+        return;
+    }
+}
+
+static void
+ngx_mail_allow_userauth(throttle_callback_t *cb)
+{
+    ngx_connection_t            *c;
+    ngx_mail_session_t          *s;
+
+    c = (ngx_connection_t *)cb->connection;
+    s = c->data;
+
+    /* remainder code is the erstwhile ngx_mail_do_auth(s);*/
+    s->args.nelts = 0;
+    s->buffer->pos = s->buffer->start;
+    s->buffer->last = s->buffer->start;
+    s->state = 0;
+
+    if (s->connection->read->timer_set) {
+        ngx_del_timer(s->connection->read);
+    }
+
+    s->login_attempt++;
+    ngx_mail_zmauth_init(s);
+}
 
 ngx_int_t
 ngx_mail_salt(ngx_mail_session_t *s, ngx_connection_t *c,
     ngx_mail_core_srv_conf_t *cscf)
 {
     s->salt.data = ngx_pnalloc(c->pool,
-                               sizeof(" <18446744073709551616.@>" CRLF) - 1
+                               sizeof("<18446744073709551616.@>" CRLF) - 1
                                + NGX_TIME_T_LEN
                                + cscf->server_name.len);
     if (s->salt.data == NULL) {
@@ -397,14 +667,42 @@ ngx_mail_starttls_only(ngx_mail_session_t *s, ngx_connection_t *c)
 #endif
 
 
+/* Decode an SASL PLAIN challenge (RFC 4616)
+   If AUTHZ is empty:
+    set s->usedauth = 0,
+    set s->login = AUTHC
+   If AUTHZ is present:
+    set s->usedauth = 1
+    set s->dusr = AUTHC
+    set s->login = AUTHZ
+ */
 ngx_int_t
 ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
 {
     u_char     *p, *last;
-    ngx_str_t  *arg, plain;
+    ngx_str_t  *arg, plain, temp;
 
     arg = s->args.elts;
 
+#if (NGX_MAIL_SSL)
+    if(ngx_mail_starttls_only(s, c)) {
+    	return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+#endif
+
+    /* check if the auth exchange is being aborted */
+    if (s->args.nelts > 0 &&
+        arg[n].len == 1 &&
+        arg[n].data[0] == '*'
+       )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "auth:abort SASL PLAIN");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
+
 #if (NGX_DEBUG_MAIL_PASSWD)
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth plain: \"%V\"", &arg[n]);
@@ -421,6 +719,8 @@ ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    s->auth_method = NGX_MAIL_AUTH_PLAIN;
+
     p = plain.data;
     last = p + plain.len;
 
@@ -432,6 +732,9 @@ ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    s->dusr.data = plain.data;
+    s->dusr.len = p - plain.data - 1;
+
     s->login.data = p;
 
     while (p < last && *p) { p++; }
@@ -447,11 +750,29 @@ ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)
     s->passwd.len = last - p;
     s->passwd.data = p;
 
+    if (s->login.len > NGX_MAIL_MAX_LOGIN_LEN ||
+        s->dusr.len > NGX_MAIL_MAX_LOGIN_LEN ||
+        s->passwd.len > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_AUTH_FAILED;
+    }
+
 #if (NGX_DEBUG_MAIL_PASSWD)
     ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth plain: \"%V\" \"%V\"", &s->login, &s->passwd);
 #endif
 
+    if (s->dusr.len == 0) {
+        /* s->dusr = s->login; */
+        s->usedauth = 0;
+    } else {
+        s->usedauth = 1;
+        temp = s->dusr;
+        s->dusr = s->login;
+        s->login = temp;
+    }
+
+    s->dpasswd = s->passwd;
+
     return NGX_DONE;
 }
 
@@ -467,6 +788,23 @@ ngx_mail_auth_login_username(ngx_mail_session_t *s, ngx_connection_t *c,
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth login username: \"%V\"", &arg[n]);
 
+
+    /* check if the auth exchange is being aborted */
+    if (s->args.nelts > 0 &&
+        arg[n].len == 1 &&
+        arg[n].data[0] == '*'
+       )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "auth:abort SASL LOGIN");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
+
+    if (ngx_base64_decoded_length(arg->len) > NGX_MAIL_MAX_LOGIN_LEN) {
+        return NGX_MAIL_AUTH_FAILED;
+    }
     s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));
     if (s->login.data == NULL) {
         return NGX_ERROR;
@@ -481,7 +819,7 @@ ngx_mail_auth_login_username(ngx_mail_session_t *s, ngx_connection_t *c,
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth login username: \"%V\"", &s->login);
 
-    return NGX_OK;
+    return NGX_MAIL_AUTH_ARGUMENT;
 }
 
 
@@ -496,7 +834,21 @@ ngx_mail_auth_login_password(ngx_mail_session_t *s, ngx_connection_t *c)
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "mail auth login password: \"%V\"", &arg[0]);
 #endif
+    /* check if the auth exchange is being aborted */
+    if (s->args.nelts > 0 &&
+        arg[0].len == 1 &&
+        arg[0].data[0] == '*'
+       ) {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "auth:abort SASL LOGIN");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
 
+    if(ngx_base64_decoded_length(arg[0].len) > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_AUTH_FAILED;
+    }
     s->passwd.data = ngx_pnalloc(c->pool,
                                  ngx_base64_decoded_length(arg[0].len));
     if (s->passwd.data == NULL) {
@@ -514,6 +866,9 @@ ngx_mail_auth_login_password(ngx_mail_session_t *s, ngx_connection_t *c)
                    "mail auth login password: \"%V\"", &s->passwd);
 #endif
 
+    s->auth_method = NGX_MAIL_AUTH_LOGIN;
+    s->usedauth = 0;
+
     return NGX_DONE;
 }
 
@@ -591,10 +946,719 @@ ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c)
                    "mail auth cram-md5: \"%V\" \"%V\"", &s->login, &s->passwd);
 
     s->auth_method = NGX_MAIL_AUTH_CRAM_MD5;
+    s->usedauth = 0;
 
     return NGX_DONE;
 }
 
+ngx_int_t
+ngx_mail_auth_gssapi(ngx_mail_session_t *s, ngx_connection_t *c, ngx_str_t * output)
+{
+    ngx_str_t  *args, *arg;
+    ngx_uint_t narg;
+    ngx_mail_core_srv_conf_t *cscf;
+    int saslrc;
+
+    args = s->args.elts;
+    narg = s->args.nelts;
+    arg = args + narg - 1;
+
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+    /* check if the auth exchange is being aborted */
+    if (narg > 0 &&
+        arg->len == 1 &&
+        arg->data[0] == '*'
+       )
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL,c->log,0,
+            "auth:abort SASL GSSAPI");
+
+        ngx_mail_dispose_sasl_context(s);
+        return NGX_MAIL_AUTH_ABORT;
+    }
+
+    /* Initialize SASL once per process */
+    saslrc = ngx_mail_initialize_sasl (c);
+
+    if (saslrc != SASL_OK) {
+        return NGX_ERROR;
+    }
+
+    /* create one sasl authentication object per connection */
+    saslrc = ngx_mail_create_sasl_context (c);
+
+    if (saslrc != SASL_OK) {
+        return NGX_ERROR;
+    }
+
+    saslrc = ngx_mail_sasl_startstep(c,"gssapi", arg, output);
+
+    if (saslrc == SASL_CONTINUE)
+    {
+        return NGX_MAIL_AUTH_ARGUMENT;
+    }
+    else if (saslrc == SASL_OK)
+    {
+        s->dusr = cscf->master_auth_username;
+        s->dpasswd = cscf->master_auth_password;
+        s->auth_method = NGX_MAIL_AUTH_GSSAPI;
+        s->passwd = krb5_cooked_password;
+        s->usedauth = 1;
+        return NGX_DONE;
+    }
+    else
+    {
+        return NGX_ERROR;
+    }
+}
+
+/* Perform a once-per-process initialization of the sasl library */
+static int
+ngx_mail_initialize_sasl (ngx_connection_t *c)
+{
+    ngx_mail_session_t          *s;
+    ngx_mail_core_srv_conf_t    *cscf;
+    int                          rc = SASL_OK;
+    char                        *app;
+
+    if (!sasl_initialized)
+    {
+        s = c->data;
+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+        app = ngx_palloc(c->pool, cscf->sasl_app_name.len + 1);
+
+        if (app == NULL) { return SASL_FAIL; }
+
+        ngx_memcpy (app, cscf->sasl_app_name.data, cscf->sasl_app_name.len);
+        ngx_memcpy (app + cscf->sasl_app_name.len, "\x0", 1);
+
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "Initializing SASL library, app:%s", app);
+
+        rc = sasl_server_init (NULL, app);
+
+        if (rc != SASL_OK)
+        {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                "Cannot initialize SASL library: err:%d, %s",
+                rc, sasl_errstring(rc,NULL,NULL)
+            );
+        }
+        else
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "Initialized SASL library");
+            sasl_initialized = 1;
+        }
+    }
+
+    return rc;
+}
+
+/*
+static int ngx_mail_canonicalize_user (
+    sasl_conn_t *conn,
+    void *context,
+    const char *in,
+    unsigned inlen,
+    unsigned flags,
+    const char *realm,
+    char *out,
+    unsigned out_max,
+    unsigned *out_len
+)
+{
+    ngx_connection_t            *c = context;
+    ngx_mail_session_t          *s = c->data;
+    ngx_mail_core_srv_conf_t    *cscf =
+        ngx_mail_get_module_srv_conf(s,ngx_mail_core_module);
+    ngx_str_t            v,R;
+
+    ngx_log_debug0 (NGX_LOG_DEBUG_MAIL,c->log,0,
+        "sasl: canonicalizing user name(s)");
+
+    if (realm == NULL) {
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+            "sasl: SASL layer did not provide realm, will use:%V",
+            &cscf->default_realm);
+        R = cscf->default_realm;
+    } else {
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+            "sasl: will use realm:%s", realm);
+        R.data = (u_char *)realm;
+        R.len = strlen(realm);
+    }
+
+    if (((flags & SASL_CU_AUTHID) != 0) || ((flags & SASL_CU_AUTHZID) != 0))
+    {
+        v.data = (u_char *)in;
+        v.len = inlen;
+
+        if ((flags & SASL_CU_AUTHID) == 0) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+                "sasl: canonicalizing authzid:%V", &v);
+        } else if ((flags & SASL_CU_AUTHZID) == 0) {
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,c->log,0,
+                "sasl: canonicalizing authcid:%V", &v);
+        } else {
+            ngx_log_debug2 (NGX_LOG_DEBUG_MAIL,c->log,0,
+                "sasl: canonicalizing authzid:%V, authcid:%V", &v, &v);
+        }
+
+        if (R.len == 0) {
+            if (out_max >= inlen) {
+                ngx_memcpy(out,in,inlen);
+                *out_len = inlen;
+                return SASL_OK;
+            } else {
+                return SASL_NOMEM;
+            }
+        } else {
+            if (out_max >= (inlen+(sizeof("@")-1)+R.len)) {
+                ngx_memcpy(out,in,inlen);
+                ngx_memcpy(out+inlen,"@",sizeof("@")-1);
+                ngx_memcpy(out+inlen+sizeof("@")-1,R.data,R.len);
+                *out_len = inlen + sizeof("@")-1 + R.len;
+                return SASL_OK;
+            } else {
+                return SASL_NOMEM;
+            }
+        }
+    }
+
+    return SASL_BADPARAM;
+}
+*/
+
+static int
+ngx_mail_sasl_pauthorize (sasl_conn_t *conn, void *context, const char *authz,
+    unsigned authzlen, const char *authc, unsigned authclen, const char *realm,
+    unsigned rlen, struct propctx *propctx)
+{
+    /* this function is called when we need to indicate whether the authz/authc
+       relationship should be allowed or not
+       ie can authc access authz's mailbox
+       since that decision must be made in the lookup servlet (which will happen later),
+       we need to defer that decision to the route lookup phase, and simply
+       indicate our consent here
+     */
+
+    ngx_connection_t    *c = context;
+    ngx_str_t            nauthz = ngx_string(""),
+                         nauthc = ngx_string(""),
+                         nrealm = ngx_string("");
+
+    (void)c;
+    if (authz != NULL && authzlen > 0) {
+        nauthz.data = (u_char *)authz;
+        nauthz.len = authzlen;
+    }
+    if (authc != NULL && authclen > 0) {
+        nauthc.data = (u_char *)authc;
+        nauthc.len = authclen;
+    }
+    if (realm != NULL && rlen > 0) {
+        nrealm.data = (u_char *)realm;
+        nrealm.len = rlen;
+    }
+
+    ngx_log_debug3(NGX_LOG_DEBUG_MAIL,c->log,0,
+        "sasl: indicating proxy policy ok, authz:%V,authc:%V,realm:%V",
+        &nauthz,&nauthc,&nrealm
+        );
+
+    return SASL_OK;
+}
+
+static int
+ngx_mail_sasl_log (void *context, int level, const char *message)
+{
+    ngx_connection_t    *c = context;
+
+    (void)c;
+    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+        "%s", message == NULL ? "null" : message);
+
+    return SASL_OK;
+}
+
+
+/* create a new SASL server authentication object (once per connection) */
+static int
+ngx_mail_create_sasl_context (ngx_connection_t *c)
+{
+    ngx_mail_session_t          *s;
+    ngx_mail_core_srv_conf_t    *cscf;
+    char                        *service;
+    int                          rc = SASL_OK;
+    sasl_security_properties_t   rsec;
+    sasl_callback_t             *callbacks;
+    ngx_uint_t                   i;
+    const char                  *fqdn = NULL;
+    struct hostent              *host;
+    struct sockaddr_in           sa;
+    socklen_t                    salen;
+    u_char                      *octets;
+
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+    if (s->saslconn == NULL)
+    {
+        service = ngx_palloc (c->pool, cscf->sasl_service_name.len + 1);
+        if (service == NULL) {
+            return SASL_FAIL;
+        }
+
+        callbacks = ngx_palloc(c->pool,sizeof(sasl_callback_t) * 8);
+        if (callbacks == NULL) {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                "cannot alloc memory for SASL callbacks"
+                );
+            return SASL_NOMEM;
+        }
+
+        i =0 ;
+        // XXX using the canon callback is corrupting mem
+        // callbacks[i].id = SASL_CB_CANON_USER;
+        // callbacks[i].proc = ngx_mail_canonicalize_user;
+        // callbacks[i].context = c;
+        // ++i;
+        callbacks[i].id = SASL_CB_LOG;
+        callbacks[i].proc = (sasl_callback_ft)&ngx_mail_sasl_log;
+        callbacks[i].context = c;
+        ++i;
+
+        callbacks[i].id = SASL_CB_PROXY_POLICY;
+        callbacks[i].proc = (sasl_callback_ft)&ngx_mail_sasl_pauthorize;
+        callbacks[i].context = c;
+        ++i;
+
+        callbacks[i].id = SASL_CB_LIST_END;
+        callbacks[i].proc = NULL;
+        callbacks[i].context = NULL;
+        ++i;
+
+        ngx_memcpy (service, cscf->sasl_service_name.data,
+            cscf->sasl_service_name.len);
+        service[cscf->sasl_service_name.len] = 0;
+
+        /* The second argument to sasl_server_new is the FQDN of the server
+           If the srvprinc_from_ip configuration parameter is true, then
+         */
+
+        if (cscf->sasl_host_from_ip)
+        {
+            ngx_log_error (NGX_LOG_WARN, c->log, 0,
+                "will use IP address to resolve service principal");
+
+            salen = sizeof(sa);
+            if (
+                getsockname(s->connection->fd, (struct sockaddr*)&sa, &salen)
+                == 0
+               )
+            {
+                if (sa.sin_family != AF_INET || salen != sizeof(sa))
+                {
+                    ngx_log_error(NGX_LOG_ERR, c->log, 0,
+                        "non-ipv4 local address of mail connection ignored");
+                }
+                else
+                {
+                    octets = (u_char *)&sa.sin_addr.s_addr;
+
+                    ngx_log_error (NGX_LOG_WARN, c->log, 0,
+                        "entering blocking network call (gethostbyaddr)");
+
+                    host = gethostbyaddr(
+                            &sa.sin_addr,
+                            sizeof(sa.sin_addr),
+                            AF_INET);
+
+                    if (host == NULL)
+                    {
+                        ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                            "cannot lookup host by IP address, err:%d",
+                            h_errno);
+                    }
+                    else
+                    {
+                        ngx_log_error (NGX_LOG_INFO, c->log, 0,
+                            "resolved incoming IP %d.%d.%d.%d to host:%s",
+                            octets[0],
+                            octets[1],
+                            octets[2],
+                            octets[3],
+                            host->h_name);
+
+                        fqdn = host->h_name;
+                    }
+                }
+            }
+            else
+            {
+                ngx_log_error(NGX_LOG_ERR, c->log, 0,
+                    "cannot get local address of mail connection, err:%d",
+                    ngx_errno);
+            }
+        }
+
+        rc = sasl_server_new
+                (
+                    service,
+                    fqdn,
+                    NULL,
+                    NULL,
+                    NULL,
+                    callbacks,
+                    0,
+                    &s->saslconn
+                );
+
+        if (rc != SASL_OK)
+        {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                "cannot create SASL context (%V), err:%d,%s",
+                &cscf->sasl_service_name,
+                rc, sasl_errstring (rc,NULL,NULL)
+                );
+            s->saslconn = NULL;
+        }
+        else
+        {
+            const char * mechlist;
+            unsigned     menLen;
+            int          num;
+            rc = sasl_listmech(s->saslconn, NULL, "{", ", ", "}", &mechlist, &menLen, &num);
+            ngx_log_error(NGX_LOG_INFO, c->log,0, "mech list is: %s", mechlist);
+            ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "created SASL context (%V), 0x%p",
+                &cscf->sasl_service_name,
+                s->saslconn
+                );
+
+            rsec.min_ssf = 0;
+            rsec.max_ssf = 0;
+            rsec.maxbufsize = 4096;
+            rsec.property_names = NULL;
+            rsec.property_values = NULL;
+            rsec.security_flags = 0;
+            // SASL_SEC_PASS_CREDENTIALS|SASL_SEC_MUTUAL_AUTH;
+
+            rc = sasl_setprop(s->saslconn, SASL_SEC_PROPS, &rsec);
+        }
+    }
+
+    return rc;
+}
+
+static void
+ngx_mail_dispose_sasl_context (ngx_mail_session_t *s)
+{
+    if (s->saslconn != NULL)
+    {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL,s->connection->log,0,
+            "disposing SASL context:%p",s->saslconn);
+        sasl_dispose(&s->saslconn);
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL,s->connection->log,0,
+            "disposed SASL context:%p",s->saslconn);
+        s->saslconn = NULL;
+    }
+    return;
+}
+
+static int
+ngx_mail_sasl_startstep (
+    ngx_connection_t *c,
+    const char *mech,
+    ngx_str_t  *response,
+    ngx_str_t  *challenge
+    )
+{
+    ngx_mail_session_t          *s;
+    ngx_str_t                    r;
+    int                          rc;
+    const char                  *saslstr,*authc,*authz;
+    unsigned                     sasls;
+    ngx_str_t                    ch64, ch;
+    ngx_mail_core_srv_conf_t    *cscf;
+    u_char                      *p;
+    ngx_flag_t                   inheritAuthZ, needRealm;
+    size_t                       len;
+
+    s = c->data;
+    cscf = ngx_mail_get_module_srv_conf(s,ngx_mail_core_module);
+
+    /* saslfr (fr = first response) indicates whether the client has
+       issued at least one SASL response to the server
+       saslfr starts out as 0, and is immediately set to 1 when the
+       server starts processing the client responses
+     */
+    if (!s->saslfr)
+    {
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "beginning SASL auth negotiation");
+
+        if (response == NULL)
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "using NULL client response");
+
+            r.data = NULL;
+            r.len = 0;
+        }
+        else
+        {
+             ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "using response %V", response);
+
+             r.len = ngx_base64_decoded_length (response->len);
+             r.data = ngx_palloc (c->pool, r.len);
+
+             if (r.data == NULL) {
+                return SASL_FAIL;
+             }
+
+             if (ngx_decode_base64 (&r, response) != NGX_OK)
+             {
+                ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                    "invalid base64 response sent by client");
+
+                return SASL_FAIL;
+             }
+             else
+             {
+                ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                    "%d bytes of base64-challenge decoded to %d sasl-bytes",
+                    response->len, r.len);
+             }
+        }
+
+        rc = sasl_server_start
+                (
+                    s->saslconn,
+                    mech,
+                    (char *)r.data,
+                    r.len,
+                    &saslstr,
+                    &sasls
+                );
+
+        s->saslfr = 1;
+    }
+    else
+    {
+         ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "continuing SASL auth negotiation");
+
+         r.len = ngx_base64_decoded_length (response->len);
+         r.data = ngx_palloc (c->pool, r.len);
+
+         if (r.data == NULL) {
+            return SASL_FAIL;
+         }
+
+         if (ngx_decode_base64 (&r, response) != NGX_OK)
+         {
+            ngx_log_error (NGX_LOG_ERR, c->log, 0,
+                "invalid base64 response sent by client");
+
+            return SASL_FAIL;
+         }
+
+         rc = sasl_server_step
+                (
+                    s->saslconn,
+                    (char *)r.data,
+                    r.len,
+                    &saslstr,
+                    &sasls
+                );
+    }
+
+    if ((rc != SASL_OK) && (rc != SASL_CONTINUE))
+    {
+        ngx_log_error (NGX_LOG_ERR, c->log, 0,
+            "SASL auth negotiation failed, err:%d (%s)",
+            rc, sasl_errstring(rc,NULL,NULL));
+    }
+    else
+    {
+        /* construct the challenge depending upon the protocol */
+
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "constructing protocol specific response for %d bytes of challenge",
+            sasls);
+
+        if (saslstr == NULL || sasls == 0)
+        {
+            ch64.data = (u_char *)"";
+            ch64.len = 0;
+        }
+        else
+        {
+            ch.len = sasls;
+            ch.data = (u_char *)saslstr;
+
+            ch64.len = ngx_base64_encoded_length(ch.len);
+            ch64.data = ngx_palloc (c->pool, ch64.len);
+
+            if (ch64.data == NULL) {
+                return SASL_FAIL;
+            }
+
+            ngx_encode_base64 (&ch64, &ch);
+        }
+
+        if (rc == SASL_CONTINUE)
+        {
+            /* For IMAP/POP, we need to send "+" SP <challenge> CRLF */
+            if (s->protocol == NGX_MAIL_IMAP_PROTOCOL ||
+                s->protocol == NGX_MAIL_POP3_PROTOCOL
+               )
+            {
+                challenge->len = sizeof("+ ") -1 + ch64.len + sizeof(CRLF) -1;
+                challenge->data = ngx_palloc (c->pool,challenge->len);
+
+                if (challenge->data == NULL) {
+                    return SASL_FAIL;
+                }
+
+                memcpy (challenge->data,"+ ",sizeof("+ ") - 1);
+                memcpy (challenge->data+sizeof("+ ")-1,ch64.data,ch64.len);
+                memcpy (challenge->data+sizeof("+ ")-1+ch64.len,CRLF,
+                        sizeof(CRLF)-1);
+            }
+            else
+            {
+                challenge->data = ch64.data;
+                challenge->len = ch64.len;
+            }
+        }
+        else  /* SASL_OK */
+        {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "SASL auth negotiation complete");
+
+            authc = NULL;
+            authz = NULL;
+
+            sasl_getprop(s->saslconn, SASL_AUTHUSER, (const void **)&authc);
+            sasl_getprop(s->saslconn, SASL_USERNAME, (const void **)&authz);
+
+            ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+                "sasl: authc=%s,authz=%s",
+                authc == NULL ? "null" : authc,
+                authz == NULL ? "null" : authz
+            );
+
+            /*  authc must always be present
+                if authc doesn't end in @realm, then we append the default realm
+                from the config file
+             */
+
+            /* s->login is authz if present, otherwise it is authc
+             */
+
+            if (authc == NULL)
+            {
+                ngx_log_debug0(NGX_LOG_DEBUG_MAIL,c->log,0,
+                    "sasl: cannot get authc, authentication will fail");
+                rc = SASL_BADAUTH;
+            }
+            else
+            {
+                if (strrchr(authc,'@') == NULL) {
+                    needRealm = 1;
+                } else {
+                    needRealm = 0;
+                }
+
+                if ((authz == NULL) || (ngx_strcmp(authc,authz) == 0)) {
+                    inheritAuthZ = 1;
+                } else {
+                    inheritAuthZ = 0;
+                }
+
+                len = ngx_strlen(authc);
+
+                if (needRealm) {
+                    if (cscf->default_realm.len > 0) {
+                        ngx_log_debug1(NGX_LOG_DEBUG_MAIL,c->log,0,
+                            "No realm found in AUTHC, using config default %V", &cscf->default_realm);
+                        len += (1 + cscf->default_realm.len);
+                    } else {
+                        ngx_log_error(NGX_LOG_ERR,c->log, 0,
+                            "SASL realm required, but no realm found in authenticating principal");
+                        ngx_log_error(NGX_LOG_ERR,c->log, 0,
+                            "Authentication will fail. Set the `default_realm' variable to the default kerberos realm");
+                    }
+                }
+
+                s->authid.data = ngx_palloc(c->pool,len);
+                if (s->authid.data == NULL) {
+                    s->authid.data = (u_char *)"";
+                    s->authid.len = 0;
+                    rc = SASL_NOMEM;
+                } else {
+                    s->authid.len = len;
+                    p = s->authid.data;
+                    p = ngx_cpymem (p,authc,strlen(authc));
+
+                    if (needRealm) {
+                        if (cscf->default_realm.len > 0) {
+                            *p++ = '@';
+                            p = ngx_cpymem (p,cscf->default_realm.data,cscf->default_realm.len);
+                        }
+                    }
+                }
+
+                if (inheritAuthZ) {
+                    /* no separate authz was specified, or authz was same as authc
+                       therefore the same changes made to authc must apply to authz
+                     */
+                    s->login.data = ngx_pstrdup(c->pool,&s->authid);
+                    if (s->login.data == NULL) {
+                        s->login.data = (u_char*)"";
+                        s->login.len = 0;
+                        rc = SASL_NOMEM;
+                    } else {
+                        s->login.len = s->authid.len;
+                    }
+                } else {
+                    /* a separate authz was specified */
+                    s->login.len  = ngx_strlen(authz);
+                    s->login.data = ngx_palloc(c->pool,s->login.len);
+                    if (s->login.data == NULL) {
+                        s->login.data = (u_char*)"";
+                        s->login.len = 0;
+                        rc = SASL_NOMEM;
+                    } else {
+                        ngx_memcpy(s->login.data,authz,s->login.len);
+                    }
+                }
+            }
+
+            if(rc == SASL_OK)
+            {
+                ngx_log_debug2(NGX_LOG_DEBUG_MAIL,c->log,0,
+                    "sasl: auth exchange completed, login:%V, authc:%V",
+                    &s->login, &s->authid);
+            }
+
+            /* we don't need the SASL object after authentication because
+               we don't negotiate a security layer with any ssf
+             */
+
+            ngx_mail_dispose_sasl_context(s);
+        }
+    }
+
+    return rc;
+}
+
 
 ngx_int_t
 ngx_mail_auth_external(ngx_mail_session_t *s, ngx_connection_t *c,
@@ -671,7 +1735,7 @@ ngx_mail_send(ngx_event_t *wev)
         }
 
         if (s->quit) {
-            ngx_mail_close_connection(c);
+            ngx_mail_end_session(s);
             return;
         }
 
@@ -701,6 +1765,82 @@ again:
     }
 }
 
+void
+ngx_mail_do_auth(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    throttle_callback_t          *callback;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_mail_zmauth_conf_t   *zmcf;
+
+    zmcf = (ngx_mail_zmauth_conf_t *)ngx_mail_get_module_srv_conf(s, ngx_mail_zmauth_module);
+    if (zmcf->use_zmauth != 1) {
+        ngx_mail_auth(s, c);
+        return;
+    }
+
+    /* all auth mechanisms for all protocols pass through ngx_mail_do_auth()
+       here. Therefore, it is best to just look at the zimbra extensions
+       *once* at this point, rather than peppering that code all across
+     */
+
+    if (has_zimbra_extensions(s->login)) {
+        s->zlogin = get_zimbra_extension(s->login);
+        s->login.len -= s->zlogin.len;
+    } else {
+        s->zlogin.data = (u_char *)"";
+        s->zlogin.len = 0;
+    }
+
+    if (s->usedauth)
+    {
+        if (has_zimbra_extensions(s->dusr)) {
+            s->zusr = get_zimbra_extension(s->dusr);
+            s->dusr.len -= s->zusr.len;
+        } else {
+            s->zusr.data = (u_char *)"";
+            s->zusr.len = 0;
+        }
+    }
+
+    if (s->usedauth) {
+        /* technically, zimbra extensions are not allowed in authc
+           but it is too troublesome to reject the login appropriately
+           at this point (with the correct message), therefore it is
+           less bother to just pass the authc + {wm,ni,tb} to upstream
+         */
+        if (s->login.len == s->dusr.len &&
+            ngx_memcmp(s->login.data, s->dusr.data, s->login.len) == 0) {
+            s->qualifydauth = 1;
+        }
+    }
+
+    callback = ngx_pcalloc(c->pool, sizeof(throttle_callback_t));
+    if (callback == NULL) {
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    callback->check_only = 1;    /* just check the counter's value */
+    callback->session = s;
+    callback->connection = c;
+    callback->log = ngx_cycle->log;
+    callback->pool = c->pool;
+    callback->on_allow = ngx_mail_allow_userauth;
+    callback->on_deny = ngx_mail_choke_userauth;
+
+    /* because of DOS attacks against legitimate users, throttling is
+       postponed till after authentication
+     */
+    tscf = ngx_mail_get_module_srv_conf (s, ngx_mail_throttle_module);
+    if (tscf->mail_login_user_max == 0) {
+        callback->on_allow(callback);
+    } else {
+        ngx_mail_throttle_user(s->login, callback);
+    }
+
+    /* previous body of ngx_mail_do_auth() now in ngx_mail_allow_userauth */
+}
+
 
 ngx_int_t
 ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)
@@ -787,20 +1927,71 @@ ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c)
     ngx_mail_auth_http_init(s);
 }
 
-
+/* send a protocol-suitable internal error message to downstream
+   close the downstream connection immediately afterwards
+ */
 void
 ngx_mail_session_internal_server_error(ngx_mail_session_t *s)
 {
     ngx_mail_core_srv_conf_t  *cscf;
+    ngx_connection_t          *c;
 
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
     s->out = cscf->protocol->internal_server_error;
-    s->quit = 1;
-
+    c = s->connection->write->data;
     ngx_mail_send(s->connection->write);
+    if (c->destroyed) {
+        return;
+    }
+    /* clean up */
+    ngx_mail_cleanup_t * cln = s->cleanup;
+    while (cln != NULL) {
+        cln->handler(cln->data);
+        cln = cln->next;
+    }
+
+    ngx_mail_close_connection (s->connection);
+}
+
+/* send a protocol-suitable bye message to downstream
+   close the downstream connection immediately afterwards
+ */
+void
+ngx_mail_end_session(ngx_mail_session_t *s)
+{
+    ngx_str_t            bye = ngx_mail_session_getquitmsg(s);
+    ngx_connection_t    *c = s->connection;
+
+    if (bye.len > 0) {
+        c->send(c, bye.data, bye.len);
+    }
+
+    /* clean up */
+    ngx_mail_cleanup_t * cln = s->cleanup;
+    while (cln != NULL) {
+        cln->handler(cln->data);
+        cln = cln->next;
+    }
+
+    ngx_mail_close_connection (c);
 }
 
+/* return protocol-specific bye message */
+ngx_str_t ngx_mail_session_getquitmsg(ngx_mail_session_t *s)
+{
+    ngx_mail_core_srv_conf_t *cscf;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    return cscf->protocol->quit_msg;
+}
+
+/* return protocol-specific internal error message */
+ngx_str_t ngx_mail_session_geterrmsg(ngx_mail_session_t *s)
+{
+    ngx_mail_core_srv_conf_t  *cscf;
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    return cscf->protocol->internal_server_error;
+}
 
 void
 ngx_mail_close_connection(ngx_connection_t *c)
@@ -834,6 +2025,13 @@ ngx_mail_close_connection(ngx_connection_t *c)
     ngx_destroy_pool(pool);
 }
 
+/* note -- we want to log the local and remote host/port information for the
+   mail proxy sessions. however, nginx allows a mail servers to be specified as
+   listening on a unix domain socket. the code below assumes that the sockaddr
+   structure is pointing to an IPv4 address, and prints the address information
+   accordingly. we will need to modify the code in case we want to support
+   printing of unix domain socket information
+ */
 
 u_char *
 ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len)
@@ -850,7 +2048,11 @@ ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len)
 
     ctx = log->data;
 
-    p = ngx_snprintf(buf, len, ", client: %V", ctx->client);
+    if (ctx->client_port && ctx->client_port < 65536) {
+        p = ngx_snprintf(buf, len, ", client: %V:%ui", ctx->client, ctx->client_port);
+    } else {
+        p = ngx_snprintf(buf, len, ", client: %V", ctx->client, ctx->client_port);
+    }
     len -= p - buf;
     buf = p;
 
@@ -877,8 +2079,125 @@ ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len)
     if (s->proxy == NULL) {
         return p;
     }
+    /* with proxy, output the proxy relationship */
+
+    u_char               dw_host[NGX_SOCKADDRLEN],
+                         dw_peer[NGX_SOCKADDRLEN],
+                         up_host[NGX_SOCKADDRLEN],
+                         up_peer[NGX_SOCKADDRLEN];
+
+    socklen_t            dw_host_len, dw_peer_len,
+                         up_host_len, up_peer_len,
+                         n;
+
+    ngx_memzero (dw_peer, NGX_SOCKADDRLEN);
+    ngx_memzero (dw_host, NGX_SOCKADDRLEN);
+    ngx_memzero (up_host, NGX_SOCKADDRLEN);
+    ngx_memzero (up_peer, NGX_SOCKADDRLEN);
+
+    dw_host_len = dw_peer_len = up_host_len = up_peer_len = NGX_SOCKADDRLEN;
+
+    if (s->connection) {
+       getsockname
+            (s->connection->fd, (struct sockaddr *)dw_host, &dw_host_len);
+
+       getpeername
+            (s->connection->fd, (struct sockaddr *)dw_peer, &dw_peer_len);
+    }
+
+    if (s->proxy->upstream.connection) {
+        getsockname (s->proxy->upstream.connection->fd,
+            (struct sockaddr *)up_host, &up_host_len);
+        getpeername (s->proxy->upstream.connection->fd,
+            (struct sockaddr *)up_peer, &up_peer_len);
+    }
 
     p = ngx_snprintf(buf, len, ", upstream: %V", s->proxy->upstream.name);
+    len -= p - buf;
+    buf = p;
+
+    /* generate "(dw_peer->dw_host) <=> (up_host->up_peer)" */
+    p = ngx_snprintf(buf, len, " (");
+    len -= p - buf;
+    buf = p;
+
+    n = ngx_sock_ntop((struct sockaddr *)dw_peer, NGX_SOCKADDR_STRLEN, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    *buf++ = '-';
+    len--;
+    *buf++ = '>';
+    len--;
+
+    n = ngx_sock_ntop((struct sockaddr *)dw_host, NGX_SOCKADDR_STRLEN, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    p = ngx_snprintf(buf, len, ") <=> (");
+    len -= p - buf;
+    buf = p;
+
+    n = ngx_sock_ntop((struct sockaddr *)up_host, NGX_SOCKADDR_STRLEN, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    *buf++ = '-';
+    len--;
+    *buf++ = '>';
+    len--;
+
+    n = ngx_sock_ntop((struct sockaddr *)up_peer, NGX_SOCKADDR_STRLEN, buf, len, 1);
+    len -= n;
+    buf += n;
+
+    *buf++ = ')';
+    len--;
+
+    p = buf;
 
     return p;
 }
+
+/*
+ * Giving a socket, return its local addr string representation IP. The
+ * string will be allocated on "pool".
+ */
+ngx_str_t ngx_mail_get_socket_local_addr_str (ngx_pool_t *pool, ngx_socket_t s)
+{
+    int family;
+    static ngx_str_t     res;
+    struct sockaddr_in  *sin;
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6 *sin6;
+#endif
+    u_char              *p;
+    socklen_t            len, strlen;
+    u_char               sockaddr[NGX_SOCKADDRLEN];
+
+    len = NGX_SOCKADDRLEN;
+    ngx_memzero(sockaddr, len);
+    getsockname(s, (struct sockaddr*)sockaddr, &len);
+
+    family = ((struct sockaddr *)sockaddr)->sa_family;
+    if (family == AF_INET) {
+        sin = (struct sockaddr_in *)sockaddr;
+        p = ngx_palloc(pool, NGX_INET_ADDRSTRLEN);
+        strlen = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                NGX_INET_ADDRSTRLEN);
+
+#if (NGX_HAVE_INET6)
+    } else {
+        sin6 = (struct sockaddr_in6 *)sockaddr;
+        p = ngx_palloc(pool, NGX_INET6_ADDRSTRLEN);
+        strlen = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                p, NGX_INET6_ADDRSTRLEN);
+#endif
+
+    }
+
+    res.data = p;
+    res.len = strlen;
+
+    return res;
+}
diff --git a/src/mail/ngx_mail_imap_handler.c b/src/mail/ngx_mail_imap_handler.c
index 3bf09ec3c..ba253e733 100644
--- a/src/mail/ngx_mail_imap_handler.c
+++ b/src/mail/ngx_mail_imap_handler.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -20,27 +24,35 @@ static ngx_int_t ngx_mail_imap_capability(ngx_mail_session_t *s,
     ngx_connection_t *c);
 static ngx_int_t ngx_mail_imap_starttls(ngx_mail_session_t *s,
     ngx_connection_t *c);
+static ngx_int_t ngx_mail_imap_id(ngx_mail_session_t *s,
+    ngx_connection_t *c);
 
 
-static u_char  imap_greeting[] = "* OK IMAP4 ready" CRLF;
-static u_char  imap_star[] = "* ";
+/*static u_char  imap_greeting[] = "* OK IMAP4 ready" CRLF; zimbra uses the greeting specified by the directive */
+static u_char  imap_star[] = "*";
 static u_char  imap_ok[] = "OK completed" CRLF;
-static u_char  imap_next[] = "+ OK" CRLF;
+static u_char  imap_next[] = "+ " CRLF;
 static u_char  imap_plain_next[] = "+ " CRLF;
+static u_char  imap_gssapi_next[] = "+ " CRLF;
 static u_char  imap_username[] = "+ VXNlcm5hbWU6" CRLF;
 static u_char  imap_password[] = "+ UGFzc3dvcmQ6" CRLF;
-static u_char  imap_bye[] = "* BYE" CRLF;
+static u_char  imap_bye[] = "* BYE Zimbra IMAP server terminating connection" CRLF;
 static u_char  imap_invalid_command[] = "BAD invalid command" CRLF;
-
+static u_char  imap_unsupported_mech[] = "NO mechanism not supported" CRLF;
+static u_char  imap_nocleartext[] = "NO cleartext logins disabled" CRLF;
+static u_char  imap_authaborted[] = "BAD AUTHENTICATE aborted" CRLF;
+static u_char  imap_login_failed[] = "NO LOGIN failed" CRLF;
+static u_char  imap_authenticate_failed[] = "NO AUTHENTICATE failed" CRLF;
 
 void
 ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
 {
     ngx_mail_core_srv_conf_t  *cscf;
-
+    ngx_mail_imap_srv_conf_t  *iscf;
     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
 
-    ngx_str_set(&s->out, imap_greeting);
+    s->out = iscf->greeting;
 
     c->read->handler = ngx_mail_imap_init_protocol;
 
@@ -91,6 +103,7 @@ ngx_mail_imap_init_protocol(ngx_event_t *rev)
         }
     }
 
+    ngx_mail_set_imap_parse_state_start(s);
     s->mail_state = ngx_imap_start;
     c->read->handler = ngx_mail_imap_auth_state;
 
@@ -116,7 +129,7 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)
     if (rev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
         c->timedout = 1;
-        ngx_mail_close_connection(c);
+        ngx_mail_end_session(s);    /* send IMAP BYE on timeout */
         return;
     }
 
@@ -134,11 +147,13 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)
         return;
     }
 
-    tag = 1;
-    s->text.len = 0;
-    ngx_str_set(&s->out, imap_ok);
-
-    if (rc == NGX_OK) {
+    if (rc == NGX_IMAP_NEXT) {
+        tag = 0;
+        ngx_str_set(&s->out, imap_next);
+    } else {
+        tag = 1;
+        ngx_str_set(&s->out, imap_ok);
+        s->text.len = 0;
 
         ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, "imap auth command: %i",
                        s->command);
@@ -164,90 +179,162 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)
             s->backslash = 0;
         }
 
-        switch (s->mail_state) {
+        if (rc == NGX_OK) {
+            switch (s->mail_state) {
 
-        case ngx_imap_start:
+            case ngx_imap_start:
 
-            switch (s->command) {
+                switch (s->command) {
 
-            case NGX_IMAP_LOGIN:
-                rc = ngx_mail_imap_login(s, c);
-                break;
+                case NGX_IMAP_LOGIN:
+                    rc = ngx_mail_imap_login(s, c);
+                    break;
 
-            case NGX_IMAP_AUTHENTICATE:
-                rc = ngx_mail_imap_authenticate(s, c);
-                tag = (rc != NGX_OK);
-                break;
+                case NGX_IMAP_AUTHENTICATE:
+                    rc = ngx_mail_imap_authenticate(s, c);
+                    break;
 
-            case NGX_IMAP_CAPABILITY:
-                rc = ngx_mail_imap_capability(s, c);
-                break;
+                case NGX_IMAP_CAPABILITY:
+                    rc = ngx_mail_imap_capability(s, c);
+                    break;
 
-            case NGX_IMAP_LOGOUT:
-                s->quit = 1;
-                ngx_str_set(&s->text, imap_bye);
-                break;
+                case NGX_IMAP_LOGOUT:
+                    s->quit = 1;
+                    ngx_str_set(&s->text, imap_bye);
+                    break;
 
-            case NGX_IMAP_NOOP:
-                break;
+                case NGX_IMAP_NOOP:
+                    break;
 
-            case NGX_IMAP_STARTTLS:
-                rc = ngx_mail_imap_starttls(s, c);
-                break;
+                case NGX_IMAP_STARTTLS:
+                    rc = ngx_mail_imap_starttls(s, c);
+                    break;
 
-            default:
-                rc = NGX_MAIL_PARSE_INVALID_COMMAND;
-                break;
-            }
+                case NGX_IMAP_ID:
+                    rc = ngx_mail_imap_id(s, c);
+                    break;
 
-            break;
+                default:
+                    rc = NGX_MAIL_PARSE_INVALID_COMMAND;
+                    break;
+                }
 
-        case ngx_imap_auth_login_username:
-            rc = ngx_mail_auth_login_username(s, c, 0);
+                break;
 
-            tag = 0;
-            ngx_str_set(&s->out, imap_password);
-            s->mail_state = ngx_imap_auth_login_password;
+            case ngx_imap_auth_login_username:
+                rc = ngx_mail_auth_login_username(s, c, 0);
+                if (rc == NGX_MAIL_AUTH_ARGUMENT) {
+                    ngx_str_set(&s->out, imap_password);
+                    s->mail_state = ngx_imap_auth_login_password;
+                }
 
-            break;
+                break;
 
-        case ngx_imap_auth_login_password:
-            rc = ngx_mail_auth_login_password(s, c);
-            break;
+            case ngx_imap_auth_login_password:
+                rc = ngx_mail_auth_login_password(s, c);
+                break;
 
-        case ngx_imap_auth_plain:
-            rc = ngx_mail_auth_plain(s, c, 0);
-            break;
+            case ngx_imap_auth_plain:
+                rc = ngx_mail_auth_plain(s, c, 0);
+                break;
 
-        case ngx_imap_auth_cram_md5:
-            rc = ngx_mail_auth_cram_md5(s, c);
-            break;
+            case ngx_imap_auth_gssapi:
+            {
+                ngx_str_t output;
+                ngx_str_set(&output, "");
+                rc = ngx_mail_auth_gssapi(s, c, &output);
+                if (rc == NGX_MAIL_AUTH_ARGUMENT) {
+                    s->mail_state = ngx_imap_auth_gssapi;
+                    s->out = output;
+                }
+                break;
+            }
 
-        case ngx_imap_auth_external:
-            rc = ngx_mail_auth_external(s, c, 0);
-            break;
+            case ngx_imap_auth_cram_md5:
+                rc = ngx_mail_auth_cram_md5(s, c);
+                break;
+            }
         }
 
-    } else if (rc == NGX_IMAP_NEXT) {
-        tag = 0;
-        ngx_str_set(&s->out, imap_next);
-    }
-
     switch (rc) {
 
     case NGX_DONE:
-        ngx_mail_auth(s, c);
+        ngx_mail_do_auth(s, c);
         return;
 
+    case NGX_OK:
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
+    case NGX_MAIL_AUTH_ABORT:
+        ngx_str_set(&s->out, imap_authaborted);
+        s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
+        break;
+
     case NGX_ERROR:
         ngx_mail_session_internal_server_error(s);
         return;
 
+     case NGX_MAIL_AUTH_FAILED:
+         ngx_str_set(&s->out, imap_authenticate_failed);
+         s->mail_state = ngx_imap_start;
+         ngx_mail_set_imap_parse_state_start(s);
+         s->arg_start = NULL;
+         ngx_mail_reset_parse_buffer(s);
+         break;
+
+     case NGX_MAIL_LOGIN_FAILED:
+         ngx_str_set(&s->out, imap_login_failed);
+         s->mail_state = ngx_imap_start;
+         ngx_mail_set_imap_parse_state_start(s);
+         s->arg_start = NULL;
+         ngx_mail_reset_parse_buffer(s);
+         break;
+
+     case NGX_MAIL_PARSE_INVALID_AUTH_MECH:
+         ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+             "unsupported IMAP auth mechanism");
+         ngx_str_set(&s->out, imap_unsupported_mech);
+         s->mail_state = ngx_imap_start;
+         ngx_mail_set_imap_parse_state_start(s);
+         s->arg_start = NULL;
+         ngx_mail_reset_parse_buffer(s);
+         break;
+
     case NGX_MAIL_PARSE_INVALID_COMMAND:
         s->state = 0;
         ngx_str_set(&s->out, imap_invalid_command);
         s->mail_state = ngx_imap_start;
+        ngx_mail_set_imap_parse_state_start(s);
+        s->arg_start = NULL;
+        ngx_mail_reset_parse_buffer(s);
         break;
+
+     case NGX_MAIL_AUTH_ARGUMENT:
+         ngx_mail_set_imap_parse_state_argument(s);
+         /* preserve tag, since tag's memory is allocated in buffer, need to set the
+          * buffer pos after tag */
+         s->arg_start = s->buffer->start + s->tag.len;
+         s->buffer->pos = s->arg_start;
+         s->buffer->last = s->arg_start;
+         tag = 0; // just output s->out
+         break;
+
+     case NGX_IMAP_NEXT:
+         /* do nothing, preserve all the state, including s->state, s->mail_state,
+          * , s->buffer, s->arg_start
+         */
+         break;
+    }
+
+    //clear args
+    if(rc != NGX_IMAP_NEXT) {
+        s->args.nelts = 0;
     }
 
     if (tag) {
@@ -255,8 +342,8 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)
             ngx_str_set(&s->tag, imap_star);
         }
 
-        if (s->tagged_line.len < s->tag.len + s->text.len + s->out.len) {
-            s->tagged_line.len = s->tag.len + s->text.len + s->out.len;
+        if (s->tagged_line.len < s->tag.len + s->text.len + s->out.len + 1) {
+            s->tagged_line.len = s->tag.len + s->text.len + s->out.len + 1;
             s->tagged_line.data = ngx_pnalloc(c->pool, s->tagged_line.len);
             if (s->tagged_line.data == NULL) {
                 ngx_mail_close_connection(c);
@@ -271,32 +358,17 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)
         }
 
         p = ngx_cpymem(p, s->tag.data, s->tag.len);
+        *p++ = ' '; /* the space between tag and out */
         ngx_memcpy(p, s->out.data, s->out.len);
 
-        s->out.len = s->text.len + s->tag.len + s->out.len;
+        s->out.len = s->text.len + s->tag.len + 1 /*for space*/+ s->out.len;
         s->out.data = s->tagged_line.data;
     }
 
-    if (rc != NGX_IMAP_NEXT) {
-        s->args.nelts = 0;
-
-        if (s->state) {
-            /* preserve tag */
-            s->arg_start = s->buffer->start + s->tag.len;
-            s->buffer->pos = s->arg_start;
-            s->buffer->last = s->arg_start;
-
-        } else {
-            s->buffer->pos = s->buffer->start;
-            s->buffer->last = s->buffer->start;
-            s->tag.len = 0;
-        }
-    }
-
     ngx_mail_send(c->write);
+    }
 }
 
-
 static ngx_int_t
 ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
 {
@@ -304,6 +376,7 @@ ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
 
 #if (NGX_MAIL_SSL)
     if (ngx_mail_starttls_only(s, c)) {
+        ngx_str_set(&s->text, imap_nocleartext);
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 #endif
@@ -314,6 +387,9 @@ ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
+    if (arg[0].len > NGX_MAIL_MAX_LOGIN_LEN) {
+        return NGX_MAIL_LOGIN_FAILED;
+    }
     s->login.len = arg[0].len;
     s->login.data = ngx_pnalloc(c->pool, s->login.len);
     if (s->login.data == NULL) {
@@ -322,6 +398,9 @@ ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
 
     ngx_memcpy(s->login.data, arg[0].data, s->login.len);
 
+    if (arg[1].len > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_LOGIN_FAILED;
+    }
     s->passwd.len = arg[1].len;
     s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
     if (s->passwd.data == NULL) {
@@ -339,6 +418,8 @@ ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
                    "imap login:\"%V\"", &s->login);
 #endif
 
+    s->auth_method = NGX_MAIL_AUTH_PASSWD;
+    s->usedauth = 0;
     return NGX_DONE;
 }
 
@@ -346,16 +427,10 @@ ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)
 static ngx_int_t
 ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)
 {
-    ngx_int_t                  rc;
+    ngx_int_t                  rc, res;
     ngx_mail_core_srv_conf_t  *cscf;
     ngx_mail_imap_srv_conf_t  *iscf;
 
-#if (NGX_MAIL_SSL)
-    if (ngx_mail_starttls_only(s, c)) {
-        return NGX_MAIL_PARSE_INVALID_COMMAND;
-    }
-#endif
-
     iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
 
     rc = ngx_mail_auth_parse(s, c);
@@ -363,30 +438,69 @@ ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)
     switch (rc) {
 
     case NGX_MAIL_AUTH_LOGIN:
-
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, imap_username);
         s->mail_state = ngx_imap_auth_login_username;
 
-        return NGX_OK;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
     case NGX_MAIL_AUTH_LOGIN_USERNAME:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
 
-        ngx_str_set(&s->out, imap_password);
-        s->mail_state = ngx_imap_auth_login_password;
-
-        return ngx_mail_auth_login_username(s, c, 1);
-
+        res = ngx_mail_auth_login_username(s, c, 1);
+        if (res == NGX_MAIL_AUTH_ARGUMENT) {
+            ngx_str_set(&s->out, imap_password);
+            s->mail_state = ngx_imap_auth_login_password;
+            return NGX_MAIL_AUTH_ARGUMENT;
+        } else {
+            return res;
+        }
     case NGX_MAIL_AUTH_PLAIN:
-
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, imap_plain_next);
         s->mail_state = ngx_imap_auth_plain;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
-        return NGX_OK;
+    case NGX_MAIL_AUTH_PLAIN_IR:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        return ngx_mail_auth_plain(s, c, 1);
+
+    case NGX_MAIL_AUTH_GSSAPI:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        ngx_str_set(&s->out, imap_gssapi_next);
+        s->mail_state = ngx_imap_auth_gssapi;
+
+        return NGX_MAIL_AUTH_ARGUMENT;
+
+    case NGX_MAIL_AUTH_GSSAPI_IR:
+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        s->mail_state = ngx_imap_auth_gssapi;
+        ngx_str_t output;
+        ngx_str_set(&output, "");
+        res = ngx_mail_auth_gssapi(s, c, &output);
+        if(res == NGX_MAIL_AUTH_ARGUMENT) {
+            s->out = output;
+            return NGX_MAIL_AUTH_ARGUMENT;
+        } else {
+            return res;
+        }
 
     case NGX_MAIL_AUTH_CRAM_MD5:
 
         if (!(iscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {
-            return NGX_MAIL_PARSE_INVALID_COMMAND;
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
         }
 
         if (s->salt.data == NULL) {
@@ -399,7 +513,7 @@ ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)
 
         if (ngx_mail_auth_cram_md5_salt(s, c, "+ ", 2) == NGX_OK) {
             s->mail_state = ngx_imap_auth_cram_md5;
-            return NGX_OK;
+            return NGX_MAIL_AUTH_ARGUMENT;
         }
 
         return NGX_ERROR;
@@ -470,3 +584,66 @@ ngx_mail_imap_starttls(ngx_mail_session_t *s, ngx_connection_t *c)
 
     return NGX_MAIL_PARSE_INVALID_COMMAND;
 }
+
+static ngx_int_t
+ngx_mail_imap_id(ngx_mail_session_t *s, ngx_connection_t * c)
+{
+    size_t i;
+    ngx_mail_imap_srv_conf_t  *iscf;
+    ngx_str_t                 *key, * value;
+
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
+    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,s->connection->log,0,
+      "imap id received %d parameters from client", s->args.nelts);
+    if (s->args.nelts) {
+      ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+          "client ID params [%d pair(s)]",
+          s->args.nelts/2);
+        for (i = 0; i < s->args.nelts / 2; ++i) {
+            ngx_log_debug3 (NGX_LOG_DEBUG_MAIL,
+                  s->connection->log, 0,
+                  "[pair %d] field:'%V' value:'%V'",
+                  i+1,
+                  (ngx_str_t*)s->args.elts + 2 * i,
+                  (ngx_str_t*)s->args.elts + 2 * i + 1
+                );
+            key = (ngx_str_t*)s->args.elts + 2 * i;
+            /* bug 64978, add support to "name" and "version" field */
+            if (key->len == sizeof ("name") - 1 &&
+                (key->data[0] == 'N' || key->data[0] == 'n') &&
+                (key->data[1] == 'A' || key->data[1] == 'a') &&
+                (key->data[2] == 'M' || key->data[2] == 'm') &&
+                (key->data[3] == 'E' || key->data[3] == 'e')) {
+                value = (ngx_str_t*)s->args.elts + 2 * i + 1;
+
+                s->id_name.data = ngx_pnalloc(c->pool, value->len);
+                if (s->id_name.data == NULL) {
+                    return NGX_ERROR;
+                }
+
+                ngx_memcpy(s->id_name.data, value->data, value->len);
+                s->id_name.len = value->len;
+            } else if (key->len == sizeof ("version") - 1 &&
+                    (key->data[0] == 'V' || key->data[0] == 'v') &&
+                    (key->data[1] == 'E' || key->data[1] == 'e') &&
+                    (key->data[2] == 'R' || key->data[2] == 'r') &&
+                    (key->data[3] == 'S' || key->data[3] == 's') &&
+                    (key->data[4] == 'I' || key->data[4] == 'i') &&
+                    (key->data[5] == 'O' || key->data[5] == 'o') &&
+                    (key->data[6] == 'N' || key->data[6] == 'n')) {
+                value = (ngx_str_t*)s->args.elts + 2 * i + 1;
+
+                s->id_version.data = ngx_pnalloc(c->pool, value->len);
+                if (s->id_version.data == NULL) {
+                    return NGX_ERROR;
+                }
+
+                ngx_memcpy(s->id_version.data, value->data, value->len);
+                s->id_version.len = value->len;
+            }
+        }
+    }
+    s->text = iscf->id;
+
+    return NGX_OK;
+}
diff --git a/src/mail/ngx_mail_imap_module.c b/src/mail/ngx_mail_imap_module.c
index 1f187fdee..82d6e89d9 100644
--- a/src/mail/ngx_mail_imap_module.c
+++ b/src/mail/ngx_mail_imap_module.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -15,7 +19,9 @@
 static void *ngx_mail_imap_create_srv_conf(ngx_conf_t *cf);
 static char *ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent,
     void *child);
+static char *ngx_mail_imap_id (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
 
+static ngx_str_t default_imap_greeting = ngx_string("* OK IMAP4 ready");
 
 static ngx_str_t  ngx_mail_imap_default_capabilities[] = {
     ngx_string("IMAP4"),
@@ -30,18 +36,18 @@ static ngx_conf_bitmask_t  ngx_mail_imap_auth_methods[] = {
     { ngx_string("login"), NGX_MAIL_AUTH_LOGIN_ENABLED },
     { ngx_string("cram-md5"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },
     { ngx_string("external"), NGX_MAIL_AUTH_EXTERNAL_ENABLED },
-    { ngx_null_string, 0 }
+    { ngx_string("gssapi"), NGX_MAIL_AUTH_GSSAPI_ENABLED },     { ngx_null_string, 0 }
 };
 
-
+/* zimbra's merge_conf method doesn't use this
 static ngx_str_t  ngx_mail_imap_auth_methods_names[] = {
     ngx_string("AUTH=PLAIN"),
     ngx_string("AUTH=LOGIN"),
-    ngx_null_string,  /* APOP */
+    ngx_null_string,  // APOP
     ngx_string("AUTH=CRAM-MD5"),
     ngx_string("AUTH=EXTERNAL"),
-    ngx_null_string   /* NONE */
-};
+    ngx_null_string   // NONE
+}; */
 
 
 static ngx_mail_protocol_t  ngx_mail_imap_protocol = {
@@ -56,7 +62,8 @@ static ngx_mail_protocol_t  ngx_mail_imap_protocol = {
 
     ngx_string("* BAD internal server error" CRLF),
     ngx_string("* BYE SSL certificate error" CRLF),
-    ngx_string("* BYE No required SSL certificate" CRLF)
+    ngx_string("* BYE No required SSL certificate" CRLF),
+    ngx_string("* BYE Zimbra IMAP server terminating connection" CRLF)
 };
 
 
@@ -76,6 +83,13 @@ static ngx_command_t  ngx_mail_imap_commands[] = {
       offsetof(ngx_mail_imap_srv_conf_t, capabilities),
       NULL },
 
+    { ngx_string("imap_id"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
+      ngx_mail_imap_id,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_imap_srv_conf_t, id_params),
+      NULL },
+
     { ngx_string("imap_auth"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
       ngx_conf_set_bitmask_slot,
@@ -83,6 +97,20 @@ static ngx_command_t  ngx_mail_imap_commands[] = {
       offsetof(ngx_mail_imap_srv_conf_t, auth_methods),
       &ngx_mail_imap_auth_methods },
 
+    { ngx_string("imap_literalauth"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_imap_srv_conf_t, literalauth),
+      NULL },
+
+    { ngx_string("imap_greeting"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_imap_srv_conf_t, greeting),
+      NULL },
+
       ngx_null_command
 };
 
@@ -132,6 +160,17 @@ ngx_mail_imap_create_srv_conf(ngx_conf_t *cf)
         return NULL;
     }
 
+    if (ngx_array_init(&iscf->id_params, cf->pool, 4, sizeof(ngx_str_t))
+    	!= NGX_OK)
+    {
+    	return NULL;
+    }
+
+    iscf->literalauth = NGX_CONF_UNSET;
+
+    ngx_str_null(&iscf->ua_name);
+    ngx_str_null(&iscf->ua_version);
+
     return iscf;
 }
 
@@ -142,14 +181,14 @@ ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_mail_imap_srv_conf_t *prev = parent;
     ngx_mail_imap_srv_conf_t *conf = child;
 
-    u_char      *p, *auth;
-    size_t       size;
+    u_char      *p, *p1, *p2, *p3;
+    size_t      size, s1, s2, s3;
     ngx_str_t   *c, *d;
-    ngx_uint_t   i, m;
+    ngx_uint_t   i;
 
     ngx_conf_merge_size_value(conf->client_buffer_size,
                               prev->client_buffer_size,
-                              (size_t) ngx_pagesize);
+                              (size_t) 4 * ngx_pagesize);
 
     ngx_conf_merge_bitmask_value(conf->auth_methods,
                               prev->auth_methods,
@@ -157,6 +196,10 @@ ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
                                |NGX_MAIL_AUTH_PLAIN_ENABLED));
 
 
+    if (conf->id_params.nelts == 0) {
+        conf->id_params = prev->id_params;
+    }
+
     if (conf->capabilities.nelts == 0) {
         conf->capabilities = prev->capabilities;
     }
@@ -173,85 +216,245 @@ ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         }
     }
 
-    size = sizeof("* CAPABILITY" CRLF) - 1;
+    s1 = sizeof("* CAPABILITY" CRLF) - 1;
+    s2 = s1;
+    s3 = s1;
 
     c = conf->capabilities.elts;
     for (i = 0; i < conf->capabilities.nelts; i++) {
-        size += 1 + c[i].len;
+        s1 += 1 + c[i].len;
+        s2 += 1 + c[i].len;
+        s3 += 1 + c[i].len;
     }
-
-    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
-         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;
-         m <<= 1, i++)
-    {
-        if (m & conf->auth_methods) {
-            size += 1 + ngx_mail_imap_auth_methods_names[i].len;
-        }
+    if (conf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED) {
+        s1 += sizeof (" AUTH=LOGIN") - 1;
+        s2 += sizeof (" AUTH=LOGIN") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+        s1 += sizeof (" AUTH=PLAIN") - 1;
+        s2 += sizeof (" AUTH=PLAIN") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
+        s1 += sizeof (" AUTH=CRAM-MD5") - 1;
+        s2 += sizeof (" AUTH=CRAM-MD5") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+        s1 += sizeof (" AUTH=GSSAPI") - 1;
+        s2 += sizeof (" AUTH=GSSAPI") - 1;
+        s3 += sizeof (" AUTH=GSSAPI") - 1;
     }
 
-    p = ngx_pnalloc(cf->pool, size);
-    if (p == NULL) {
+    s2 += sizeof (" STARTTLS") - 1;
+    s3 += sizeof (" STARTTLS") - 1;
+    s3 += sizeof (" LOGINDISABLED") - 1;
+
+    p1 = ngx_palloc(cf->pool, s1);
+    if (p1 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+    p2 = ngx_palloc(cf->pool, s2);
+    if (p2 == NULL) {
         return NGX_CONF_ERROR;
     }
+    p3 = ngx_palloc(cf->pool, s3);
+    if (p3 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    conf->capability.len = s1;
+    conf->capability.data = p1;
 
-    conf->capability.len = size;
-    conf->capability.data = p;
+    conf->starttls_capability.len = s2;
+    conf->starttls_capability.data = p2;
 
-    p = ngx_cpymem(p, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+    conf->starttls_only_capability.len = s3;
+    conf->starttls_only_capability.data = p3;
 
+    p1 = ngx_cpymem(p1, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+    p2 = ngx_cpymem(p2, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+    p3 = ngx_cpymem(p3, "* CAPABILITY", sizeof("* CAPABILITY") - 1);
+
+    c = conf->capabilities.elts;
     for (i = 0; i < conf->capabilities.nelts; i++) {
-        *p++ = ' ';
-        p = ngx_cpymem(p, c[i].data, c[i].len);
+        *p1++ = ' ';
+        p1 = ngx_cpymem(p1,c[i].data,c[i].len);
+        *p2++ = ' ';
+        p2 = ngx_cpymem(p2,c[i].data,c[i].len);
+        *p3++ = ' ';
+        p3 = ngx_cpymem(p3,c[i].data,c[i].len);
     }
 
-    auth = p;
-
-    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
-         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;
-         m <<= 1, i++)
-    {
-        if (m & conf->auth_methods) {
-            *p++ = ' ';
-            p = ngx_cpymem(p, ngx_mail_imap_auth_methods_names[i].data,
-                           ngx_mail_imap_auth_methods_names[i].len);
-        }
+    if (conf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=LOGIN", sizeof(" AUTH=LOGIN") - 1);
+        p2 = ngx_cpymem(p2," AUTH=LOGIN", sizeof(" AUTH=LOGIN") - 1);
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=PLAIN", sizeof(" AUTH=PLAIN") - 1);
+        p2 = ngx_cpymem(p2," AUTH=PLAIN", sizeof(" AUTH=PLAIN") - 1);
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=CRAM-MD5", sizeof(" AUTH=CRAM-MD5") - 1);
+        p2 = ngx_cpymem(p2," AUTH=CRAM-MD5", sizeof(" AUTH=CRAM-MD5") - 1);
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+        p1 = ngx_cpymem(p1," AUTH=GSSAPI", sizeof(" AUTH=GSSAPI") - 1);
+        p2 = ngx_cpymem(p2," AUTH=GSSAPI", sizeof(" AUTH=GSSAPI") - 1);
+        p3 = ngx_cpymem(p3," AUTH=GSSAPI", sizeof(" AUTH=GSSAPI") - 1);
     }
 
-    *p++ = CR; *p = LF;
+    p2 = ngx_cpymem(p2," STARTTLS",sizeof(" STARTTLS")-1);
+    p3 = ngx_cpymem(p3," STARTTLS",sizeof(" STARTTLS")-1);
+    p3 = ngx_cpymem(p3," LOGINDISABLED",sizeof(" LOGINDISABLED")-1);
 
+    *p1++ = CR; *p1++ = LF;
+    *p2++ = CR; *p2++ = LF;
+    *p3++ = CR; *p3++ = LF;
 
-    size += sizeof(" STARTTLS") - 1;
+    ngx_conf_merge_str_value(conf->greeting, prev->greeting, "");
+    if (conf->greeting.len == 0) {
+        conf->greeting = default_imap_greeting;
+    }
 
-    p = ngx_pnalloc(cf->pool, size);
+    p = ngx_pnalloc(cf->pool, conf->greeting.len + 2);
     if (p == NULL) {
         return NGX_CONF_ERROR;
     }
 
-    conf->starttls_capability.len = size;
-    conf->starttls_capability.data = p;
+    ngx_memcpy(p, conf->greeting.data, conf->greeting.len);
+    ngx_memcpy(p + conf->greeting.len, CRLF, sizeof(CRLF)-1);
 
-    p = ngx_cpymem(p, conf->capability.data,
-                   conf->capability.len - (sizeof(CRLF) - 1));
-    p = ngx_cpymem(p, " STARTTLS", sizeof(" STARTTLS") - 1);
-    *p++ = CR; *p = LF;
+    conf->greeting.data = p;
+    conf->greeting.len += 2;
 
+    size = sizeof ("* ID ()" CRLF) - 1;
 
-    size = (auth - conf->capability.data) + sizeof(CRLF) - 1
-            + sizeof(" STARTTLS LOGINDISABLED") - 1;
+    c = conf->id_params.elts;
+    for (i = 0; i < conf->id_params.nelts; ++i) {
+        if (!((c[i].len == 3) &&
+            (c[i].data[0] == 'n' || c[i].data[0] == 'N') &&
+            (c[i].data[1] == 'i' || c[i].data[1] == 'I') &&
+            (c[i].data[2] == 'l' || c[i].data[2] == 'L'))
+           )
+        {
+            size += 2;      // for enclosing quotes
+        }
+
+        size += c[i].len;
+        size += 1;          // for following SP
+    }
+
+    if (conf->id_params.nelts > 0) {
+        --size;                 // no SP follows the last parameter
+    } else {
+        size = size - 2 + 3;    // take away the () and put nil
+    }
 
     p = ngx_pnalloc(cf->pool, size);
     if (p == NULL) {
         return NGX_CONF_ERROR;
     }
 
-    conf->starttls_only_capability.len = size;
-    conf->starttls_only_capability.data = p;
 
-    p = ngx_cpymem(p, conf->capability.data,
-                   auth - conf->capability.data);
-    p = ngx_cpymem(p, " STARTTLS LOGINDISABLED",
-                   sizeof(" STARTTLS LOGINDISABLED") - 1);
+    conf->id.len = size;
+    conf->id.data = p;
+
+    p = ngx_cpymem (p, "* ID ", sizeof ("* ID ") -1);
+
+    if (conf->id_params.nelts > 0)
+    {
+        *p++ = '(';
+
+        for (i = 0; i < conf->id_params.nelts; ++i)
+        {
+            if (!((c[i].len == 3) &&
+                (c[i].data[0] == 'n' || c[i].data[0] == 'N') &&
+                (c[i].data[1] == 'i' || c[i].data[1] == 'I') &&
+                (c[i].data[2] == 'l' || c[i].data[2] == 'L'))
+               )
+            {
+                *p++ = '"';
+                p = ngx_cpymem(p, c[i].data, c[i].len);
+                *p++ = '"';
+            }
+            else
+            {
+                p = ngx_cpymem(p, c[i].data, c[i].len);
+            }
+
+            if (i < conf->id_params.nelts - 1)
+                *p++ = ' ';
+        }
+
+        *p++ = ')';
+    }
+    else
+    {
+        p = ngx_cpymem (p, "nil", sizeof("nil") - 1);
+    }
+
     *p++ = CR; *p = LF;
+    ngx_conf_merge_value (conf->literalauth, prev->literalauth,1);
+    ngx_conf_merge_str_value (conf->ua_name, prev->ua_name, "ZCS");
+    ngx_conf_merge_str_value (conf->ua_version, prev->ua_version, "Unknown Version");
 
     return NGX_CONF_OK;
 }
+
+static char *
+ngx_mail_imap_id (ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+    ngx_mail_imap_srv_conf_t  *iscf;
+    ngx_str_t   *c, *value, *elt;
+    ngx_uint_t  i;
+    ngx_array_t *a;
+
+    iscf = (ngx_mail_imap_srv_conf_t *)conf;
+
+    value = cf->args->elts;
+
+    if (cf->args->nelts % 2 == 0)
+    {
+        // ID response must contain id param field-value pairs
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "unmatched pair in IMAP ID string: %V",
+            value + cf->args->nelts - 1);
+
+        return NGX_CONF_ERROR;
+    }
+    else
+    {
+        a = (ngx_array_t *) (p + cmd->offset);
+        for (i = 1; i < cf->args->nelts; ++i)
+        {
+            c = ngx_array_push (a);
+            if (c == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *c = value[i];
+        }
+
+        for (i = 0; i < a->nelts; i += 2 ) {
+            elt = ((ngx_str_t *) a->elts + i);
+            if (elt->len == sizeof ("NAME") - 1 &&
+                (elt->data[0] == 'N' || elt->data[0] == 'n') &&
+                (elt->data[1] == 'A' || elt->data[1] == 'a') &&
+                (elt->data[2] == 'M' || elt->data[2] == 'm') &&
+                (elt->data[3] == 'E' || elt->data[0] == 'e')) {
+                iscf->ua_name = *(elt + 1);
+            }else if (elt->len == sizeof ("VERSION") - 1 &&
+                (elt->data[0] == 'V' || elt->data[0] == 'v') &&
+                (elt->data[1] == 'E' || elt->data[1] == 'e') &&
+                (elt->data[2] == 'R' || elt->data[2] == 'r') &&
+                (elt->data[3] == 'S' || elt->data[3] == 's') &&
+                (elt->data[4] == 'I' || elt->data[4] == 'i') &&
+                (elt->data[5] == 'O' || elt->data[5] == 'o') &&
+                (elt->data[6] == 'N' || elt->data[6] == 'n')) {
+                iscf->ua_version = *(elt + 1);
+            }
+        }
+
+        return NGX_CONF_OK;
+    }
+}
diff --git a/src/mail/ngx_mail_imap_module.h b/src/mail/ngx_mail_imap_module.h
index 131b44597..e45747ef7 100644
--- a/src/mail/ngx_mail_imap_module.h
+++ b/src/mail/ngx_mail_imap_module.h
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #ifndef _NGX_MAIL_IMAP_MODULE_H_INCLUDED_
 #define _NGX_MAIL_IMAP_MODULE_H_INCLUDED_
@@ -24,6 +28,15 @@ typedef struct {
     ngx_uint_t   auth_methods;
 
     ngx_array_t  capabilities;
+
+    ngx_array_t  id_params;
+    ngx_str_t    id;
+
+    ngx_str_t    ua_name;    /* user agent name coming from ID field "NAME" */
+    ngx_str_t    ua_version; /* user agent version coming from ID field "VERSION" */
+
+    ngx_flag_t   literalauth;
+    ngx_str_t    greeting;
 } ngx_mail_imap_srv_conf_t;
 
 
diff --git a/src/mail/ngx_mail_parse.c b/src/mail/ngx_mail_parse.c
index 2c2cdffa1..d335caf0f 100644
--- a/src/mail/ngx_mail_parse.c
+++ b/src/mail/ngx_mail_parse.c
@@ -4,6 +4,9 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -14,19 +17,100 @@
 #include <ngx_mail_smtp_module.h>
 
 
+static ngx_int_t ngx_mail_imap_parse_id_params(ngx_mail_session_t *s, u_char *p);
+
+typedef enum {
+    swi_start = 0,
+    swi_spaces_before_command,
+    swi_command,
+    swi_spaces_before_argument,
+    swi_argument,
+    swi_backslash,
+    swi_literal,
+    swi_no_sync_literal_argument,
+    swi_start_literal_argument,
+    swi_literal_argument,
+    swi_end_literal_argument,
+    swi_almost_done,
+    swi_begin_idparams = 15,
+    swi_end_idparams,
+    swi_done_idparams,
+    swi_almost_done_idparams,
+    swi_begin_idfield,
+    swi_id_n,
+    swi_id_ni,
+    swi_id_nil,
+    swi_idfield,
+    swi_idfield_len,
+    swi_idfield_len_plus,
+    swi_begin_idfield_l,
+    swi_idfield_l,
+    swi_SP_before_idvalue,
+    swi_X_before_idfield,
+    swi_begin_idvalue,
+    swi_idvalue,
+    swi_idvalue_n,
+    swi_idvalue_ni,
+    swi_idvalue_nil,
+    swi_idvalue_len,
+    swi_idvalue_len_plus,
+    swi_begin_idvalue_l,
+    swi_idvalue_l,
+} ngx_imap_parse_state_e;
+
+typedef enum {
+    swp_start = 0,
+    swp_spaces_before_argument,
+    swp_argument,
+    swp_almost_done
+} ngx_pop3_parse_state_e;
+
+typedef enum {
+    sws_start = 0,
+    sws_command,
+    sws_invalid,
+    sws_spaces_before_argument,
+    sws_argument,
+    sws_almost_done
+} ngx_smtp_parse_state_e;
+
+inline void ngx_mail_set_imap_parse_state_start(ngx_mail_session_t * s) {
+    s->state = swi_start;
+}
+
+inline void ngx_mail_set_pop3_parse_state_start(ngx_mail_session_t * s) {
+    s->state = swp_start;
+}
+
+inline void ngx_mail_set_smtp_parse_state_start(ngx_mail_session_t * s) {
+    s->state = sws_start;
+}
+
+inline void ngx_mail_set_imap_parse_state_argument(ngx_mail_session_t * s) {
+    s->state = swi_argument;
+}
+
+inline void ngx_mail_set_pop3_parse_state_argument(ngx_mail_session_t * s) {
+    s->state = swp_argument;
+}
+
+inline void ngx_mail_set_smtp_parse_state_argument(ngx_mail_session_t * s) {
+    s->state = sws_argument;
+}
+
+inline void ngx_mail_reset_parse_buffer(ngx_mail_session_t * s) {
+    s->buffer->pos = s->buffer->start;
+    s->buffer->last = s->buffer->start;
+}
+
+
 ngx_int_t
 ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
 {
     u_char      ch, *p, *c, c0, c1, c2, c3;
     ngx_str_t  *arg;
-    enum {
-        sw_start = 0,
-        sw_spaces_before_argument,
-        sw_argument,
-        sw_almost_done
-    } state;
 
-    state = s->state;
+    ngx_pop3_parse_state_e state = s->state;
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         ch = *p;
@@ -34,7 +118,7 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
         switch (state) {
 
         /* POP3 command */
-        case sw_start:
+        case swp_start:
             if (ch == ' ' || ch == CR || ch == LF) {
                 c = s->buffer->start;
 
@@ -87,10 +171,10 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = swp_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swp_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -104,12 +188,12 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
 
             break;
 
-        case sw_spaces_before_argument:
+        case swp_spaces_before_argument:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                state = sw_almost_done;
+                state = swp_almost_done;
                 s->arg_end = p;
                 break;
             case LF:
@@ -117,7 +201,7 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
                 goto done;
             default:
                 if (s->args.nelts <= 2) {
-                    state = sw_argument;
+                    state = swp_argument;
                     s->arg_start = p;
                     break;
                 }
@@ -125,7 +209,7 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
             }
             break;
 
-        case sw_argument:
+        case swp_argument:
             switch (ch) {
 
             case ' ':
@@ -155,10 +239,10 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = swp_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swp_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -170,7 +254,7 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)
             }
             break;
 
-        case sw_almost_done:
+        case swp_almost_done:
             switch (ch) {
             case LF:
                 goto done;
@@ -199,40 +283,523 @@ done:
         s->arg_start = NULL;
     }
 
-    s->state = (s->command != NGX_POP3_AUTH) ? sw_start : sw_argument;
-
     return NGX_OK;
 
 invalid:
 
-    s->state = sw_start;
+    s->state = swp_start;
     s->arg_start = NULL;
 
     return NGX_MAIL_PARSE_INVALID_COMMAND;
 }
 
+static ngx_int_t
+ngx_mail_imap_parse_id_params(ngx_mail_session_t *s, u_char *p)
+{
+    u_char ch;
+    ngx_imap_parse_state_e state;
+    ngx_str_t *arg;
+    state = s->state;
+
+    for (; p < s->buffer->last; p++) {
+        ch = *p;
+        switch(state) {
+        case swi_begin_idparams:
+            switch (ch) {
+                case '(':
+                    state = swi_begin_idfield;
+                    break;
+                case 'n':
+                case 'N':
+                    state = swi_id_n;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idparams: expected (/n/N, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_end_idparams:
+            switch (ch)
+            {
+                case ')':
+                    state = swi_done_idparams;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_end_idparams: expected ), got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+
+            break;
+
+        case swi_done_idparams:
+            switch (ch)
+            {
+                case CR:
+                    state = swi_almost_done;
+                    break;
+                case LF:
+                    return NGX_OK;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_done_idparams: expected CR/LF, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_id_n:
+            switch (ch) {
+                case 'i':
+                case 'I':
+                    state = swi_id_ni;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_id_n: expected i/I, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_id_ni:
+            switch (ch) {
+                case 'l':
+                case 'L':
+                    state = swi_id_nil;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_id_ni: expected l/L, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_id_nil:
+            switch (ch) {
+                case CR:
+                    state = swi_almost_done;
+                    break;
+                case LF:
+                    return NGX_OK;
+                default:
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_begin_idfield:
+            switch (ch) {
+                case '{':
+                    s->literal_len = 0;
+                    state = swi_idfield_len;
+                    break;
+                case '"':
+                    s->quoted = 1;
+                    s->backslash = 0;
+                    s->arg_start = p+1;
+                    state = swi_idfield;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idfield: expected \"/{, got '%c'", ch);
+                     return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idfield_len:
+            if (ch >= '0' && ch <= '9') {
+                s->literal_len = s->literal_len * 10 + (ch - '0');
+                break;
+            }
+            if (ch == '+') {
+                state = swi_idfield_len_plus; //  literalplus stuff
+                break;
+            }
+            if (ch == '}') {
+                s->no_sync_literal = 0;
+                state = swi_begin_idfield_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idfield_len: expected 0-9/+/}, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_idfield_len_plus:
+            if (ch == '}') {
+                s->no_sync_literal = 1;
+                state = swi_begin_idfield_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idfield_len_plus: expected }, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_begin_idfield_l:
+            switch (ch)
+            {
+                case CR:
+                    break;
+                case LF:
+                    if (s->literal_len) {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = p + 1;
+                        state = swi_idfield_l;
+                    } else {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = NULL;
+                        arg = ngx_array_push (&s->args);
+                        if (arg == NULL) { return NGX_ERROR; }
+                        arg->data = (u_char *)"";
+                        arg->len = 0;
+                        state = swi_SP_before_idvalue;
+                    }
+                    if (s->no_sync_literal == 1) {
+                        s->no_sync_literal = 0;
+                        break;
+                    } else {
+                        s->state = state;
+                        return NGX_IMAP_NEXT;
+                    }
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idfield_l: expected CR/LF, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idfield_l:
+            if (s->literal_len && --s->literal_len) {
+                break;
+            }
+
+            arg = ngx_array_push (&s->args);
+            if (arg == NULL) {
+                return NGX_ERROR;
+            }
+
+            arg->len = p + 1 - s->arg_start;
+            arg->data = s->arg_start;
+            s->arg_start = NULL;
+            state = swi_SP_before_idvalue;
+            break;
+
+        case swi_idfield:
+            switch (ch) {
+                case '\\':
+                    if (!s->backslash) {
+                        s->backslash = 1;
+                    } else {
+                        if (ch == '\\' && ch == '"')
+                            s->backslash = 0;
+                        else {
+                            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,
+                              s->connection->log, 0,
+                              "swi_idfield: \\ escapes non-quoted special '%c'",
+                              ch);
+                            return NGX_MAIL_PARSE_INVALID_COMMAND;
+                        }
+                    }
+                    break;
+
+                case '"':
+                    if (s->backslash) {
+                        s->backslash = 0;
+                        break;
+                    }
+                    s->quoted = 0;
+                    arg = ngx_array_push(&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+
+                    arg->len = p - s->arg_start;
+                    arg->data = s->arg_start;
+                    s->arg_start = NULL;
+                    state = swi_SP_before_idvalue;
+                    break;
+
+                case CR:
+                case LF:
+                    ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idfield: CR/LF breaks id field");
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+                default:
+                    break;
+            }
+            break;
+
+        case swi_begin_idvalue:
+            switch (ch)
+            {
+                case '"':
+                    s->quoted = 1;
+                    s->backslash = 0;
+                    s->arg_start = p+1;
+                    state = swi_idvalue;
+                    break;
+                case 'n':
+                case 'N':
+                    state = swi_idvalue_n;
+                    break;
+                case '{':
+                    s->literal_len = 0;
+                    state = swi_idvalue_len;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idvalue: expected \"/n/N/{, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_len:
+            if (ch >= '0' && ch <= '9') {
+                s->literal_len = s->literal_len + (ch - '0');
+                break;
+            }
+            if (ch == '+') {
+                state = swi_idvalue_len_plus;
+                break;
+            }
+            if (ch == '}') {
+                s->no_sync_literal = 0;
+                state = swi_begin_idvalue_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idvalue_len: expected 0-9/}, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_idvalue_len_plus:
+            if (ch == '}') {
+                s->no_sync_literal = 1;
+                state = swi_begin_idvalue_l;
+                break;
+            }
+            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                "swi_idvalue_len_plus: expected }, got '%c'", ch);
+            return NGX_MAIL_PARSE_INVALID_COMMAND;
+
+        case swi_begin_idvalue_l:
+            switch (ch)
+            {
+                case CR:
+                    break;
+                case LF:
+                    if (s->literal_len) {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = p + 1;
+                        state = swi_idvalue_l;
+                    } else {
+                        s->buffer->pos = p + 1;
+                        s->arg_start = NULL;
+                        arg = ngx_array_push (&s->args);
+                        if (arg == NULL) { return NGX_ERROR; }
+                        arg->data = (u_char *)"";
+                        arg->len = 0;
+                        state = swi_X_before_idfield;
+                    }
+                    if (s->no_sync_literal == 1) {
+                        s->no_sync_literal = 0;
+                        break;
+                    } else {
+                        s->state = state;
+                        return NGX_IMAP_NEXT;
+                    }
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_begin_idvalue_l: expected CR/LF, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_l:
+            if (s->literal_len && --s->literal_len) {
+                break;
+            }
+
+            arg = ngx_array_push (&s->args);
+            if (arg == NULL) {
+                return NGX_ERROR;
+            }
+
+            arg->len = p + 1 - s->arg_start;
+            arg->data = s->arg_start;
+            s->arg_start = NULL;
+            state = swi_X_before_idfield;
+            break;
+
+        case swi_idvalue_n:
+            switch (ch)
+            {
+                case 'i':
+                case 'I':
+                    state = swi_idvalue_ni;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue_n: expected i/I, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_ni:
+            switch (ch)
+            {
+                case 'l':
+                case 'L':
+                    state = swi_idvalue_nil;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue_ni: expected l/L, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue_nil:
+            switch (ch)
+            {
+                case ' ':
+                    state = swi_begin_idfield;
+                    arg = ngx_array_push (&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+                    arg->data = (u_char *)"";
+                    arg->len = 0;
+                    break;
+                case ')':
+                    state = swi_done_idparams;
+                    arg = ngx_array_push (&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+                    arg->data = (u_char *)"";
+                    arg->len = 0;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue_nil: expected SP/), got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_SP_before_idvalue:
+            switch (ch)
+            {
+                case ' ':
+                    state = swi_begin_idvalue;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_SP_before_idvalue: expected SP, got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_X_before_idfield:
+            switch (ch)
+            {
+                case ' ':
+                    state = swi_begin_idfield;
+                    break;
+                case ')':
+                    state = swi_done_idparams;
+                    break;
+                default:
+                    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_X_before_idfield: expected SP/), got '%c'", ch);
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+            break;
+
+        case swi_idvalue:
+            switch (ch)
+            {
+                case '\\':
+                    if (!s->backslash) {
+                        s->backslash = 1;
+                    } else {
+                        if (ch == '\\' || ch == '"')
+                            s->backslash = 0;
+                        else {
+                            ngx_log_debug1 (NGX_LOG_DEBUG_MAIL,
+                              s->connection->log, 0,
+                              "swi_idvalue: \\ escapes non-quoted special '%c'",
+                              ch);
+                            return NGX_MAIL_PARSE_INVALID_COMMAND;
+                        }
+                    }
+                    break;
+
+                case '"':
+                    if (s->backslash)
+                    {
+                        s->backslash = 0;
+                        break;
+                    }
+                    s->quoted = 0;
+                    arg = ngx_array_push (&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+
+                    arg->len = p - s->arg_start;
+                    arg->data = s->arg_start;
+                    s->arg_start = NULL;
+                    state = swi_X_before_idfield;
+                    break;
+
+                case CR:
+                case LF:
+                    ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                        "swi_idvalue: CR/LF breaks id value");
+                    return NGX_MAIL_PARSE_INVALID_COMMAND;
+                default:
+                    break;
+            }
+            break;
+        case swi_almost_done:
+            switch (ch) {
+            case LF:
+                return NGX_OK;
+            default:
+                return NGX_MAIL_PARSE_INVALID_COMMAND;
+            }
+
+         default:
+             break; /* for avoid warning only */
+         } /* switch (state) */
+     } /* for */
+
+     s->buffer->pos = p;
+     s->state = state;
+
+     return NGX_AGAIN;
+ }
 
 ngx_int_t
 ngx_mail_imap_parse_command(ngx_mail_session_t *s)
 {
     u_char      ch, *p, *c;
+    ngx_int_t   rc;
     ngx_str_t  *arg;
-    enum {
-        sw_start = 0,
-        sw_spaces_before_command,
-        sw_command,
-        sw_spaces_before_argument,
-        sw_argument,
-        sw_backslash,
-        sw_literal,
-        sw_no_sync_literal_argument,
-        sw_start_literal_argument,
-        sw_literal_argument,
-        sw_end_literal_argument,
-        sw_almost_done
-    } state;
+    p = NULL; /* for avoid warning */
+    ngx_imap_parse_state_e state = s->state;
+
+    if(state >= swi_begin_idparams) { /* beyond the states handled in ID parse function */
+        rc = ngx_mail_imap_parse_id_params(s, s->buffer->pos);
+        switch (rc) {
+        case NGX_OK:
+             goto done;
+        case NGX_MAIL_PARSE_INVALID_COMMAND:
+             goto invalid;
+        default: /* NGX_ERROR, NGX_AGAIN or NGX_IMAP_NEXT */
+             return rc;
+        }
+    }
 
-    state = s->state;
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         ch = *p;
@@ -240,46 +807,74 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
         switch (state) {
 
         /* IMAP tag */
-        case sw_start:
+        case swi_start:
             switch (ch) {
             case ' ':
-                s->tag.len = p - s->buffer->start + 1;
+                s->tag.len = p - s->buffer->start;
                 s->tag.data = s->buffer->start;
-                state = sw_spaces_before_command;
+                state = swi_spaces_before_command;
+                s->eargs = 0;
                 break;
-            case CR:
-                s->state = sw_start;
-                return NGX_MAIL_PARSE_INVALID_COMMAND;
-            case LF:
-                s->state = sw_start;
+            case CR: /* walk through */
+            case LF: /* walk through */
+            case '\x0':
+                s->tag.len = p - s->buffer->start;
+                s->tag.data = s->buffer->start;
+                s->state = swi_start;
                 return NGX_MAIL_PARSE_INVALID_COMMAND;
             }
             break;
 
-        case sw_spaces_before_command:
+        case swi_spaces_before_command:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                s->state = sw_start;
+                s->state = swi_start;
                 return NGX_MAIL_PARSE_INVALID_COMMAND;
             case LF:
-                s->state = sw_start;
+                s->state = swi_start;
+                return NGX_MAIL_PARSE_INVALID_COMMAND;
+            case '\x0':
+                s->state = swi_start;
                 return NGX_MAIL_PARSE_INVALID_COMMAND;
             default:
                 s->cmd_start = p;
-                state = sw_command;
+                state = swi_command;
                 break;
             }
             break;
 
-        case sw_command:
+        case swi_command:
             if (ch == ' ' || ch == CR || ch == LF) {
 
                 c = s->cmd_start;
 
                 switch (p - c) {
 
+                case 2:
+                    if ((c[0] == 'I' || c[0] == 'i')
+                        && (c[1] == 'D' || c[1] == 'd'))
+                    {
+                        s->command = NGX_IMAP_ID;
+                        /* RFC 2971 */
+                        ngx_int_t rc;
+                        s->state = swi_begin_idparams;
+                        p++; //move to the next character
+                        rc = ngx_mail_imap_parse_id_params(s, p);
+                        switch (rc) {
+                        case NGX_OK:
+                            goto done;
+                        case NGX_MAIL_PARSE_INVALID_COMMAND:
+                            goto invalid;
+                        default: /* NGX_ERROR or NGX_IMAP_NEXT */
+                            return rc;
+                        }
+                    } else {
+                        goto invalid;
+                    }
+                    break;
+
                 case 4:
                     if ((c[0] == 'N' || c[0] == 'n')
                         && (c[1] == 'O'|| c[1] == 'o')
@@ -287,7 +882,7 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                         && (c[3] == 'P'|| c[3] == 'p'))
                     {
                         s->command = NGX_IMAP_NOOP;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -301,7 +896,7 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                         && (c[4] == 'N'|| c[4] == 'n'))
                     {
                         s->command = NGX_IMAP_LOGIN;
-
+                        s->eargs = 2;
                     } else {
                         goto invalid;
                     }
@@ -316,7 +911,7 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                         && (c[5] == 'T'|| c[5] == 't'))
                     {
                         s->command = NGX_IMAP_LOGOUT;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -334,7 +929,7 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                         && (c[7] == 'S'|| c[7] == 's'))
                     {
                         s->command = NGX_IMAP_STARTTLS;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -354,7 +949,7 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                         && (c[9] == 'Y'|| c[9] == 'y'))
                     {
                         s->command = NGX_IMAP_CAPABILITY;
-
+                        s->eargs = 0;
                     } else {
                         goto invalid;
                     }
@@ -374,8 +969,12 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                         && (c[10] == 'T'|| c[10] == 't')
                         && (c[11] == 'E'|| c[11] == 'e'))
                     {
-                        s->command = NGX_IMAP_AUTHENTICATE;
-
+                        if (ch != ' ') {
+                            goto invalid;
+                        } else {
+                            s->command = NGX_IMAP_AUTHENTICATE;
+                            s->eargs = 1;
+                        }
                     } else {
                         goto invalid;
                     }
@@ -387,10 +986,13 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    if (s->command == NGX_IMAP_CAPABILITY) {
+                        goto invalid;
+                    }
+                    state = swi_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swi_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -404,42 +1006,48 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
 
             break;
 
-        case sw_spaces_before_argument:
+        case swi_spaces_before_argument:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                state = sw_almost_done;
+                if (s->args.nelts == 0) {
+                    goto invalid; //no argument
+                }
+                state = swi_almost_done;
                 s->arg_end = p;
                 break;
             case LF:
+                if ( s->args.nelts == 0) {
+                    goto invalid; // no argument
+                }
                 s->arg_end = p;
                 goto done;
             case '"':
-                if (s->args.nelts <= 2) {
+                if (s->args.nelts <= s->eargs) {
                     s->quoted = 1;
                     s->arg_start = p + 1;
-                    state = sw_argument;
+                    state = swi_argument;
                     break;
                 }
                 goto invalid;
             case '{':
-                if (s->args.nelts <= 2) {
-                    state = sw_literal;
+                if (s->args.nelts <= s->eargs) {
+                    state = swi_literal;
                     break;
                 }
                 goto invalid;
             default:
-                if (s->args.nelts <= 2) {
+                if (s->args.nelts <= s->eargs) {
                     s->arg_start = p;
-                    state = sw_argument;
+                    state = swi_argument;
                     break;
                 }
                 goto invalid;
             }
             break;
 
-        case sw_argument:
+        case swi_argument:
             if (ch == ' ' && s->quoted) {
                 break;
             }
@@ -465,10 +1073,10 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                 switch (ch) {
                 case '"':
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = swi_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = swi_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -477,46 +1085,52 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
             case '\\':
                 if (s->quoted) {
                     s->backslash = 1;
-                    state = sw_backslash;
+                    state = swi_backslash;
                 }
                 break;
             }
             break;
 
-        case sw_backslash:
+        case swi_backslash:
             switch (ch) {
             case CR:
             case LF:
                 goto invalid;
+            // (RFC3501)
+            // a backslash may only escape another backslash, or a double quote
+            case '\\':
+            case '"':
+                state = swi_argument;
+                break;
             default:
-                state = sw_argument;
+                goto invalid;
             }
             break;
 
-        case sw_literal:
+        case swi_literal:
             if (ch >= '0' && ch <= '9') {
                 s->literal_len = s->literal_len * 10 + (ch - '0');
                 break;
             }
             if (ch == '}') {
-                state = sw_start_literal_argument;
+                state = swi_start_literal_argument;
                 break;
             }
             if (ch == '+') {
-                state = sw_no_sync_literal_argument;
+                state = swi_no_sync_literal_argument;
                 break;
             }
             goto invalid;
 
-        case sw_no_sync_literal_argument:
+        case swi_no_sync_literal_argument:
             if (ch == '}') {
                 s->no_sync_literal = 1;
-                state = sw_start_literal_argument;
+                state = swi_start_literal_argument;
                 break;
             }
             goto invalid;
 
-        case sw_start_literal_argument:
+        case swi_start_literal_argument:
             switch (ch) {
             case CR:
                 break;
@@ -524,10 +1138,10 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
                 s->buffer->pos = p + 1;
                 s->arg_start = p + 1;
                 if (s->no_sync_literal == 0) {
-                    s->state = sw_literal_argument;
+                    s->state = swi_literal_argument;
                     return NGX_IMAP_NEXT;
                 }
-                state = sw_literal_argument;
+                state = swi_literal_argument;
                 s->no_sync_literal = 0;
                 break;
             default:
@@ -535,7 +1149,7 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
             }
             break;
 
-        case sw_literal_argument:
+        case swi_literal_argument:
             if (s->literal_len && --s->literal_len) {
                 break;
             }
@@ -547,36 +1161,38 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)
             arg->len = p + 1 - s->arg_start;
             arg->data = s->arg_start;
             s->arg_start = NULL;
-            state = sw_end_literal_argument;
+            state = swi_end_literal_argument;
 
             break;
 
-        case sw_end_literal_argument:
+        case swi_end_literal_argument:
             switch (ch) {
             case '{':
-                if (s->args.nelts <= 2) {
-                    state = sw_literal;
+                if (s->args.nelts <= s->eargs) {
+                    state = swi_literal;
                     break;
                 }
                 goto invalid;
             case CR:
-                state = sw_almost_done;
+                state = swi_almost_done;
                 break;
             case LF:
                 goto done;
             default:
-                state = sw_spaces_before_argument;
+                state = swi_spaces_before_argument;
                 break;
             }
             break;
 
-        case sw_almost_done:
+        case swi_almost_done:
             switch (ch) {
             case LF:
                 goto done;
             default:
                 goto invalid;
             }
+        default:
+            break; /* for avoid warning only */
         }
     }
 
@@ -604,13 +1220,11 @@ done:
         s->literal_len = 0;
     }
 
-    s->state = (s->command != NGX_IMAP_AUTHENTICATE) ? sw_start : sw_argument;
-
     return NGX_OK;
 
 invalid:
 
-    s->state = sw_start;
+    s->state = swi_start;
     s->quoted = 0;
     s->no_sync_literal = 0;
     s->literal_len = 0;
@@ -624,16 +1238,8 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
 {
     u_char      ch, *p, *c, c0, c1, c2, c3;
     ngx_str_t  *arg;
-    enum {
-        sw_start = 0,
-        sw_command,
-        sw_invalid,
-        sw_spaces_before_argument,
-        sw_argument,
-        sw_almost_done
-    } state;
 
-    state = s->state;
+    ngx_smtp_parse_state_e state = s->state;
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         ch = *p;
@@ -641,13 +1247,13 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
         switch (state) {
 
         /* SMTP command */
-        case sw_start:
+        case sws_start:
             s->cmd_start = p;
-            state = sw_command;
+            state = sws_command;
 
             /* fall through */
 
-        case sw_command:
+        case sws_command:
             if (ch == ' ' || ch == CR || ch == LF) {
                 c = s->cmd_start;
 
@@ -732,10 +1338,10 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = sws_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = sws_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -749,15 +1355,15 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
 
             break;
 
-        case sw_invalid:
+        case sws_invalid:
             goto invalid;
 
-        case sw_spaces_before_argument:
+        case sws_spaces_before_argument:
             switch (ch) {
             case ' ':
                 break;
             case CR:
-                state = sw_almost_done;
+                state = sws_almost_done;
                 s->arg_end = p;
                 break;
             case LF:
@@ -765,7 +1371,7 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
                 goto done;
             default:
                 if (s->args.nelts <= 10) {
-                    state = sw_argument;
+                    state = sws_argument;
                     s->arg_start = p;
                     break;
                 }
@@ -773,7 +1379,7 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
             }
             break;
 
-        case sw_argument:
+        case sws_argument:
             switch (ch) {
             case ' ':
             case CR:
@@ -788,10 +1394,10 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
 
                 switch (ch) {
                 case ' ':
-                    state = sw_spaces_before_argument;
+                    state = sws_spaces_before_argument;
                     break;
                 case CR:
-                    state = sw_almost_done;
+                    state = sws_almost_done;
                     break;
                 case LF:
                     goto done;
@@ -803,7 +1409,7 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)
             }
             break;
 
-        case sw_almost_done:
+        case sws_almost_done:
             switch (ch) {
             case LF:
                 goto done;
@@ -832,20 +1438,18 @@ done:
         s->arg_start = NULL;
     }
 
-    s->state = (s->command != NGX_SMTP_AUTH) ? sw_start : sw_argument;
-
     return NGX_OK;
 
 invalid:
 
-    s->state = sw_invalid;
+    s->state = sws_start;
     s->arg_start = NULL;
 
     /* skip invalid command till LF */
 
     for (p = s->buffer->pos; p < s->buffer->last; p++) {
         if (*p == LF) {
-            s->state = sw_start;
+            s->state = sws_start;
             p++;
             break;
         }
@@ -860,13 +1464,7 @@ invalid:
 ngx_int_t
 ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)
 {
-    ngx_str_t                 *arg;
-
-#if (NGX_MAIL_SSL)
-    if (ngx_mail_starttls_only(s, c)) {
-        return NGX_MAIL_PARSE_INVALID_COMMAND;
-    }
-#endif
+    ngx_str_t   *arg;
 
     if (s->args.nelts == 0) {
         return NGX_MAIL_PARSE_INVALID_COMMAND;
@@ -882,7 +1480,7 @@ ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)
                 return NGX_MAIL_AUTH_LOGIN;
             }
 
-            if (s->args.nelts == 2) {
+            if (s->args.nelts == 2) { //initial response
                 return NGX_MAIL_AUTH_LOGIN_USERNAME;
             }
 
@@ -895,8 +1493,22 @@ ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)
                 return NGX_MAIL_AUTH_PLAIN;
             }
 
-            if (s->args.nelts == 2) {
-                return ngx_mail_auth_plain(s, c, 1);
+            if (s->args.nelts == 2) { //initial response
+                return NGX_MAIL_AUTH_PLAIN_IR;
+            }
+        }
+
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+
+    if (arg[0].len == 6) {
+        if (ngx_strncasecmp(arg[0].data, (u_char *) "GSSAPI", 6) == 0 ) {
+            if (s->args.nelts == 1) {
+            	return NGX_MAIL_AUTH_GSSAPI;
+            }
+
+            if (s->args.nelts == 2) { //initial response
+            	return NGX_MAIL_AUTH_GSSAPI_IR;
             }
         }
 
@@ -928,5 +1540,5 @@ ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
-    return NGX_MAIL_PARSE_INVALID_COMMAND;
+    return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
 }
diff --git a/src/mail/ngx_mail_pop3_handler.c b/src/mail/ngx_mail_pop3_handler.c
index 9310c2750..305e1f6d5 100644
--- a/src/mail/ngx_mail_pop3_handler.c
+++ b/src/mail/ngx_mail_pop3_handler.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -21,13 +25,18 @@ static ngx_int_t ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c);
 static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);
 
 
-static u_char  pop3_greeting[] = "+OK POP3 ready" CRLF;
+/*static u_char  pop3_greeting[] = "+OK POP3 ready" CRLF; zimbra uses the greeting specified by the directive */
 static u_char  pop3_ok[] = "+OK" CRLF;
 static u_char  pop3_next[] = "+ " CRLF;
+static u_char  pop3_gssapi_next[] = "+ " CRLF;
 static u_char  pop3_username[] = "+ VXNlcm5hbWU6" CRLF;
 static u_char  pop3_password[] = "+ UGFzc3dvcmQ6" CRLF;
 static u_char  pop3_invalid_command[] = "-ERR invalid command" CRLF;
-
+static u_char  pop3_unsupported_mech[] = "-ERR mechanism not supported" CRLF;
+static u_char  pop3_nocleartext[] = "-ERR cleartext logins disabled" CRLF;
+static u_char  pop3_authaborted[] = "-ERR authentication aborted" CRLF;
+static u_char  pop3_login_failed[] = "-ERR invalid username/password" CRLF;
+static u_char  pop3_auth_failed[] = "-ERR line is too long" CRLF;
 
 void
 ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
@@ -47,20 +56,20 @@ ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
             return;
         }
 
-        s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_greeting) + s->salt.len);
+        s->out.data = ngx_pnalloc(c->pool, pscf->greeting.len + s->salt.len - 1);
         if (s->out.data == NULL) {
             ngx_mail_session_internal_server_error(s);
             return;
         }
 
-        p = ngx_cpymem(s->out.data, pop3_greeting, sizeof(pop3_greeting) - 3);
+        p = ngx_cpymem(s->out.data, pscf->greeting.data, pscf->greeting.len - 2);
         *p++ = ' ';
         p = ngx_cpymem(p, s->salt.data, s->salt.len);
 
         s->out.len = p - s->out.data;
 
     } else {
-        ngx_str_set(&s->out, pop3_greeting);
+        s->out = pscf->greeting;
     }
 
     c->read->handler = ngx_mail_pop3_init_protocol;
@@ -80,6 +89,7 @@ ngx_mail_pop3_init_protocol(ngx_event_t *rev)
 {
     ngx_connection_t    *c;
     ngx_mail_session_t  *s;
+    ngx_mail_pop3_srv_conf_t  *pscf;
 
     c = rev->data;
 
@@ -102,13 +112,16 @@ ngx_mail_pop3_init_protocol(ngx_event_t *rev)
             return;
         }
 
-        s->buffer = ngx_create_temp_buf(c->pool, 128);
+        pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);
+
+        s->buffer = ngx_create_temp_buf(c->pool, pscf->client_buffer_size);
         if (s->buffer == NULL) {
             ngx_mail_session_internal_server_error(s);
             return;
         }
     }
 
+    ngx_mail_set_pop3_parse_state_start(s);
     s->mail_state = ngx_pop3_start;
     c->read->handler = ngx_mail_pop3_auth_state;
 
@@ -160,6 +173,7 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)
 
             case NGX_POP3_USER:
                 rc = ngx_mail_pop3_user(s, c);
+                s->mail_state = ngx_pop3_user;
                 break;
 
             case NGX_POP3_CAPA:
@@ -198,6 +212,7 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)
 
             case NGX_POP3_PASS:
                 rc = ngx_mail_pop3_pass(s, c);
+                s->mail_state = ngx_pop3_user;
                 break;
 
             case NGX_POP3_CAPA:
@@ -224,9 +239,10 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)
 
         case ngx_pop3_auth_login_username:
             rc = ngx_mail_auth_login_username(s, c, 0);
-
-            ngx_str_set(&s->out, pop3_password);
-            s->mail_state = ngx_pop3_auth_login_password;
+            if(rc == NGX_MAIL_AUTH_ARGUMENT) {
+                ngx_str_set(&s->out, pop3_password);
+                s->mail_state = ngx_pop3_auth_login_password;
+            }
             break;
 
         case ngx_pop3_auth_login_password:
@@ -244,39 +260,84 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)
         case ngx_pop3_auth_external:
             rc = ngx_mail_auth_external(s, c, 0);
             break;
+
+        case ngx_pop3_auth_gssapi:
+            {
+                ngx_str_t output;
+                ngx_str_set(&output, "");
+                rc = ngx_mail_auth_gssapi(s, c, &output);
+                if (rc == NGX_MAIL_AUTH_ARGUMENT) {
+                    s->mail_state = ngx_pop3_auth_gssapi;
+                    s->out = output;
+                }
+                break;
+            }
         }
     }
 
     switch (rc) {
 
     case NGX_DONE:
-        ngx_mail_auth(s, c);
+        ngx_mail_do_auth(s, c);
         return;
 
+    case NGX_OK:
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
+
+    case NGX_MAIL_AUTH_ABORT:
+        ngx_str_set(&s->out, pop3_authaborted);
+        s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
+
     case NGX_ERROR:
         ngx_mail_session_internal_server_error(s);
         return;
 
-    case NGX_MAIL_PARSE_INVALID_COMMAND:
+    case NGX_MAIL_LOGIN_FAILED:
+        ngx_str_set(&s->out, pop3_login_failed);
         s->mail_state = ngx_pop3_start;
-        s->state = 0;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
 
-        ngx_str_set(&s->out, pop3_invalid_command);
+    case NGX_MAIL_AUTH_FAILED:
+        ngx_str_set(&s->out, pop3_auth_failed);
+        s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
+
+    case NGX_MAIL_PARSE_INVALID_AUTH_MECH:
+        ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, c->log, 0,
+            "unsupported POP auth mechanism");
+        ngx_str_set(&s->out, pop3_unsupported_mech);
+        s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
 
-        /* fall through */
+    case NGX_MAIL_PARSE_INVALID_COMMAND:
+        ngx_str_set(&s->out, pop3_invalid_command);
+    	s->mail_state = ngx_pop3_start;
+        s->arg_start = NULL;
+        ngx_mail_set_pop3_parse_state_start(s);
+        break;
 
-    case NGX_OK:
+    case NGX_MAIL_AUTH_ARGUMENT:
+        s->arg_start = s->buffer->start;
+        ngx_mail_set_pop3_parse_state_argument(s);
+        break;
 
-        s->args.nelts = 0;
-        s->buffer->pos = s->buffer->start;
-        s->buffer->last = s->buffer->start;
+    }
 
-        if (s->state) {
-            s->arg_start = s->buffer->start;
-        }
+    s->args.nelts = 0;
+    ngx_mail_reset_parse_buffer(s);
 
-        ngx_mail_send(c->write);
-    }
+    ngx_mail_send(c->write);
 }
 
 static ngx_int_t
@@ -286,6 +347,7 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)
 
 #if (NGX_MAIL_SSL)
     if (ngx_mail_starttls_only(s, c)) {
+        ngx_str_set(&s->out, pop3_nocleartext);
         return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 #endif
@@ -295,6 +357,10 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)
     }
 
     arg = s->args.elts;
+    if(arg[0].len > NGX_MAIL_MAX_LOGIN_LEN) {
+        ngx_str_null(&s->login);
+        return NGX_OK;
+    }
     s->login.len = arg[0].len;
     s->login.data = ngx_pnalloc(c->pool, s->login.len);
     if (s->login.data == NULL) {
@@ -306,8 +372,6 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
                    "pop3 login: \"%V\"", &s->login);
 
-    s->mail_state = ngx_pop3_user;
-
     return NGX_OK;
 }
 
@@ -322,6 +386,10 @@ ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)
     }
 
     arg = s->args.elts;
+
+    if (s->login.len == 0 || arg[0].len > NGX_MAIL_MAX_PASSWORD_LEN) {
+        return NGX_MAIL_LOGIN_FAILED;
+    }
     s->passwd.len = arg[0].len;
     s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);
     if (s->passwd.data == NULL) {
@@ -332,10 +400,13 @@ ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)
 
 #if (NGX_DEBUG_MAIL_PASSWD)
     ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,
-                   "pop3 passwd: \"%V\"", &s->passwd);
+                                   "pop3 passwd: \"%V\"", &s->passwd);
 #endif
 
-    return NGX_DONE;
+     s->auth_method = NGX_MAIL_AUTH_PASSWD;
+     s->usedauth = 0;
+
+     return NGX_DONE;
 }
 
 
@@ -349,7 +420,7 @@ ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c, ngx_int_t stls)
 #if (NGX_MAIL_SSL)
 
     if (stls && c->ssl == NULL) {
-        ngx_mail_ssl_conf_t  *sslcf;
+        ngx_mail_ssl_conf_t *sslcf;
 
         sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
 
@@ -435,6 +506,7 @@ ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)
                    "pop3 apop: \"%V\" \"%V\"", &s->login, &s->passwd);
 
     s->auth_method = NGX_MAIL_AUTH_APOP;
+    s->usedauth = 0;
 
     return NGX_DONE;
 }
@@ -454,11 +526,15 @@ ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)
 
     pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);
 
-    if (s->args.nelts == 0) {
-        s->out = pscf->auth_capability;
-        s->state = 0;
+//    if (s->args.nelts == 0) {
+//        s->out = pscf->auth_capability;
+//        s->state = 0;
+//
+//        return NGX_OK;
+//    }
 
-        return NGX_OK;
+    if (s->args.nelts == 0) {
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
     }
 
     rc = ngx_mail_auth_parse(s, c);
@@ -466,35 +542,68 @@ ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)
     switch (rc) {
 
     case NGX_MAIL_AUTH_LOGIN:
-
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, pop3_username);
         s->mail_state = ngx_pop3_auth_login_username;
-
-        return NGX_OK;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
     case NGX_MAIL_AUTH_LOGIN_USERNAME:
-
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_LOGIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, pop3_password);
         s->mail_state = ngx_pop3_auth_login_password;
-
-        return ngx_mail_auth_login_username(s, c, 1);
+        return ngx_mail_auth_login_username(s, c, 0);
 
     case NGX_MAIL_AUTH_PLAIN:
-
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
         ngx_str_set(&s->out, pop3_next);
         s->mail_state = ngx_pop3_auth_plain;
+        return NGX_MAIL_AUTH_ARGUMENT;
 
-        return NGX_OK;
+    case NGX_MAIL_AUTH_PLAIN_IR:
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        return ngx_mail_auth_plain(s, c, 1);
+
+    case NGX_MAIL_AUTH_GSSAPI:
+        if( !(pscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        ngx_str_set(&s->out, pop3_gssapi_next);
+        s->mail_state = ngx_pop3_auth_gssapi;
+        return NGX_MAIL_AUTH_ARGUMENT;
+
+    case NGX_MAIL_AUTH_GSSAPI_IR:
+
+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
+        }
+        s->mail_state = ngx_pop3_auth_gssapi;
+        ngx_str_t output;
+        ngx_str_set(&output, "");
+        int res = ngx_mail_auth_gssapi(s, c, &output);
+        if(res == NGX_MAIL_AUTH_ARGUMENT) {
+            s->out = output;
+            return NGX_MAIL_AUTH_ARGUMENT;
+        } else {
+            return res;
+        }
 
     case NGX_MAIL_AUTH_CRAM_MD5:
 
         if (!(pscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {
-            return NGX_MAIL_PARSE_INVALID_COMMAND;
+            return NGX_MAIL_PARSE_INVALID_AUTH_MECH;
         }
 
         if (ngx_mail_auth_cram_md5_salt(s, c, "+ ", 2) == NGX_OK) {
             s->mail_state = ngx_pop3_auth_cram_md5;
-            return NGX_OK;
+            return NGX_MAIL_AUTH_ARGUMENT;
         }
 
         return NGX_ERROR;
@@ -509,6 +618,9 @@ ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)
         s->mail_state = ngx_pop3_auth_external;
 
         return NGX_OK;
+
+    default:
+        break;
     }
 
     return rc;
diff --git a/src/mail/ngx_mail_pop3_module.c b/src/mail/ngx_mail_pop3_module.c
index a67307073..c7ab3213a 100644
--- a/src/mail/ngx_mail_pop3_module.c
+++ b/src/mail/ngx_mail_pop3_module.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -16,6 +20,7 @@ static void *ngx_mail_pop3_create_srv_conf(ngx_conf_t *cf);
 static char *ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent,
     void *child);
 
+static ngx_str_t default_pop3_greeting = ngx_string("+OK POP3 ready");
 
 static ngx_str_t  ngx_mail_pop3_default_capabilities[] = {
     ngx_string("TOP"),
@@ -28,8 +33,10 @@ static ngx_str_t  ngx_mail_pop3_default_capabilities[] = {
 static ngx_conf_bitmask_t  ngx_mail_pop3_auth_methods[] = {
     { ngx_string("plain"), NGX_MAIL_AUTH_PLAIN_ENABLED },
     { ngx_string("apop"), NGX_MAIL_AUTH_APOP_ENABLED },
+    { ngx_string("login"), NGX_MAIL_AUTH_LOGIN_ENABLED },
     { ngx_string("cram-md5"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },
     { ngx_string("external"), NGX_MAIL_AUTH_EXTERNAL_ENABLED },
+    { ngx_string("gssapi"), NGX_MAIL_AUTH_GSSAPI_ENABLED },
     { ngx_null_string, 0 }
 };
 
@@ -56,11 +63,18 @@ static ngx_mail_protocol_t  ngx_mail_pop3_protocol = {
 
     ngx_string("-ERR internal server error" CRLF),
     ngx_string("-ERR SSL certificate error" CRLF),
-    ngx_string("-ERR No required SSL certificate" CRLF)
+    ngx_string("-ERR No required SSL certificate" CRLF),
+    ngx_string("")
 };
 
 
 static ngx_command_t  ngx_mail_pop3_commands[] = {
+    { ngx_string("pop3_client_buffer"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_pop3_srv_conf_t, client_buffer_size),
+      NULL },
 
     { ngx_string("pop3_capabilities"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
@@ -76,6 +90,13 @@ static ngx_command_t  ngx_mail_pop3_commands[] = {
       offsetof(ngx_mail_pop3_srv_conf_t, auth_methods),
       &ngx_mail_pop3_auth_methods },
 
+    { ngx_string("pop3_greeting"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_pop3_srv_conf_t, greeting),
+      NULL },
+
       ngx_null_command
 };
 
@@ -117,6 +138,8 @@ ngx_mail_pop3_create_srv_conf(ngx_conf_t *cf)
         return NULL;
     }
 
+    pscf->client_buffer_size = NGX_CONF_UNSET_SIZE;
+
     if (ngx_array_init(&pscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))
         != NGX_OK)
     {
@@ -133,15 +156,25 @@ ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_mail_pop3_srv_conf_t *prev = parent;
     ngx_mail_pop3_srv_conf_t *conf = child;
 
-    u_char      *p;
+    u_char      *p, *p1, *p2, *p3;
+    size_t      s1, s2, s3;
     size_t       size, stls_only_size;
     ngx_str_t   *c, *d;
     ngx_uint_t   i, m;
 
+    ngx_conf_merge_size_value(conf->client_buffer_size,
+                              prev->client_buffer_size,
+                              (size_t) 4*ngx_pagesize);
+
     ngx_conf_merge_bitmask_value(conf->auth_methods,
                                  prev->auth_methods,
-                                 (NGX_CONF_BITMASK_SET
-                                  |NGX_MAIL_AUTH_PLAIN_ENABLED));
+                                 NGX_CONF_BITMASK_SET);
+
+    ngx_conf_merge_str_value(conf->greeting, prev->greeting,"");
+
+    if (conf->greeting.len == 0) {
+        conf->greeting = default_pop3_greeting;
+    }
 
     if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
         conf->auth_methods |= NGX_MAIL_AUTH_LOGIN_ENABLED;
@@ -163,23 +196,41 @@ ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         }
     }
 
-    size = sizeof("+OK Capability list follows" CRLF) - 1
-           + sizeof("." CRLF) - 1;
-
-    stls_only_size = size + sizeof("STLS" CRLF) - 1;
+    s1 = sizeof("+OK Capability list follows" CRLF) - 1
+         + sizeof("." CRLF)-1;
+    if (conf->auth_methods &
+        (NGX_MAIL_AUTH_PLAIN_ENABLED | NGX_MAIL_AUTH_GSSAPI_ENABLED)){
+         s1 += sizeof("SASL" CRLF)-1;
+    }
+    s2 = s1;
+    s3 = s1;
 
     c = conf->capabilities.elts;
     for (i = 0; i < conf->capabilities.nelts; i++) {
-        size += c[i].len + sizeof(CRLF) - 1;
+        s1 += c[i].len + sizeof(CRLF) - 1;
+        s2 += c[i].len + sizeof(CRLF) - 1;
 
         if (ngx_strcasecmp(c[i].data, (u_char *) "USER") == 0) {
+            s3 += c[i].len + sizeof(CRLF) - 1;
             continue;
         }
 
         stls_only_size += c[i].len + sizeof(CRLF) - 1;
     }
 
-    size += sizeof("SASL") - 1 + sizeof(CRLF) - 1;
+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+        s1 += sizeof(" PLAIN") - 1;
+        s2 += sizeof(" PLAIN") - 1;
+        s3 += sizeof(" PLAIN") - 1;
+    }
+    if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+        s1 += sizeof(" GSSAPI") - 1;
+        s2 += sizeof(" GSSAPI") - 1;
+        s3 += sizeof(" GSSAPI") - 1;
+    }
+
+    s2 += sizeof("STLS" CRLF) - 1;
+    s3 += sizeof("STLS" CRLF) - 1;
 
     for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
          m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;
@@ -199,17 +250,75 @@ ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
-    conf->capability.len = size;
-    conf->capability.data = p;
+    p1 = ngx_pnalloc(cf->pool,s1);
+    if (p1 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+    p2 = ngx_palloc(cf->pool,s2);
+    if (p2 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+    p3 = ngx_pnalloc(cf->pool,s3);
+    if (p3 == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    conf->capability.len = s1;
+    conf->capability.data = p1;
+    conf->starttls_capability.len = s2;
+    conf->starttls_capability.data = p2;
+    conf->starttls_only_capability.len = s3;
+    conf->starttls_only_capability.data = p3;
 
-    p = ngx_cpymem(p, "+OK Capability list follows" CRLF,
+    p1 = ngx_cpymem(p1, "+OK Capability list follows" CRLF,
                    sizeof("+OK Capability list follows" CRLF) - 1);
+    p2 = ngx_cpymem(p2, "+OK Capability list follows" CRLF,
+                    sizeof("+OK Capability list follows" CRLF) - 1);
+    p3 = ngx_cpymem(p3, "+OK Capability list follows" CRLF,
+                    sizeof("+OK Capability list follows" CRLF) - 1);
 
+    c = conf->capabilities.elts;
     for (i = 0; i < conf->capabilities.nelts; i++) {
-        p = ngx_cpymem(p, c[i].data, c[i].len);
-        *p++ = CR; *p++ = LF;
+        p1 = ngx_cpymem(p1, c[i].data, c[i].len);
+        p2 = ngx_cpymem(p2, c[i].data, c[i].len);
+        *p1++ = CR; *p1++ = LF;
+        *p2++ = CR; *p2++ = LF;
+        if (ngx_strcasecmp(c[i].data, (u_char *) "USER") != 0) {
+            p3 = ngx_cpymem(p3,c[i].data,c[i].len);
+            *p3++ = CR; *p3++ = LF;
+        }
     }
 
+    if (conf->auth_methods &
+        (NGX_MAIL_AUTH_PLAIN_ENABLED | NGX_MAIL_AUTH_GSSAPI_ENABLED)) {
+        p1 = ngx_cpymem(p1,"SASL",sizeof("SASL") - 1);
+        p2 = ngx_cpymem(p2,"SASL",sizeof("SASL") - 1);
+        p3 = ngx_cpymem(p3,"SASL",sizeof("SASL") - 1);
+
+        if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {
+            p1 = ngx_cpymem(p1," PLAIN",sizeof(" PLAIN") - 1);
+            p2 = ngx_cpymem(p2," PLAIN",sizeof(" PLAIN") - 1);
+            p3 = ngx_cpymem(p3," PLAIN",sizeof(" PLAIN") - 1);
+        }
+        if (conf->auth_methods & NGX_MAIL_AUTH_GSSAPI_ENABLED) {
+            p1 = ngx_cpymem(p1," GSSAPI",sizeof(" GSSAPI") - 1);
+            p2 = ngx_cpymem(p2," GSSAPI",sizeof(" GSSAPI") - 1);
+            p3 = ngx_cpymem(p3," GSSAPI",sizeof(" GSSAPI") - 1);
+        }
+
+        *p1++ = CR; *p1++ = LF;
+        *p2++ = CR; *p2++ = LF;
+        *p3++ = CR; *p3++ = LF;
+    }
+
+    p2 = ngx_cpymem(p2,"STLS" CRLF, sizeof("STLS" CRLF)-1);
+    p3 = ngx_cpymem(p3,"STLS" CRLF, sizeof("STLS" CRLF)-1);
+
+    *p1++ = '.'; *p1++ = CR; *p1++ = LF;
+    *p2++ = '.'; *p2++ = CR; *p2++ = LF;
+    *p3++ = '.'; *p3++ = CR; *p3++ = LF;
+
+    /* not required */
     p = ngx_cpymem(p, "SASL", sizeof("SASL") - 1);
 
     for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
@@ -294,29 +403,15 @@ ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
 
     *p++ = '.'; *p++ = CR; *p = LF;
 
-
-    p = ngx_pnalloc(cf->pool, stls_only_size);
+    p = ngx_pnalloc(cf->pool,conf->greeting.len + 2);
     if (p == NULL) {
         return NGX_CONF_ERROR;
     }
 
-    conf->starttls_only_capability.len = stls_only_size;
-    conf->starttls_only_capability.data = p;
-
-    p = ngx_cpymem(p, "+OK Capability list follows" CRLF,
-                   sizeof("+OK Capability list follows" CRLF) - 1);
-
-    for (i = 0; i < conf->capabilities.nelts; i++) {
-        if (ngx_strcasecmp(c[i].data, (u_char *) "USER") == 0) {
-            continue;
-        }
-
-        p = ngx_cpymem(p, c[i].data, c[i].len);
-        *p++ = CR; *p++ = LF;
-    }
-
-    p = ngx_cpymem(p, "STLS" CRLF, sizeof("STLS" CRLF) - 1);
-    *p++ = '.'; *p++ = CR; *p = LF;
+    ngx_memcpy(p, conf->greeting.data, conf->greeting.len);
+    ngx_memcpy(p + conf->greeting.len, CRLF, sizeof(CRLF) - 1);
+    conf->greeting.data = p;
+    conf->greeting.len += 2;
 
     return NGX_CONF_OK;
 }
diff --git a/src/mail/ngx_mail_pop3_module.h b/src/mail/ngx_mail_pop3_module.h
index 86947a772..090e9bc6b 100644
--- a/src/mail/ngx_mail_pop3_module.h
+++ b/src/mail/ngx_mail_pop3_module.h
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
+
 
 #ifndef _NGX_MAIL_POP3_MODULE_H_INCLUDED_
 #define _NGX_MAIL_POP3_MODULE_H_INCLUDED_
@@ -15,6 +19,8 @@
 
 
 typedef struct {
+    size_t       client_buffer_size;
+
     ngx_str_t    capability;
     ngx_str_t    starttls_capability;
     ngx_str_t    starttls_only_capability;
@@ -23,6 +29,8 @@ typedef struct {
     ngx_uint_t   auth_methods;
 
     ngx_array_t  capabilities;
+
+    ngx_str_t greeting;
 } ngx_mail_pop3_srv_conf_t;
 
 
diff --git a/src/mail/ngx_mail_proxy_module.c b/src/mail/ngx_mail_proxy_module.c
index 1c86e54cf..938bd36e9 100644
--- a/src/mail/ngx_mail_proxy_module.c
+++ b/src/mail/ngx_mail_proxy_module.c
@@ -4,19 +4,35 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2011]. All Rights Reserved.
+ */
 
+#include <nginx.h>
 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
 #include <ngx_event_connect.h>
 #include <ngx_mail.h>
+#include <ngx_mail_throttle_module.h>
+#include <ngx_mail_pop3_module.h>
+#include <ngx_mail_imap_module.h>
+#include <ngx_mail_smtp_module.h>
+#include <ngx_zm_lookup.h>
 
+extern ngx_module_t ngx_mail_auth_http_module;
 
 typedef struct {
     ngx_flag_t  enable;
     ngx_flag_t  pass_error_message;
+    ngx_flag_t  issue_pop3_xoip;
+    ngx_flag_t  issue_imap_id;
     ngx_flag_t  xclient;
+    ngx_flag_t  proxy_ssl;
+    ngx_flag_t  proxy_ssl_session_reuse;
+    ngx_ssl_t  *ssl;
     size_t      buffer_size;
+    ngx_msec_t  ctimeout;
     ngx_msec_t  timeout;
 } ngx_mail_proxy_conf_t;
 
@@ -36,6 +52,31 @@ static void *ngx_mail_proxy_create_conf(ngx_conf_t *cf);
 static char *ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent,
     void *child);
 
+#if (NGX_MAIL_SSL)
+static char *ngx_mail_proxy_ssl(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static void ngx_mail_proxy_ssl_init_connection(ngx_mail_session_t *s,
+        ngx_connection_t *c);
+static void ngx_mail_proxy_ssl_handshake(ngx_connection_t *c);
+/** TODO suport ssl session reuse
+static void ngx_mail_proxy_set_session(ngx_peer_connection_t *pc);
+static void ngx_mail_proxy_save_session(ngx_peer_connection_t *pc);
+*/
+#endif
+
+/* throttle */
+static void ngx_mail_proxy_throttle_imap(ngx_event_t *rev);
+static void ngx_mail_proxy_allow_imap(throttle_callback_t *callback);
+static void ngx_mail_proxy_choke_imap(throttle_callback_t *callback);
+static void ngx_mail_proxy_throttle_pop3(ngx_event_t *rev);
+static void ngx_mail_proxy_allow_pop3(throttle_callback_t *callback);
+static void ngx_mail_proxy_choke_pop3(throttle_callback_t *callback);
+static void ngx_mail_proxy_choke_session(ngx_mail_session_t *s);
+
+/* utility */
+static ngx_str_t ngx_imap_quote_string(ngx_pool_t *pool, ngx_str_t *u);
+static void ngx_mail_proxy_auth_sleep_handler (ngx_event_t *rev);
+
 
 static ngx_command_t  ngx_mail_proxy_commands[] = {
 
@@ -53,6 +94,13 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {
       offsetof(ngx_mail_proxy_conf_t, buffer_size),
       NULL },
 
+    { ngx_string("proxy_ctimeout"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_msec_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, ctimeout),
+      NULL },
+
     { ngx_string("proxy_timeout"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_msec_slot,
@@ -67,6 +115,20 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {
       offsetof(ngx_mail_proxy_conf_t, pass_error_message),
       NULL },
 
+    { ngx_string("proxy_issue_pop3_xoip"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, issue_pop3_xoip),
+      NULL },
+
+    { ngx_string("proxy_issue_imap_id"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, issue_imap_id),
+      NULL },
+
     { ngx_string("xclient"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -74,6 +136,23 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {
       offsetof(ngx_mail_proxy_conf_t, xclient),
       NULL },
 
+#if (NGX_MAIL_SSL)
+
+    { ngx_string("proxy_ssl"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_mail_proxy_ssl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, proxy_ssl),
+      NULL },
+
+    { ngx_string("proxy_ssl_session_reuse"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_proxy_conf_t, proxy_ssl_session_reuse),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -105,8 +184,12 @@ ngx_module_t  ngx_mail_proxy_module = {
 };
 
 
+static u_char  pop3_authplain[] = "AUTH PLAIN" CRLF;
+static u_char  pop3_authxzimbra[] = "AUTH X-ZIMBRA" CRLF;
 static u_char  smtp_auth_ok[] = "235 2.0.0 OK" CRLF;
-
+static u_char  imap_login_no[] = "NO LOGIN failed" CRLF;
+static u_char  imap_auth_no[] = "NO AUTHENTICATE failed" CRLF;
+static u_char  imap_no[] = "NO" CRLF;
 
 void
 ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
@@ -114,12 +197,9 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
     ngx_int_t                  rc;
     ngx_mail_proxy_ctx_t      *p;
     ngx_mail_proxy_conf_t     *pcf;
-    ngx_mail_core_srv_conf_t  *cscf;
 
     s->connection->log->action = "connecting to upstream";
 
-    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
-
     p = ngx_pcalloc(s->connection->pool, sizeof(ngx_mail_proxy_ctx_t));
     if (p == NULL) {
         ngx_mail_session_internal_server_error(s);
@@ -142,7 +222,9 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
         return;
     }
 
-    ngx_add_timer(p->upstream.connection->read, cscf->timeout);
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    ngx_add_timer(p->upstream.connection->read, pcf->ctimeout);
 
     p->upstream.connection->data = s;
     p->upstream.connection->pool = s->connection->pool;
@@ -150,8 +232,6 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
     s->connection->read->handler = ngx_mail_proxy_block_read;
     p->upstream.connection->write->handler = ngx_mail_proxy_dummy_handler;
 
-    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
-
     s->proxy->buffer = ngx_create_temp_buf(s->connection->pool,
                                            pcf->buffer_size);
     if (s->proxy->buffer == NULL) {
@@ -161,6 +241,16 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)
 
     s->out.len = 0;
 
+/* bug 32683, ssl support on mail proxy connection */
+#if (NGX_MAIL_SSL)
+
+    if (pcf->proxy_ssl && p->upstream.connection->ssl == NULL) {
+        ngx_mail_proxy_ssl_init_connection(s, p->upstream.connection);
+        return;
+    }
+
+#endif
+
     switch (s->protocol) {
 
     case NGX_MAIL_POP3_PROTOCOL:
@@ -203,16 +293,28 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)
 {
     u_char                 *p;
     ngx_int_t               rc;
+    int                     family;
     ngx_str_t               line;
+    size_t                  len;
     ngx_connection_t       *c;
     ngx_mail_session_t     *s;
     ngx_mail_proxy_conf_t  *pcf;
+    struct sockaddr_in     *sin;
+
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6    *sin6;
+#endif
+
+    ngx_mail_core_srv_conf_t   *cscf;
+    ngx_str_t                   ap, ap64, tmp;
 
     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                    "mail proxy pop3 auth handler");
 
     c = rev->data;
     s = c->data;
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
 
     if (rev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
@@ -222,36 +324,165 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)
         return;
     }
 
-    rc = ngx_mail_proxy_read_response(s, 0);
+    rc = ngx_mail_proxy_read_response(s, s->mail_state);
 
     if (rc == NGX_AGAIN) {
         return;
     }
 
     if (rc == NGX_ERROR) {
-        ngx_mail_proxy_upstream_error(s);
-        return;
+        if (s->mail_state == ngx_pop3_passwd ||
+            s->mail_state == ngx_pop3_auth_plain_response
+           )
+        {
+            if(s->proxy->upstream.connection->read->timer_set) {
+                ngx_del_timer(s->proxy->upstream.connection->read);
+            }
+
+            ngx_add_timer(s->connection->read,cscf->auth_wait_intvl);
+            s->connection->read->handler = ngx_mail_proxy_auth_sleep_handler;
+            return;
+        }
+        else
+        {
+            ngx_mail_proxy_upstream_error(s);
+            return;
+        }
+    }
+
+    if (s->mail_state == ngx_pop3_start)
+    {
+        // bug 23349 -- conditionally (not always) issue pop3 xoip command
+        if (pcf->issue_pop3_xoip == 0) {
+            s->mail_state = ngx_pop3_xoip;
+        }
     }
 
     switch (s->mail_state) {
 
     case ngx_pop3_start:
-        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy send user");
+        s->connection->log->action =
+            "sending POP3 XOIP command to upstream";
+
+        /* Bug 13325 - The upstream server needs to record the IP address of
+           the downstream client that connected. For this, the Zimbra server
+           has been modified to support the XOIP command that will allow
+           the proxy to pass the IP address of the downstream client. Both
+           ipv4 and ipv6 (bug 56383) has been supported
+         */
+        family = s->connection->sockaddr->sa_family;
+        if (family == AF_INET) {
+            len = NGX_INET_ADDRSTRLEN;
+            sin = (struct sockaddr_in *) s->connection->sockaddr;
 
-        s->connection->log->action = "sending user name to upstream";
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = NGX_INET6_ADDRSTRLEN;
+            sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;
+#endif
+
+        }
+
+        line.len = sizeof ("XOIP ") -1 +
+                len +
+                sizeof (CRLF) - 1;
+
+        line.data = ngx_palloc(c->pool, line.len);
 
-        line.len = sizeof("USER ")  - 1 + s->login.len + 2;
-        line.data = ngx_pnalloc(c->pool, line.len);
         if (line.data == NULL) {
             ngx_mail_proxy_internal_server_error(s);
             return;
         }
 
-        p = ngx_cpymem(line.data, "USER ", sizeof("USER ") - 1);
-        p = ngx_cpymem(p, s->login.data, s->login.len);
-        *p++ = CR; *p = LF;
+        p = ngx_sprintf (line.data, "XOIP ");
+        tmp.data = p;
+
+        if (family == AF_INET) {
+            len = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                    line.data + line.len - p);
+
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                    p, line.data + line.len - p);
+#endif
+
+        }
+
+        p += len;
+
+        tmp.len = p - tmp.data;
+
+        *p++ = CR;
+        *p++ = LF;
+
+        line.len = p - line.data;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+            "sending POP3 XOIP command (XOIP %V)",
+            &tmp);
+
+        s->mail_state = ngx_pop3_xoip;
+
+        break;
+
+    case ngx_pop3_xoip:
+        if (!s->usedauth && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR))
+        {
+            /* If auth plain was used, but no authz, then we must blank out
+               login+zlogin, and use dusr+zusr in authc to upstream
+             */
+            s->dusr = s->qlogin;
+            s->zusr = s->zlogin;
+            s->qlogin.data = (u_char*)"";
+            s->qlogin.len = 0;
+            s->zlogin.data = (u_char*)"";
+            s->zlogin.len = 0;
+            s->usedauth = 1;
+        }
+
+        if (!s->usedauth)
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "mail proxy send user");
+
+            s->connection->log->action = "sending user name to upstream";
+
+            line.len = sizeof("USER ")  - 1 + s->qlogin.len + 2;
+            line.data = ngx_palloc(c->pool, line.len);
+            if (line.data == NULL) {
+                ngx_mail_proxy_internal_server_error(s);
+                return;
+            }
+
+            p = ngx_cpymem(line.data, "USER ", sizeof("USER ") - 1);
+            p = ngx_cpymem(p, s->qlogin.data, s->qlogin.len);
+            *p++ = CR; *p = LF;
+
+            s->mail_state = ngx_pop3_user;
+        }
+        else
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                    "mail proxy send auth plain");
+
+            if (s->auth_method == NGX_MAIL_AUTH_GSSAPI)
+            {
+                s->connection->log->action = "sending AUTH X-ZIMBRA to upstream";
+                line.len = sizeof(pop3_authxzimbra) -1;
+                line.data = pop3_authxzimbra;
+            }
+            else
+            {
+                s->connection->log->action = "sending AUTH PLAIN to upstream";
+                line.len = sizeof(pop3_authplain) - 1;
+                line.data = pop3_authplain;
+            }
+
+            s->mail_state = ngx_pop3_auth_plain;
+        }
 
-        s->mail_state = ngx_pop3_user;
         break;
 
     case ngx_pop3_user:
@@ -274,21 +505,67 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)
         break;
 
     case ngx_pop3_passwd:
-        s->connection->read->handler = ngx_mail_proxy_handler;
-        s->connection->write->handler = ngx_mail_proxy_handler;
-        rev->handler = ngx_mail_proxy_handler;
-        c->write->handler = ngx_mail_proxy_handler;
+    case ngx_pop3_auth_plain_response:
+        ngx_mail_proxy_throttle_pop3(rev);
+        return;
 
-        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
-        ngx_add_timer(s->connection->read, pcf->timeout);
-        ngx_del_timer(c->read);
+    case ngx_pop3_auth_plain:
+        if (s->auth_method == NGX_MAIL_AUTH_GSSAPI) {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "mail proxy send AUTH X-ZIMBRA response");
+            s->connection->log->action = "sending AUTH X-ZIMBRA response to upstream";
+        }
+        else {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "mail proxy send AUTH PLAIN response");
+            s->connection->log->action = "sending AUTH PLAIN response to upstream";
+        }
 
-        c->log->action = NULL;
-        ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
 
-        ngx_mail_proxy_handler(s->connection->write);
+        ap.len = s->qlogin.len + 1 +
+                 s->dusr.len + 1 +
+                 s->dpasswd.len;
+        ap.data = ngx_palloc (c->pool, ap.len);
 
-        return;
+        if (ap.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        ngx_memcpy (ap.data, s->qlogin.data, s->qlogin.len);
+        ngx_memcpy (ap.data + s->qlogin.len, "\x0", 1);
+        ngx_memcpy (ap.data + s->qlogin.len + 1,
+                    s->dusr.data,
+                    s->dusr.len);
+        ngx_memcpy (ap.data + s->qlogin.len + 1 + s->dusr.len,
+                    "\x0",1);
+        ngx_memcpy (ap.data + s->qlogin.len+1 + s->dusr.len + 1,
+                    s->dpasswd.data,
+                    s->dpasswd.len);
+
+        ap64.len = ngx_base64_encoded_length(ap.len);
+        ap64.data = ngx_palloc(c->pool, ap64.len);
+
+        if (ap64.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        ngx_encode_base64 (&ap64, &ap);
+
+        line.len = ap64.len + sizeof(CRLF) -1;
+        line.data = ngx_palloc (c->pool, line.len);
+
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        ngx_memcpy (line.data, ap64.data, ap64.len);
+        ngx_memcpy (line.data + ap64.len, CRLF, sizeof (CRLF) -1);
+
+        s->mail_state = ngx_pop3_auth_plain_response;
+        break;
 
     default:
 #if (NGX_SUPPRESS_WARN)
@@ -316,16 +593,33 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)
 {
     u_char                 *p;
     ngx_int_t               rc;
-    ngx_str_t               line;
+    ngx_uint_t              family;
+    size_t                  len;
+    ngx_str_t               line, proxy_ip;
     ngx_connection_t       *c;
     ngx_mail_session_t     *s;
     ngx_mail_proxy_conf_t  *pcf;
+    struct sockaddr_in     *sin;
+
+#if (NGX_HAVE_INET6)
+    struct sockaddr_in6        *sin6;
+#endif
+
+    ngx_mail_core_srv_conf_t   *cscf;
+    ngx_mail_imap_srv_conf_t   *iscf;
+    ngx_str_t                   challenge;
+    ngx_str_t                   ql, qp, login, tmp;
+    socklen_t                   socklen;
+    u_char                      sockaddr[NGX_SOCKADDRLEN];
 
     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
                    "mail proxy imap auth handler");
 
     c = rev->data;
     s = c->data;
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);
 
     if (rev->timedout) {
         ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
@@ -341,32 +635,268 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)
         return;
     }
 
-    if (rc == NGX_ERROR) {
-        ngx_mail_proxy_upstream_error(s);
+    if (rc == NGX_ABORT) {
+        /* NGX_ABORT is borrowed to indicate nginx should send
+         * something coming from upstream directly.
+         */
+        if (s->connection->send(s->connection, s->out.data, s->out.len) <
+                (ssize_t) s->out.len) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+        s->proxy->buffer->pos = s->proxy->buffer->start;
+        s->proxy->buffer->last = s->proxy->buffer->start;
         return;
     }
 
+    if (rc == NGX_ERROR) {
+        if (s->mail_state == ngx_imap_passwd ||
+            s->mail_state == ngx_imap_auth_plain_ir
+           )
+        {
+            if(s->proxy->upstream.connection->read->timer_set) {
+                ngx_del_timer(s->proxy->upstream.connection->read);
+            }
+
+            ngx_add_timer(s->connection->read,cscf->auth_wait_intvl);
+            s->connection->read->handler = ngx_mail_proxy_auth_sleep_handler;
+            return;
+        }
+        else
+        {
+            ngx_mail_proxy_upstream_error(s);
+            return;
+        }
+    }
+
+    if (s->mail_state == ngx_imap_start)
+    {
+        // bug 23349 -- conditionally (not always) issue imap id command
+        if (pcf->issue_imap_id == 0) {
+            s->mail_state = ngx_imap_id;
+        }
+    }
+
+
     switch (s->mail_state) {
 
     case ngx_imap_start:
         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
-                       "mail proxy send login");
+                       "mail proxy send id");
 
-        s->connection->log->action = "sending LOGIN command to upstream";
+        s->connection->log->action =
+            "sending IMAP ID extension command to upstream";
+
+        /* Bug 13325 - The upstream server needs to record the IP of the
+           original downstream client that connected, not just the proxy's IP
+           To pass on the information about the downstream client, we use the
+           IMAP ID extension command (rfc 2971)
+
+           Currently both ipv4 and ipv6 (bug 56383) are supported
+         */
+        family = s->connection->sockaddr->sa_family;
+        if (family == AF_INET) {
+            len = NGX_INET_ADDRSTRLEN;
+            sin = (struct sockaddr_in *) s->connection->sockaddr;
+
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = NGX_INET6_ADDRSTRLEN;
+            sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;
+#endif
+
+        }
+
+        line.len = s->tag.len + 1 /* for space */ +
+                sizeof ("ID (\"X-ORIGINATING-IP\" \"") - 1 +
+                len +
+                sizeof ("\" \"name\" \"") - 1 +
+                iscf->ua_name.len +
+                sizeof("\" \"version\" \"") - 1 +
+                iscf->ua_version.len +
+                sizeof ("\" \"X-VIA\" \"(" NGINX_VER ")\")"CRLF) - 1;
+        ngx_memzero(sockaddr, NGX_SOCKADDRLEN);
+        socklen = NGX_SOCKADDRLEN;
+        if(getsockname(s->connection->fd, (struct sockaddr*)sockaddr, &socklen) < 0) {
+            ngx_log_error(NGX_LOG_WARN, s->connection->log, errno, "can't get proxy's IP address");
+        }
+
+        if(((struct sockaddr *)sockaddr)->sa_family == AF_INET) {
+            proxy_ip.len = NGX_INET_ADDRSTRLEN;
+        } else {
+            proxy_ip.len = NGX_INET6_ADDRSTRLEN;
+        }
+        proxy_ip.data = ngx_palloc(c->pool, proxy_ip.len);
+        proxy_ip.len = ngx_sock_ntop((struct sockaddr*)sockaddr, NGX_SOCKADDR_STRLEN, proxy_ip.data, proxy_ip.len, 0);
+        line.len += proxy_ip.len;
+
+        if (s->id_name.len > 0) {
+            line.len += (s->id_name.len + sizeof(",") - 1);
+            if (s->id_version.len > 0) {
+                line.len += (s->id_version.len + sizeof("/") - 1);
+            }
+        }
+
+        line.data = ngx_palloc(c->pool, line.len);
 
-        line.len = s->tag.len + sizeof("LOGIN ") - 1
-                   + 1 + NGX_SIZE_T_LEN + 1 + 2;
-        line.data = ngx_pnalloc(c->pool, line.len);
         if (line.data == NULL) {
             ngx_mail_proxy_internal_server_error(s);
             return;
         }
 
-        line.len = ngx_sprintf(line.data, "%VLOGIN {%uz}" CRLF,
-                               &s->tag, s->login.len)
-                   - line.data;
+        p = ngx_sprintf (line.data, "%V ID (\"X-ORIGINATING-IP\" \"", &s->tag);
+        tmp.data = p;
+
+        if (family == AF_INET) {
+            len = ngx_inet_ntop (family, &(sin->sin_addr.s_addr), p,
+                    line.data + line.len - p);
+#if (NGX_HAVE_INET6)
+        } else { /* AF_INET6 */
+            len = ngx_inet_ntop (family, &(sin6->sin6_addr.s6_addr),
+                    p, line.data + line.len - p);
+#endif
+        }
+
+        p += len;
+        tmp.len = p - tmp.data;
+
+        p = ngx_sprintf(p, "\" \"name\" \"%V\" \"version\" \"%V\" \"X-VIA\" \"",
+                        &iscf->ua_name, &iscf->ua_version);
+        if (s->id_name.len > 0) {
+            p = ngx_cpymem(p, s->id_name.data, s->id_name.len);
+            if (s->id_version.len > 0) {
+                *p++ = '/';
+                p = ngx_cpymem(p, s->id_version.data, s->id_version.len);
+            }
+            *p++ = ',';
+        }
+        p = ngx_sprintf(p, "%V(" NGINX_VER ")\")"CRLF, &proxy_ip);
+
+        line.len = p - line.data;
+
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "sending IMAP ID command %V",
+                &line);
+
+        s->mail_state = ngx_imap_id;
 
-        s->mail_state = ngx_imap_login;
+        break;
+
+    case ngx_imap_id:
+        /* If the downstream client has logged in with a sasl mechanism
+           that does not use clear-text passwords, we do not have the
+           end user credentials to log in to the upstream server, therefore
+           in this case, we need to log in with the master username and
+           master password, using auth plain to the upstream server
+         */
+
+        if (!s->usedauth && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR)) {
+            /* If auth plain was used, but no authz, then we must blank out
+               login+zlogin, and use dusr+zusr in authc to upstream
+             */
+            s->dusr = s->qlogin;
+            s->zusr = s->zlogin;
+            s->qlogin.data = (u_char*)"";
+            s->qlogin.len = 0;
+            s->zlogin.data = (u_char*)"";
+            s->zlogin.len = 0;
+            s->usedauth = 1;
+        }
+
+        if (!s->usedauth)
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                   "no delegated auth, login to upstream using LOGIN");
+
+            s->connection->log->action = "sending LOGIN command to upstream";
+
+            /* LOGIN with literal or quoted strings (imap_literalauth) */
+            if (iscf->literalauth)
+            {
+                line.len = s->tag.len + 1 + sizeof("LOGIN ") - 1
+                           + 1 + NGX_SIZE_T_LEN + 1 + 2;
+                line.data = ngx_palloc(c->pool, line.len);
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                line.len = ngx_sprintf(line.data, "%V LOGIN {%uz}" CRLF,
+                                       &s->tag, s->qlogin.len + s->zlogin.len)
+                           - line.data;
+
+                s->mail_state = ngx_imap_login;
+            }
+            else
+            {
+                /* merge back zimbra extensions (/tb|/wm|/ni), if any */
+
+                login.data = ngx_palloc(c->pool, s->qlogin.len + s->zlogin.len);
+                if (login.data == NULL) {
+                    login = s->qlogin;
+                } else {
+                    login.len = s->qlogin.len + s->zlogin.len;
+                    ngx_memcpy(login.data, s->qlogin.data, s->qlogin.len);
+                    ngx_memcpy(login.data + s->qlogin.len, s->zlogin.data,
+                               s->zlogin.len);
+                }
+                ql = ngx_imap_quote_string(c->pool, &login);
+                qp = ngx_imap_quote_string(c->pool, &s->passwd);
+
+                line.len = s->tag.len + 1 /* for space */ + sizeof("LOGIN ") - 1 +
+                           ql.len +
+                           sizeof(" ") - 1 +
+                           qp.len +
+                           sizeof(CRLF) - 1;
+
+                line.data = ngx_palloc(c->pool,line.len);
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                ngx_sprintf(line.data,"%V LOGIN %V %V" CRLF, &s->tag, &ql, &qp);
+
+                s->mail_state = ngx_imap_passwd;
+            }
+        }
+        else
+        {
+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                "Using delegated auth to log in to upstream");
+
+            if (s->auth_method == NGX_MAIL_AUTH_GSSAPI)
+            {
+                s->connection->log->action = "sending AUTHENTICATE X-ZIMBRA to upstream";
+
+                line.len = s->tag.len + 1 /* for space */ + sizeof ("AUTHENTICATE X-ZIMBRA") - 1 + 2;
+                line.data = ngx_palloc (c->pool, line.len);
+
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                ngx_snprintf (line.data, line.len, "%V AUTHENTICATE X-ZIMBRA" CRLF, &s->tag);
+            }
+            else
+            {
+                s->connection->log->action = "sending AUTHENTICATE PLAIN to upstream";
+
+                line.len = s->tag.len + 1 /* for space */ + sizeof ("AUTHENTICATE PLAIN") - 1 + 2;
+                line.data = ngx_palloc (c->pool, line.len);
+
+                if (line.data == NULL) {
+                    ngx_mail_proxy_internal_server_error(s);
+                    return;
+                }
+
+                ngx_snprintf (line.data, line.len, "%V AUTHENTICATE PLAIN" CRLF, &s->tag);
+            }
+
+            s->mail_state = ngx_imap_auth_plain;
+        }
         break;
 
     case ngx_imap_login:
@@ -374,15 +904,15 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)
 
         s->connection->log->action = "sending user name to upstream";
 
-        line.len = s->login.len + 1 + 1 + NGX_SIZE_T_LEN + 1 + 2;
+        line.len = s->qlogin.len + 1 + 1 + NGX_SIZE_T_LEN + 1 + 2;
         line.data = ngx_pnalloc(c->pool, line.len);
         if (line.data == NULL) {
             ngx_mail_proxy_internal_server_error(s);
             return;
         }
 
-        line.len = ngx_sprintf(line.data, "%V {%uz}" CRLF,
-                               &s->login, s->passwd.len)
+        line.len = ngx_sprintf(line.data, "%V%V {%uz}" CRLF,
+                               &s->qlogin, &s->zlogin, s->passwd.len)
                    - line.data;
 
         s->mail_state = ngx_imap_user;
@@ -408,25 +938,67 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)
         break;
 
     case ngx_imap_passwd:
-        s->connection->read->handler = ngx_mail_proxy_handler;
-        s->connection->write->handler = ngx_mail_proxy_handler;
-        rev->handler = ngx_mail_proxy_handler;
-        c->write->handler = ngx_mail_proxy_handler;
+    case ngx_imap_auth_plain_ir:
+        ngx_mail_proxy_throttle_imap(rev);
+        return;
 
-        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
-        ngx_add_timer(s->connection->read, pcf->timeout);
-        ngx_del_timer(c->read);
+    case ngx_imap_auth_plain:
+        /* RFC 4616
+           message   = [authzid] UTF8NUL authcid UTF8NUL passwd
+         */
 
-        c->log->action = NULL;
-        ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+        challenge.len = s->qlogin.len + s->zlogin.len + 1 +
+                        s->dusr.len + s->zusr.len + 1 +
+                        s->dpasswd.len;
+        line.len = ngx_base64_encoded_length (challenge.len);
 
-        ngx_mail_proxy_handler(s->connection->write);
+        challenge.data = ngx_palloc (c->pool, challenge.len);
+        if (challenge.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
 
-        return;
+        line.data = ngx_palloc (c->pool, line.len + 2);   /* +2 for CRLF */
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        /* construct the base64 challenge for auth-plain login to upstream */
+
+        p = challenge.data;
+        p = ngx_cpymem(p, s->qlogin.data, s->qlogin.len);   /* authz */
+        p = ngx_cpymem(p, s->zlogin.data, s->zlogin.len); /* [/wm|/ni|/tb] */
+        *p++ = '\x0';
+        p = ngx_cpymem(p, s->dusr.data, s->dusr.len);     /* authc */
+        p = ngx_cpymem(p, s->zusr.data, s->zusr.len);     /* [/wm|/ni|/tb] for authc */
+        *p++ = '\x0';
+        p = ngx_cpymem(p, s->dpasswd.data, s->dpasswd.len); /* password */
+
+        ngx_encode_base64 (&line, &challenge);
+
+        if (s->auth_method == NGX_MAIL_AUTH_GSSAPI) {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                            "sending AUTH X-ZIMBRA challenge to upstream"
+                           );
+        }
+        else {
+            ngx_log_debug0 (NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                            "sending AUTH PLAIN challenge to upstream"
+                           );
+        }
+
+        ngx_memcpy (line.data + line.len, CRLF, 2);
+        line.len += 2;
+
+        s->mail_state = ngx_imap_auth_plain_ir;
+
+        break;
 
     default:
 #if (NGX_SUPPRESS_WARN)
-        ngx_str_null(&line);
+        line.len = 0;
+        line.data = NULL;
 #endif
         break;
     }
@@ -590,10 +1162,10 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)
             return;
         }
 
-        line.len = ngx_sprintf(line.data,
+            line.len = ngx_sprintf(line.data,
                        ((s->esmtp) ? "EHLO %V" CRLF : "HELO %V" CRLF),
                        &s->smtp_helo)
-                   - line.data;
+                       - line.data;
 
         s->mail_state = (s->auth_method == NGX_MAIL_AUTH_NONE) ?
                             ngx_smtp_helo_from : ngx_smtp_helo;
@@ -721,6 +1293,33 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)
     ssize_t                 n;
     ngx_buf_t              *b;
     ngx_mail_proxy_conf_t  *pcf;
+    int                     expect_chunk;
+
+    /* (bug 21323)
+
+       during the authentication phase, the upstream imap server can include an
+       optional untagged response to the LOGIN or to the ID command
+       if the `nio_imap_enabled' parameter is set to true, then the upstream
+       server's response is split into two tcp packets, the first chunk
+       contains the untagged response, and the next chunk contains the tagged
+       result
+
+       in this function, nginx previously expected all the response to arrive
+       in a single chunk, which is not true in this case, and therefore, we
+       must maintain a state variable (expect_chunk), which has boolean
+       significance -- if the variable starts off as false, and it is marked
+       true when we encounter an untagged response
+
+       when the tagged response eventually arrives (the tag identifier is at
+       the start of a new line of response), then this variable is signaled
+       to false again, which means that we don't expect another chunk of
+       data
+
+       if we finish processing the data returned by the call to recv(), and
+       if expect_chunk is set to true, then we return NGX_AGAIN, which will
+       cause this handler to get invoked again, when the next chunk of data
+       becomes available
+     */
 
     s->connection->log->action = "reading response from upstream";
 
@@ -739,7 +1338,12 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)
 
     b->last += n;
 
-    if (b->last - b->pos < 4) {
+    /* if (b->last - b->pos < 5) {
+        return NGX_AGAIN;
+    } */ /* -- This won't work with zimbra */
+
+    if ((b->last - b->pos < 5) && (b->pos) && (*b->pos != '+'))
+    {
         return NGX_AGAIN;
     }
 
@@ -755,13 +1359,20 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)
         return NGX_AGAIN;
     }
 
+    expect_chunk = 0;
     p = b->pos;
 
     switch (s->protocol) {
 
     case NGX_MAIL_POP3_PROTOCOL:
-        if (p[0] == '+' && p[1] == 'O' && p[2] == 'K') {
-            return NGX_OK;
+        if (state == ngx_pop3_auth_plain) {
+            if (p[0] == '+' && p[1] == ' ') {
+                return NGX_OK;
+            }
+        } else {
+            if (p[0] == '+' && p[1] == 'O' && p[2] == 'K') {
+                return NGX_OK;
+            }
         }
         break;
 
@@ -776,18 +1387,78 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)
 
         case ngx_imap_login:
         case ngx_imap_user:
+        case ngx_imap_auth_plain:
             if (p[0] == '+') {
                 return NGX_OK;
             }
             break;
 
-        case ngx_imap_passwd:
-            if (ngx_strncmp(p, s->tag.data, s->tag.len) == 0) {
-                p += s->tag.len;
-                if (p[0] == 'O' && p[1] == 'K') {
+        case ngx_imap_id:
+            if (*p == '*') {
+                /* bug 60751 identify the [ALERT] msg from upstream */
+                if (ngx_strncmp(p, "* OK [ALERT]", sizeof("* OK [ALERT]") - 1) == 0) {
+                    s->out.len = b->last - b->pos;
+                    s->out.data = b->pos;
+                    return NGX_ABORT;
+                }
+
+                /* bug 68678 ignore the untagged error for the ID command */
+                if (ngx_strncmp(p, "* BAD", sizeof("* BAD") - 1) == 0) {
                     return NGX_OK;
                 }
             }
+            /* fall through */
+        case ngx_imap_passwd:
+        case ngx_imap_auth_plain_ir:
+            /* Consume (optional, untagged response, plus) tagged response to
+               IMAP command previously issued
+               As the switch case indicates, we are prepared to handle this
+               after sending the ID command, or after sending the password to
+               the upstream imap server
+               In the former case, the IMAP server MAY optionally include an
+               untagged ID repsonse (RFC 2971, section 3.1)
+               In the latter case, the IMAP server MAY include a CAPABILITY
+               response code in the tagged OK response to a successful LOGIN
+               command (RFC 3501, section 6.2.3)
+             */
+
+            while ((p != NULL) && (p < b->last))
+            {
+                if (ngx_strncmp(p, s->tag.data, s->tag.len) == 0)
+                {
+                    /* This line is the tagged response */
+                    expect_chunk = 0;
+
+                    p += s->tag.len + 1 /*for space*/;
+                    if (p[0] == 'O' && p[1] == 'K')
+                    {
+                        return NGX_OK;
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+                else
+                {
+                    /* this line is any optional untagged response
+                     */
+                    p = (u_char *)strstr ((char *)p, (char *)"\n");
+                    if (!p)
+                    {
+                        /* if we don't find the newline, it indicates an
+                           invalid response
+                         */
+                        break;
+                    }
+                    else
+                    {
+                        /* the first (possible) chunk has been read */
+                        expect_chunk = 1;
+                        ++p;
+                    }
+                }
+            }
             break;
         }
 
@@ -845,6 +1516,11 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)
         break;
     }
 
+    if (expect_chunk == 1) {
+        return NGX_AGAIN;
+    }
+
+    s->sendquitmsg = 1;
     pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
 
     if (pcf->pass_error_message == 0) {
@@ -898,6 +1574,7 @@ ngx_mail_proxy_handler(ngx_event_t *ev)
                           "upstream timed out");
         }
 
+        s->sendquitmsg = 1;
         ngx_mail_proxy_close_session(s);
         return;
     }
@@ -975,7 +1652,14 @@ ngx_mail_proxy_handler(ngx_event_t *ev)
 
             n = src->recv(src, b->last, size);
 
-            if (n == NGX_AGAIN || n == 0) {
+            if (n == NGX_AGAIN) {
+                break;
+            }
+
+            if (n == 0) {
+                if (c == s->connection && !ev->write) {
+                    s->sendquitmsg = 1;
+                }
                 break;
             }
 
@@ -1037,7 +1721,10 @@ ngx_mail_proxy_handler(ngx_event_t *ev)
     }
 }
 
-
+/* error out of an established proxy session
+    - close the upstream connection
+    - close the downstream connection after sending any pending data
+ */
 static void
 ngx_mail_proxy_upstream_error(ngx_mail_session_t *s)
 {
@@ -1081,11 +1768,22 @@ ngx_mail_proxy_close_session(ngx_mail_session_t *s)
         ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
                        "close mail proxy connection: %d",
                        s->proxy->upstream.connection->fd);
+#if (NGX_MAIL_SSL)
+
+        if (s->proxy->upstream.connection->ssl) {
+            s->proxy->upstream.connection->ssl->no_wait_shutdown = 1;
+            ngx_ssl_shutdown(s->proxy->upstream.connection);
+        }
+#endif
 
         ngx_close_connection(s->proxy->upstream.connection);
     }
 
-    ngx_mail_close_connection(s->connection);
+    if (s->sendquitmsg) {
+        ngx_mail_end_session(s);
+    } else {
+        ngx_mail_close_connection(s->connection);
+    }
 }
 
 
@@ -1101,9 +1799,16 @@ ngx_mail_proxy_create_conf(ngx_conf_t *cf)
 
     pcf->enable = NGX_CONF_UNSET;
     pcf->pass_error_message = NGX_CONF_UNSET;
+    pcf->issue_pop3_xoip = NGX_CONF_UNSET;
+    pcf->issue_imap_id = NGX_CONF_UNSET;
+    pcf->xclient = NGX_CONF_UNSET;
     pcf->xclient = NGX_CONF_UNSET;
     pcf->buffer_size = NGX_CONF_UNSET_SIZE;
+    pcf->ctimeout = NGX_CONF_UNSET_MSEC;
     pcf->timeout = NGX_CONF_UNSET_MSEC;
+    pcf->proxy_ssl = NGX_CONF_UNSET;
+    pcf->proxy_ssl_session_reuse = NGX_CONF_UNSET;
+    pcf->ssl = NGX_CONF_UNSET_PTR;
 
     return pcf;
 }
@@ -1117,10 +1822,507 @@ ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)
 
     ngx_conf_merge_value(conf->enable, prev->enable, 0);
     ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);
+    ngx_conf_merge_value(conf->issue_pop3_xoip, prev->issue_pop3_xoip, 1);
+    ngx_conf_merge_value(conf->issue_imap_id, prev->issue_imap_id, 1);
     ngx_conf_merge_value(conf->xclient, prev->xclient, 1);
+    ngx_conf_merge_value(conf->proxy_ssl, prev->proxy_ssl, 0);
+    ngx_conf_merge_value(conf->proxy_ssl_session_reuse, prev->proxy_ssl_session_reuse, 1);
+    ngx_conf_merge_ptr_value(conf->ssl, prev->ssl, NULL);
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                               (size_t) ngx_pagesize);
+    ngx_conf_merge_msec_value(conf->ctimeout, prev->ctimeout, 2 * 60000);
     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);
 
     return NGX_CONF_OK;
 }
+
+#if (NGX_MAIL_SSL)
+
+static char *
+ngx_mail_proxy_ssl(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+
+    ngx_pool_cleanup_t    *cln;
+    char                  *rc;
+    ngx_mail_proxy_conf_t *pcf;
+
+    rc = ngx_conf_set_flag_slot(cf, cmd, conf);
+    if (rc != NGX_CONF_OK) {
+        return rc;
+    }
+
+    pcf = (ngx_mail_proxy_conf_t *)conf;
+
+    if (!pcf->proxy_ssl) {
+        return NGX_CONF_OK;
+    }
+
+    pcf->ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));
+
+    if (pcf->ssl == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    pcf->ssl->log = cf->log;
+
+    // don't support SSLv2 anymore
+    if (ngx_ssl_create(pcf->ssl, NGX_SSL_SSLv3|NGX_SSL_TLSv1, NULL)
+            != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_ssl_cleanup_ctx;
+    cln->data = pcf->ssl;
+
+    return NGX_CONF_OK;
+}
+
+#endif
+/* throttle imap session if necessary (user has just finished logging in) */
+static void ngx_mail_proxy_throttle_imap(ngx_event_t *rev)
+{
+    throttle_callback_t          *callback;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_mail_proxy_conf_t        *pcf;
+    ngx_mail_session_t           *s;
+    ngx_connection_t             *c;
+    ngx_pool_t                   *pool;
+    ngx_log_t                    *log;
+    ngx_str_t                     user;
+
+    c = rev->data;
+    s = c->data;
+    pool = c->pool;
+    log = ngx_cycle->log;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    callback = ngx_pcalloc(pool, sizeof(throttle_callback_t));
+    if (callback == NULL) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    callback->check_only = 0;    /* increment the counter */
+    callback->session = s;
+    callback->connection = c;
+    callback->rev = rev;
+    callback->config = pcf;
+    callback->log = log;
+    callback->pool = pool;
+    callback->on_allow = ngx_mail_proxy_allow_imap;
+    callback->on_deny = ngx_mail_proxy_choke_imap;
+
+    if (tscf->mail_login_user_max == 0) {
+        callback->on_allow(callback);
+    } else {
+        user = s->qlogin;
+        if ((user.len == 0) && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR)) {
+            user = s->dusr;
+        }
+        ngx_mail_throttle_user(user, callback);
+    }
+}
+
+static void ngx_mail_proxy_allow_imap(throttle_callback_t *callback)
+{
+    ngx_mail_session_t      *s = callback->session;
+    ngx_event_t             *rev = callback->rev;
+    ngx_connection_t        *c = callback->connection;
+    ngx_mail_proxy_conf_t   *pcf = callback->config;
+
+    s->connection->read->handler = ngx_mail_proxy_handler;
+    s->connection->write->handler = ngx_mail_proxy_handler;
+    rev->handler = ngx_mail_proxy_handler;
+    c->write->handler = ngx_mail_proxy_handler;
+
+    ngx_add_timer(s->connection->read, pcf->timeout);
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    c->log->action = NULL;
+    ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+
+    ngx_mail_proxy_handler(s->connection->write);
+}
+
+static void ngx_mail_proxy_choke_imap(throttle_callback_t *callback)
+{
+    ngx_mail_session_t  *s = callback->session;
+    ngx_mail_proxy_choke_session(s);
+}
+
+/* throttle pop3 session if necessary (user has just finished logging in) */
+static void ngx_mail_proxy_throttle_pop3(ngx_event_t *rev)
+{
+    throttle_callback_t          *callback;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_mail_proxy_conf_t        *pcf;
+    ngx_mail_session_t           *s;
+    ngx_connection_t             *c;
+    ngx_pool_t                   *pool;
+    ngx_log_t                    *log;
+    ngx_str_t                     user;
+
+    c = rev->data;
+    s = c->data;
+    pool = c->pool;
+    log = ngx_cycle->log;
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    callback = ngx_pcalloc(pool, sizeof(throttle_callback_t));
+    if (callback == NULL) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    callback->check_only = 0;    /* increment the counter */
+    callback->session = s;
+    callback->connection = c;
+    callback->rev = rev;
+    callback->config = pcf;
+    callback->log = log;
+    callback->pool = pool;
+    callback->on_allow = ngx_mail_proxy_allow_pop3;
+    callback->on_deny = ngx_mail_proxy_choke_pop3;
+
+    if (tscf->mail_login_user_max == 0) {
+        callback->on_allow(callback);
+    } else {
+        user = s->qlogin;
+        if ((user.len == 0) && (s->auth_method == NGX_MAIL_AUTH_PLAIN
+                || s->auth_method == NGX_MAIL_AUTH_PLAIN_IR)) {
+            user = s->dusr;
+        }
+        ngx_mail_throttle_user(user, callback);
+    }
+}
+
+static void ngx_mail_proxy_allow_pop3(throttle_callback_t *callback)
+{
+    ngx_mail_session_t      *s = callback->session;
+    ngx_event_t             *rev = callback->rev;
+    ngx_connection_t        *c = callback->connection;
+    ngx_mail_proxy_conf_t   *pcf = callback->config;
+
+    s->connection->read->handler = ngx_mail_proxy_handler;
+    s->connection->write->handler = ngx_mail_proxy_handler;
+    rev->handler = ngx_mail_proxy_handler;
+    c->write->handler = ngx_mail_proxy_handler;
+
+    ngx_add_timer(s->connection->read, pcf->timeout);
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    c->log->action = NULL;
+    ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+
+    ngx_mail_proxy_handler(s->connection->write);
+}
+
+static void ngx_mail_proxy_choke_pop3(throttle_callback_t *callback)
+{
+    ngx_mail_session_t  *s = callback->session;
+    ngx_mail_proxy_choke_session(s);
+}
+
+static void ngx_mail_proxy_choke_session(ngx_mail_session_t *s)
+{
+    ngx_mail_throttle_srv_conf_t *tscf;
+    ngx_str_t                     bye, msg, umsg;
+    ngx_pool_t                   *pool;
+    u_char                       *p;
+
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    pool = s->connection->pool;
+    msg = tscf->mail_login_user_rejectmsg;
+
+    if (s->proxy->upstream.connection)
+    {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,
+                       "close mail proxy connection: %d",
+                       s->proxy->upstream.connection->fd);
+
+        ngx_close_connection(s->proxy->upstream.connection);
+    }
+
+    if (s->protocol == NGX_MAIL_IMAP_PROTOCOL)
+    {
+        bye.len =   sizeof("* BYE ") - 1 +
+                    msg.len +
+                    sizeof(CRLF) - 1;
+
+        bye.data = ngx_palloc(pool, bye.len);
+
+        if (bye.data != NULL)
+        {
+            p = bye.data;
+            p = ngx_cpymem(p,"* BYE ",sizeof("* BYE ")-1);
+            p = ngx_cpymem(p, msg.data, msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p - bye.data;
+        }
+        else
+        {
+            bye.data = (u_char *) ("* BYE" CRLF);
+            bye.len = sizeof("* BYE" CRLF)-1;
+        }
+
+        s->out = bye;
+        s->quit = 0;
+        ngx_mail_send(s->connection->write);
+
+        if (s->command == NGX_IMAP_LOGIN) {
+            umsg.data = imap_login_no;
+            umsg.len = sizeof(imap_login_no) - 1;
+        } else if (s->command == NGX_IMAP_AUTHENTICATE) {
+            umsg.data = imap_auth_no;
+            umsg.len = sizeof(imap_auth_no) - 1;
+        } else {
+            umsg.data = imap_no;
+            umsg.len = sizeof(imap_no) - 1;
+        }
+
+        s->out.len = s->tag.len + 1 /*for space*/+ umsg.len;
+        s->out.data = ngx_palloc(pool, s->out.len);
+
+        if (s->out.data == NULL) {
+            s->out.data = (u_char*)"";
+            s->out.len = 0;
+            ngx_mail_close_connection(s->connection);
+        } else {
+            ngx_memcpy(s->out.data, s->tag.data, s->tag.len);
+            *(s->out.data + s->tag.len) = ' ';
+            ngx_memcpy(s->out.data + s->tag.len + 1, umsg.data, umsg.len);
+            s->quit = 1;
+            ngx_mail_send(s->connection->write);
+        }
+
+        return;
+    }
+    else if (s->protocol == NGX_MAIL_POP3_PROTOCOL)
+    {
+        bye.len = sizeof("-ERR ")-1 +
+                  msg.len +
+                  sizeof(CRLF)-1;
+
+        bye.data = ngx_palloc(pool,bye.len);
+
+        if (bye.data != NULL)
+        {
+            p = bye.data;
+            p = ngx_cpymem(p,"-ERR ",sizeof("-ERR ")-1);
+            p = ngx_cpymem(p,msg.data,msg.len);
+            *p++ = CR;
+            *p++ = LF;
+            bye.len = p-bye.data;
+        }
+        else
+        {
+            bye.data = (u_char *)("-ERR" CRLF);
+            bye.len = sizeof("-ERR" CRLF)-1;
+        }
+
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(s->connection->write);
+        return;
+    }
+    else
+    {
+        /* TODO ?? reject SMTP ?? */
+        bye.data = (u_char *)"";
+        bye.len = 0;
+        s->out = bye;
+        s->quit = 1;
+        ngx_mail_send(s->connection->write);
+        return;
+    }
+}
+
+/* Quote an IMAP string according to RFC 3501, section 9 (formal syntax) */
+static ngx_str_t ngx_imap_quote_string(ngx_pool_t *pool, ngx_str_t *u)
+{
+    size_t      s;
+    ngx_str_t   k;
+    u_char     *p,*q,*r;
+
+    s = 2;
+    q = u->data;
+    r = q + u->len;
+
+    while (q<r) {
+        if (*q == '"' || *q == '\\') { ++s; }
+        ++s;
+        ++q;
+    }
+
+    k.data = ngx_palloc(pool,s);
+    if (k.data == NULL) {
+        k = *u;
+    } else {
+        k.len = s;
+        p = k.data;
+        q = u->data;
+        r = q + u->len;
+        *p++ = '"';
+        while (q<r) {
+            if (*q == '"' || *q == '\\') { *p++ = '\\'; }
+            *p++ = *q++;
+        }
+        *p++ = '"';
+    }
+
+    return k;
+}
+
+static void
+ngx_mail_proxy_auth_sleep_handler (ngx_event_t *rev)
+{
+    ngx_connection_t        *c;
+    ngx_mail_session_t      *s;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+        "mail proxy auth sleep handler");
+
+    c = rev->data;
+    s = c->data;
+
+    ngx_zm_lookup_delete_cache(s->key_alias, s->key_route);
+
+    if (rev->timedout) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    if (rev->active) {
+        if (ngx_handle_read_event(rev, 0) == NGX_ERROR) {
+            ngx_mail_proxy_upstream_error(s);
+        }
+    }
+}
+
+ngx_flag_t
+ngx_mail_get_proxy_ssl (ngx_mail_session_t * s)
+{
+    ngx_mail_proxy_conf_t * pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+    return pcf->proxy_ssl;
+}
+
+#if (NGX_HTTP_SSL)
+
+static void
+ngx_mail_proxy_ssl_init_connection(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    ngx_int_t               rc;
+    ngx_mail_proxy_conf_t  *pcf;
+
+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+
+    if (ngx_ssl_create_connection(pcf->ssl, c,
+                                  NGX_SSL_BUFFER|NGX_SSL_CLIENT)
+        != NGX_OK)
+    {
+        ngx_mail_proxy_internal_server_error(s);
+        return;
+    }
+
+    /**
+     * TODO support session reuse
+    if (pcf->ssl_session_reuse) {
+        if (u->peer.set_session(&u->peer, u->peer.data) != NGX_OK) {
+            ngx_mail_internal_server_error(s);
+            return;
+        }
+    }
+    */
+
+    s->connection->log->action = "SSL handshaking to upstream";
+
+    rc = ngx_ssl_handshake(c);
+
+    if (rc == NGX_AGAIN) {
+        c->ssl->handler = ngx_mail_proxy_ssl_handshake;
+        return;
+    }
+
+    ngx_mail_proxy_ssl_handshake(c);
+}
+
+
+static void
+ngx_mail_proxy_ssl_handshake(ngx_connection_t *c)
+{
+    ngx_mail_session_t  *s;
+    s = c->data;
+
+    if (c->ssl->handshaked) {
+
+        /**
+         * TODO support ssl session reuse
+
+        if (pcf->ssl_session_reuse) {
+            ngx_mail_proxy_save_session(s, c);
+        }
+        */
+        c->write->handler = ngx_mail_proxy_dummy_handler;
+        switch (s->protocol) {
+
+            case NGX_MAIL_POP3_PROTOCOL:
+                c->read->handler = ngx_mail_proxy_pop3_handler;
+                s->mail_state = ngx_pop3_start;
+                break;
+
+            case NGX_MAIL_IMAP_PROTOCOL:
+                c->read->handler = ngx_mail_proxy_imap_handler;
+                s->mail_state = ngx_imap_start;
+                break;
+
+            default: /* NGX_MAIL_SMTP_PROTOCOL */
+                c->read->handler = ngx_mail_proxy_smtp_handler;
+                s->mail_state = ngx_smtp_start;
+                break;
+        }
+
+        /* server might have send the intial welcome msg */
+        c->read->handler(c->read);
+    } else {
+        /* when handshake fails, we should close the session */
+        ngx_mail_proxy_upstream_error(s);
+    }
+}
+
+/** TODO support ssl session reuse
+void
+ngx_mail_proxy_set_session (ngx_peer_connection_t *pc, ngx_mail_proxy_ctx_t *ctx)
+{
+    ngx_ssl_session_t   *ssl_session;
+    ngx_int_t            rc;
+
+    ssl_session = peer->ssl_session;
+
+    rc = ngx_ssl_set_session(pc->connection, ssl_session);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, pc->log, 0,
+                   "set session: %p:%d",
+                   ssl_session, ssl_session ? ssl_session->references : 0);
+    return;
+}
+
+void
+ngx_mail_proxy_save_session (ngx_peer_connection_t *pc)
+{
+
+}
+*/
+
+#endif
diff --git a/src/mail/ngx_mail_smtp_module.c b/src/mail/ngx_mail_smtp_module.c
index 3b5a2d8f3..2ca4347e1 100644
--- a/src/mail/ngx_mail_smtp_module.c
+++ b/src/mail/ngx_mail_smtp_module.c
@@ -49,7 +49,8 @@ static ngx_mail_protocol_t  ngx_mail_smtp_protocol = {
 
     ngx_string("451 4.3.2 Internal server error" CRLF),
     ngx_string("421 4.7.1 SSL certificate error" CRLF),
-    ngx_string("421 4.7.1 No required SSL certificate" CRLF)
+    ngx_string("421 4.7.1 No required SSL certificate" CRLF),
+    ngx_string("") /* zimbra add a quite_msg field in mail protocol */
 };
 
 
diff --git a/src/mail/ngx_mail_throttle_module.c b/src/mail/ngx_mail_throttle_module.c
new file mode 100644
index 000000000..96e85297b
--- /dev/null
+++ b/src/mail/ngx_mail_throttle_module.c
@@ -0,0 +1,1564 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+#include <ngx_config.h>
+#include <ngx_mail_throttle_module.h>
+#include <ngx_zm_lookup.h>
+#include <ngx_memcache.h>
+
+static ngx_str_t throttle_zero = ngx_string("0");
+
+static void *ngx_mail_throttle_create_srv_conf
+    (ngx_conf_t *cf);
+static char *ngx_mail_throttle_merge_srv_conf
+    (ngx_conf_t *cf, void *parent, void *child);
+static char *ngx_mail_throttle_ip_ttl
+    (ngx_conf_t *cf, ngx_command_t* command, void * conf);
+static char *ngx_mail_throttle_ip_imap_ttl
+    (ngx_conf_t *cf, ngx_command_t* command, void * conf);
+static char *ngx_mail_throttle_ip_pop3_ttl
+    (ngx_conf_t *cf, ngx_command_t* command, void * conf);
+static char *ngx_mail_throttle_user_ttl
+    (ngx_conf_t *cf, ngx_command_t* command, void * conf);
+static char *ngx_mail_throttle_set_ttl_text
+    (ngx_msec_t ttl, ngx_str_t * input, ngx_str_t * ttl_text);
+static char *ngx_mail_throttle_whitelist_ips
+    (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char * ngx_mail_throttle_whitelist_ips_ttl
+    (ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+void ngx_mail_throttle_whitelist_lookup_ip
+    (throttle_callback_t *callback);
+static void ngx_mail_throttle_whitelist_lookup_ip_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_whitelist_lookup_ip_failure_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_ip_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_ip_failure_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_whitelist_ip_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_whitelist_ip_failure_handler
+    (mc_work_t *w);
+static ngx_str_t ngx_mail_throttle_ip_ttl_txt
+    (ngx_mail_throttle_srv_conf_t * tscf, ngx_uint_t protocol);
+static void ngx_mail_throttle_ip_add
+    (ngx_str_t *ip, throttle_callback_t *callback);
+static void ngx_mail_throttle_ip_add_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_ip_add_failure_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_quser
+    (ngx_str_t *quser, throttle_callback_t *callback);
+static void ngx_mail_throttle_quser_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_quser_failure_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_user_add
+    (ngx_str_t *user, throttle_callback_t *callback);
+static void ngx_mail_throttle_user_add_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_user_add_failure_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_user_success_handler
+    (mc_work_t *w);
+static void ngx_mail_throttle_user_failure_handler
+    (mc_work_t *w);
+
+static ngx_str_t ngx_mail_throttle_get_ip_throttle_key
+   (ngx_pool_t *pool, ngx_log_t *log, ngx_str_t ip, ngx_uint_t protocol);
+static ngx_str_t ngx_mail_throttle_get_ip_whitelist_key
+    (ngx_pool_t *pool, ngx_log_t *log, ngx_str_t ip);
+static ngx_str_t ngx_mail_throttle_get_user_throttle_key
+   (ngx_pool_t *pool, ngx_log_t *log, ngx_str_t user);
+static char * ngx_encode_protocol
+   (ngx_uint_t protocol, char eptype);
+
+static ngx_command_t  ngx_mail_throttle_commands[] = {
+    { ngx_string("mail_login_ip_max"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_max),
+      NULL },
+
+    { ngx_string("mail_login_ip_ttl"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_mail_throttle_ip_ttl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_ttl),
+      NULL },
+
+    { ngx_string("mail_login_ip_rejectmsg"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_rejectmsg),
+      NULL },
+
+    { ngx_string("mail_login_ip_imap_max"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_imap_max),
+      NULL },
+
+    { ngx_string("mail_login_ip_imap_ttl"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_mail_throttle_ip_imap_ttl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_imap_ttl),
+      NULL },
+
+    { ngx_string("mail_login_ip_pop3_max"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_pop3_max),
+      NULL },
+
+    { ngx_string("mail_login_ip_pop3_ttl"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_mail_throttle_ip_pop3_ttl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_ip_pop3_ttl),
+      NULL },
+
+    { ngx_string("mail_whitelist_ip"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_1MORE,
+      ngx_mail_throttle_whitelist_ips,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_throttle_whitelist_ips),
+      NULL },
+
+    { ngx_string("mail_whitelist_ip_ttl"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_mail_throttle_whitelist_ips_ttl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_whitelist_ip_ttl),
+      NULL },
+
+    { ngx_string("mail_login_user_max"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_user_max),
+      NULL },
+
+    { ngx_string("mail_login_user_ttl"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_mail_throttle_user_ttl,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_user_ttl),
+      NULL },
+
+    { ngx_string("mail_login_user_rejectmsg"),
+      NGX_MAIL_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_throttle_srv_conf_t, mail_login_user_rejectmsg),
+      NULL },
+
+     ngx_null_command
+};
+
+static ngx_mail_module_t  ngx_mail_throttle_module_ctx = {
+    NULL,                                  /* protocol */
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_mail_throttle_create_srv_conf,     /* create server configuration */
+    ngx_mail_throttle_merge_srv_conf       /* merge server configuration */
+};
+
+ngx_module_t  ngx_mail_throttle_module = {
+    NGX_MODULE_V1,
+    &ngx_mail_throttle_module_ctx,         /* module context */
+    ngx_mail_throttle_commands,            /* module directives */
+    NGX_MAIL_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+static void *
+ngx_mail_throttle_create_srv_conf(ngx_conf_t *cf)
+{
+    ngx_mail_throttle_srv_conf_t  *tscf;
+
+    tscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_throttle_srv_conf_t));
+    if (tscf == NULL) {
+        return NULL;
+    }
+
+    tscf->mail_login_ip_max = NGX_CONF_UNSET;
+    tscf->mail_login_ip_imap_max = NGX_CONF_UNSET;
+    tscf->mail_login_ip_pop3_max = NGX_CONF_UNSET;
+    tscf->mail_login_ip_ttl = NGX_CONF_UNSET_MSEC;
+    tscf->mail_login_ip_imap_ttl = NGX_CONF_UNSET_MSEC;
+    tscf->mail_login_ip_pop3_ttl = NGX_CONF_UNSET_MSEC;
+    ngx_str_null (&tscf->mail_login_ip_ttl_text);
+    ngx_str_null (&tscf->mail_login_ip_imap_ttl_text);
+    ngx_str_null (&tscf->mail_login_ip_pop3_ttl_text);
+    tscf->mail_login_user_max = NGX_CONF_UNSET;
+    tscf->mail_login_user_ttl = NGX_CONF_UNSET_MSEC;
+    ngx_str_null (&tscf->mail_login_user_ttl_text);
+    tscf->mail_throttle_whitelist_ips = NGX_CONF_UNSET_PTR;
+    tscf->mail_whitelist_ip_ttl = NGX_CONF_UNSET;
+    ngx_str_null (&tscf->mail_whitelist_ip_ttl_text);
+
+    return tscf;
+}
+
+static char *
+ngx_mail_throttle_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_mail_throttle_srv_conf_t *prev = parent;
+    ngx_mail_throttle_srv_conf_t *conf = child;
+
+    ngx_conf_merge_uint_value (conf->mail_login_ip_max,
+                               prev->mail_login_ip_max, 1000);
+    ngx_conf_merge_uint_value (conf->mail_login_ip_imap_max,
+                               prev->mail_login_ip_imap_max, 0);
+    ngx_conf_merge_uint_value (conf->mail_login_ip_pop3_max,
+                               prev->mail_login_ip_pop3_max, 0);
+    ngx_conf_merge_uint_value (conf->mail_login_user_max,
+                               prev->mail_login_user_max, 100);
+    ngx_conf_merge_msec_value (conf->mail_login_ip_ttl,
+                               prev->mail_login_ip_ttl, 60000);
+    ngx_conf_merge_msec_value (conf->mail_login_ip_imap_ttl,
+                               prev->mail_login_ip_imap_ttl, 60000);
+    ngx_conf_merge_msec_value (conf->mail_login_ip_pop3_ttl,
+                               prev->mail_login_ip_pop3_ttl, 60000);
+    ngx_conf_merge_msec_value (conf->mail_login_user_ttl,
+                               prev->mail_login_user_ttl, 60000);
+    ngx_conf_merge_str_value (conf->mail_login_ip_rejectmsg,
+                              prev->mail_login_ip_rejectmsg, "");
+    ngx_conf_merge_str_value (conf->mail_login_user_rejectmsg,
+                              prev->mail_login_user_rejectmsg, "");
+    ngx_conf_merge_str_value (conf->mail_login_ip_ttl_text,
+                              prev->mail_login_ip_ttl_text, "60");
+    ngx_conf_merge_str_value (conf->mail_login_ip_imap_ttl_text,
+                              prev->mail_login_ip_imap_ttl_text, "60");
+    ngx_conf_merge_str_value (conf->mail_login_ip_pop3_ttl_text,
+                              prev->mail_login_ip_pop3_ttl_text, "60");
+
+    ngx_conf_merge_str_value (conf->mail_login_user_ttl_text,
+                              prev->mail_login_user_ttl_text, "60");
+    ngx_conf_merge_ptr_value(conf->mail_throttle_whitelist_ips,
+                             prev->mail_throttle_whitelist_ips,
+                             NGX_CONF_UNSET_PTR);
+    ngx_conf_merge_value (conf->mail_whitelist_ip_ttl,
+                          prev->mail_whitelist_ip_ttl, 300);
+    ngx_conf_merge_str_value (conf->mail_whitelist_ip_ttl_text,
+                              prev->mail_whitelist_ip_ttl_text, "300");
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_throttle_ip_ttl (ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    char      *res;
+    ngx_str_t *value;
+    ngx_mail_throttle_srv_conf_t *tscf = conf;
+
+    res = ngx_conf_set_msec_slot(cf, cmd, conf);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    value = cf->args->elts;
+    res = ngx_mail_throttle_set_ttl_text (tscf->mail_login_ip_ttl,
+                    &value[1], &tscf->mail_login_ip_ttl_text);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_throttle_ip_imap_ttl (ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    char      *res;
+    ngx_str_t *value;
+    ngx_mail_throttle_srv_conf_t *tscf = conf;
+
+    res = ngx_conf_set_msec_slot(cf, cmd, conf);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    value = cf->args->elts;
+    res = ngx_mail_throttle_set_ttl_text (tscf->mail_login_ip_imap_ttl,
+                    &value[1], &tscf->mail_login_ip_imap_ttl_text);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_throttle_ip_pop3_ttl (ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    char      *res;
+    ngx_str_t *value;
+    ngx_mail_throttle_srv_conf_t *tscf = conf;
+
+    res = ngx_conf_set_msec_slot(cf, cmd, conf);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    value = cf->args->elts;
+    res = ngx_mail_throttle_set_ttl_text (tscf->mail_login_ip_pop3_ttl,
+                    &value[1], &tscf->mail_login_ip_pop3_ttl_text);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_throttle_whitelist_ips_ttl (ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    char      *res;
+    ngx_str_t *value;
+    ngx_mail_throttle_srv_conf_t *tscf = conf;
+
+    res = ngx_conf_set_msec_slot(cf, cmd, conf);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    value = cf->args->elts;
+    res = ngx_mail_throttle_set_ttl_text (tscf->mail_whitelist_ip_ttl,
+                    &value[1], &tscf->mail_whitelist_ip_ttl_text);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_throttle_user_ttl (ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    char      *res;
+    ngx_str_t *value;
+    ngx_mail_throttle_srv_conf_t *tscf = conf;
+
+    res = ngx_conf_set_msec_slot(cf, cmd, conf);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    value = cf->args->elts;
+    res = ngx_mail_throttle_set_ttl_text (tscf->mail_login_user_ttl,
+                    &value[1], &tscf->mail_login_user_ttl_text);
+
+    if (res != NGX_CONF_OK) {
+        return res;
+    }
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_throttle_whitelist_ips (ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    ngx_cidr_t                   *cidr;
+    ngx_mail_throttle_srv_conf_t *tscf = conf;
+    ngx_uint_t                    i;
+    ngx_int_t                     rc;
+    ngx_str_t                     *value;
+
+    if (tscf->mail_throttle_whitelist_ips == NGX_CONF_UNSET_PTR) {
+	// This function gets called once for each mail_whitelist_ip parameter/value found.
+        // TODO - see if there is a way to determine here how many of these there are so that
+        //        we can allocate the exact number of elements that we need at once.
+        tscf->mail_throttle_whitelist_ips = ngx_array_create(cf->pool, 10, sizeof(ngx_cidr_t));
+        if (tscf->mail_throttle_whitelist_ips == NGX_CONF_UNSET_PTR) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    for (i = 1; i < cf->args->nelts; ++i)
+    {
+        value = &((ngx_str_t *)cf->args->elts)[i];
+        cidr = ngx_array_push(tscf->mail_throttle_whitelist_ips);
+        if (cidr == NULL) {
+            return NGX_CONF_ERROR;
+        }
+        rc = ngx_ptocidr(value, cidr);
+        if (rc == NGX_ERROR) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "invalid mail_whitelist_ip parameter \"%V\"", &value[1]);
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+void
+ngx_mail_throttle_whitelist_lookup_ip (throttle_callback_t *callback) {
+    mc_work_t                        w;
+    ngx_int_t                        i;
+    ngx_cidr_t                       ip_cidr, *cidr;
+    ngx_log_t                       *log;
+    ngx_uint_t                       rc;
+    ngx_mail_session_t              *session;
+    ngx_mail_throttle_srv_conf_t    *tscf;
+    ngx_pool_t                      *pool;
+    ngx_str_t                        *ip, *cache_val, tmpval;
+
+    ip = callback->ip;
+    callback->is_whitelisted = 0;
+    log = callback->log;
+    pool = callback->pool;
+    session = callback->session;
+
+    tscf = ngx_mail_get_module_srv_conf(session, ngx_mail_throttle_module);
+    if (tscf->mail_throttle_whitelist_ips == NGX_CONF_UNSET_PTR) {
+        ngx_log_error (NGX_LOG_DEBUG, log, 0, "no whitelisted ips, %V not whitelisted", ip);
+        ngx_mail_throttle_ip(*ip, callback);
+        return;
+    }
+    rc = ngx_ptocidr(ip, &ip_cidr);
+    if (rc == NGX_ERROR) {
+        ngx_log_error (NGX_LOG_ERR, log, 0, "whitelisting ip %V do to error converting to cidr", ip);
+        ngx_mail_throttle_ip(*ip, callback);
+        return;
+    }
+#if (NGX_HAVE_INET6)
+    if (ip_cidr.family == AF_INET6) {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ngx_mail_throttle_ip_whitelisted: %V is IPV6", ip);
+        for (i = 0; i < tscf->mail_throttle_whitelist_ips->nelts; ++i) {
+            cidr = &((ngx_cidr_t *)tscf->mail_throttle_whitelist_ips->elts)[i];
+            if (cidr->family == AF_INET6) {
+                if (
+                    ((ip_cidr.u.in6.addr.__in6_u.__u6_addr32[0] & cidr->u.in6.mask.__in6_u.__u6_addr32[0]) ==
+                     (cidr->u.in6.addr.__in6_u.__u6_addr32[0] & cidr->u.in6.mask.__in6_u.__u6_addr32[0])) &&
+                    ((ip_cidr.u.in6.addr.__in6_u.__u6_addr32[1] & cidr->u.in6.mask.__in6_u.__u6_addr32[1]) ==
+                     (cidr->u.in6.addr.__in6_u.__u6_addr32[1] & cidr->u.in6.mask.__in6_u.__u6_addr32[1])) &&
+                    ((ip_cidr.u.in6.addr.__in6_u.__u6_addr32[2] & cidr->u.in6.mask.__in6_u.__u6_addr32[2]) ==
+                     (cidr->u.in6.addr.__in6_u.__u6_addr32[2] & cidr->u.in6.mask.__in6_u.__u6_addr32[2])) &&
+                    ((ip_cidr.u.in6.addr.__in6_u.__u6_addr32[3] & cidr->u.in6.mask.__in6_u.__u6_addr32[3]) ==
+                     (cidr->u.in6.addr.__in6_u.__u6_addr32[3] & cidr->u.in6.mask.__in6_u.__u6_addr32[3]))
+                   ) {
+                    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ngx_mail_throttle_ip_whitelisted: IPV6: %V is whitelisted", ip);
+                    callback->is_whitelisted = 1;
+                }
+            }
+        }
+    }
+#endif
+    if (ip_cidr.family == AF_INET) {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ngx_mail_throttle_ip_whitelisted: %V is IPV4", ip);
+        for (i = 0; i < tscf->mail_throttle_whitelist_ips->nelts; ++i) {
+            cidr = &((ngx_cidr_t *)tscf->mail_throttle_whitelist_ips->elts)[i];
+            if (cidr->family == AF_INET) {
+                ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ngx_mail_throttle_ip_whitelisted: verify IPV4: %V", ip);
+                if ((ip_cidr.u.in.addr & cidr->u.in.mask) == (cidr->u.in.addr & cidr->u.in.mask)) {
+                    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ngx_mail_throttle_ip_whitelisted: IPV4: %V is whitelisted", ip);
+                    callback->is_whitelisted = 1;
+                }
+            }
+        }
+    }
+
+    tmpval.len = 1;
+    tmpval.data = callback->is_whitelisted ? "1" : "0";
+    cache_val = ngx_pstrcpy(pool, &tmpval);
+    if (cache_val == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "Unable to cache fact that %V is_whitelisted=%d (alloc mem for cache_val)",
+            ip, callback->is_whitelisted);
+        if (callback->is_whitelisted) {
+            callback->on_allow(callback);
+        }
+        else {
+            ngx_mail_throttle_ip(*ip, callback);
+        }
+        return;
+    }
+
+    w.ctx = callback;
+    w.request_code = mcreq_add;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_mail_throttle_whitelist_lookup_ip_success_handler;
+    w.on_failure = ngx_mail_throttle_whitelist_lookup_ip_failure_handler;
+
+    ngx_memcache_post_with_ttl(&w, *callback->wl_key, *cache_val, tscf->mail_whitelist_ip_ttl_text, NULL, log);
+}
+
+static void
+ngx_mail_throttle_whitelist_lookup_ip_success_handler (mc_work_t *w) {
+    ngx_log_t               *log;
+    throttle_callback_t     *callback;
+
+    callback = (throttle_callback_t *)w->ctx;
+    log = callback->log;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, log, 0, "cached is_whitelisted=%d for IP %V", callback->is_whitelisted, callback->ip);
+
+    if (callback->is_whitelisted) {
+        callback->on_allow(callback);
+    }
+    else {
+        ngx_mail_throttle_ip(*callback->ip, callback);
+    }
+}
+
+static void
+ngx_mail_throttle_whitelist_lookup_ip_failure_handler (mc_work_t *w) {
+    ngx_log_t               *log;
+    throttle_callback_t     *callback;
+
+    callback = (throttle_callback_t *)w->ctx;
+    log = callback->log;
+
+    ngx_log_error (NGX_LOG_NOTICE, log, 0, "error trying to cache whitelist status for IP %V", callback->ip);
+    if (callback->is_whitelisted) {
+        callback->on_allow(callback);
+    }
+    else {
+        ngx_mail_throttle_ip(*callback->ip, callback);
+    }
+}
+
+
+static char *
+ngx_mail_throttle_set_ttl_text (ngx_msec_t ttl, ngx_str_t * input, ngx_str_t * ttl_text) {
+
+   if (ttl > 1000) {
+       if (input->len > 2 &&
+           input->data[input->len - 2] == 'm' &&
+           input->data[input->len - 1] == 's') {
+           /* for ms value, trim the last 5 characters 'NNNms' and become the number of seconds
+            * for example, 3600000ms --> 3600 */
+           ttl_text->data = input->data;
+           ttl_text->len = input->len - 5;
+       } else {
+           /* no trailing "ms", directly used as second value */
+           *ttl_text = *input;
+       }
+   } else if (ttl > 0) {
+       /* 0 ~ 1000ms, make it 1 */
+       ngx_str_set(ttl_text, "1");
+   } else if (ttl == 0){
+       ngx_str_set(ttl_text, "0");
+   } else {
+       return "invalid value";
+   }
+
+   return NGX_CONF_OK;
+}
+
+/* check whether the client ip should be allowed to proceed, or whether
+   the connection should be throttled
+ */
+void ngx_mail_throttle_ip (ngx_str_t ip, throttle_callback_t *callback)
+{
+    ngx_log_t       *log;
+    ngx_pool_t      *pool;
+    mc_work_t        w;
+    ngx_str_t        k;
+    ngx_str_t       *value, *eip, *key;
+    ngx_uint_t       protocol;
+
+    pool = callback->pool;
+    log = callback->log;
+    protocol = callback->session->protocol;
+
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, log, 0, "check ip throttle:[%s, %V]", ngx_encode_protocol(protocol, 'l'), &ip);
+
+    w.ctx = callback;
+    w.request_code = mcreq_incr;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_mail_throttle_ip_success_handler;
+    w.on_failure = ngx_mail_throttle_ip_failure_handler;
+
+    k = ngx_mail_throttle_get_ip_throttle_key(pool, log, ip, protocol);
+
+    if (k.len == 0) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle control (generate key for incr)", &ip);
+        callback->on_allow(callback);
+        return;
+    }
+
+    key = ngx_pstrcpy (pool, &k);
+    if (key == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle control (deep copy key for incr)", &ip);
+        callback->on_allow(callback);
+    }
+
+    value = ngx_palloc (pool, sizeof(ngx_str_t));
+    if (value == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle control (alloc mem for incr value)", &ip);
+        callback->on_allow(callback);
+        return;
+    }
+
+    ngx_str_set(value, "1");
+
+    /* make a copy of the input IP address for callback reference */
+    eip = ngx_pstrcpy (pool, &ip);
+    if (eip == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle control (deep copy ip for incr)", &ip);
+        callback->on_allow(callback);
+        return;
+    }
+
+    callback->ip = eip;
+    callback->value = value;
+    callback->key = key;
+
+    ngx_memcache_post(&w, *key, *value, /* pool */ NULL, log);
+}
+
+ngx_uint_t ngx_mail_throttle_ip_max_for_protocol (
+    ngx_mail_throttle_srv_conf_t * tscf,
+    ngx_uint_t protocol
+)
+{
+    ngx_uint_t login_ip_max = 0;
+
+    switch (protocol) {
+        case NGX_MAIL_POP3_PROTOCOL:
+            login_ip_max = tscf->mail_login_ip_pop3_max > 0 ? tscf->mail_login_ip_pop3_max : tscf->mail_login_ip_max;
+            break;
+        case NGX_MAIL_IMAP_PROTOCOL:
+            login_ip_max = tscf->mail_login_ip_imap_max > 0 ? tscf->mail_login_ip_imap_max : tscf->mail_login_ip_max;
+            break;
+        default:
+            login_ip_max = tscf->mail_login_ip_max;
+    }
+    return login_ip_max;
+}
+
+/* memcache handler (return counter for the specified ip or NOT_FOUND) */
+static void ngx_mail_throttle_ip_success_handler (mc_work_t *w)
+{
+    ngx_mail_throttle_srv_conf_t * tscf;
+    throttle_callback_t     *callback = w->ctx;
+    ngx_mail_session_t      *s = callback->session;
+    ngx_str_t                ip = *callback->ip;
+    size_t                   hits;
+    ngx_str_t                counter;
+    ngx_uint_t               login_ip_max = 0;
+
+    /* the increment was successful - deep copy w->payload to counter */
+    counter.data = ngx_pstrdup (callback->pool, &w->payload);
+
+    if (counter.data == NULL) {
+        /* enomem */
+        counter = throttle_zero;    /* "0" */
+    } else {
+        counter.len = w->payload.len;
+    }
+
+    /* check if the limit has exceeded */
+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, callback->log, 0,
+        "ip throttle:%V is %V", &ip, &counter);
+
+    hits = ngx_atoi(counter.data, counter.len);
+
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+    login_ip_max = ngx_mail_throttle_ip_max_for_protocol(tscf, s->protocol);
+    ngx_log_error (NGX_LOG_DEBUG, callback->log, 0,
+        "ngx_mail_throttle_ip_success_handler: login_ip_max=%d, mail_login_ip_max=%d, "
+        "mail_login_ip_imap_max=%d, mail_login_ip_pop3_max=%d",
+        login_ip_max, tscf->mail_login_ip_max, tscf->mail_login_ip_imap_max, tscf->mail_login_ip_pop3_max);
+
+    if (login_ip_max == 0) {
+
+        //should never reach here because mail handler won't
+        //start throttle control if it's unlimited.
+        ngx_log_error (NGX_LOG_INFO, callback->log, 0,
+            "ip throttle:[%V] allow [count:%d, limit:inf]",
+            &ip, hits);
+        callback->on_allow(callback);
+    } else if (hits <= login_ip_max) {
+        ngx_log_error (NGX_LOG_INFO, callback->log, 0,
+            "ip throttle:[%V] allow [count:%d, limit:%d]",
+            &ip, hits, login_ip_max);
+        callback->on_allow(callback);
+    } else {
+        ngx_log_error (NGX_LOG_NOTICE, callback->log, 0,
+            "ip throttle:[%V] deny [count:%d, limit:%d]",
+            &ip, hits, login_ip_max);
+        callback->on_deny(callback);
+    }
+}
+
+/* check cache to see whether the client ip is whitelisted.  if so,
+   invokes callback->on_allow.  if not, calls ngx_mail_throttle_ip.
+   If no IPs are configured for whitelisting, doesn't bother checking
+   cache and just calls ngx_mail_throttle_ip.
+ */
+void
+ngx_mail_throttle_whitelist_ip (ngx_str_t ip, throttle_callback_t *callback) {
+    ngx_log_t                       *log;
+    ngx_mail_session_t              *session;
+    ngx_mail_throttle_srv_conf_t    *tscf;
+    ngx_pool_t                      *pool;
+    mc_work_t                        w;
+    ngx_str_t                        k;
+    ngx_str_t                       *value, *eip, *key;
+
+    pool = callback->pool;
+    log = callback->log;
+    session = callback->session;
+    tscf = ngx_mail_get_module_srv_conf(session, ngx_mail_throttle_module);
+    if (tscf->mail_throttle_whitelist_ips == NGX_CONF_UNSET_PTR) {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "no configured whitelisted IPs, %V not whitelisted", &ip);
+        ngx_mail_throttle_ip(ip, callback);
+        return;
+    }
+
+    k = ngx_mail_throttle_get_ip_whitelist_key (pool, log, ip);
+    if (k.len == 0) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle whitelist control (generate key for get)", &ip);
+        callback->on_allow(callback);
+        return;
+    }
+    key = ngx_pstrcpy (pool, &k);
+    if (key == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle whitelist control (deep copy key for get)", &ip);
+        callback->on_allow(callback);
+    }
+    /* make a copy of the input IP address for callback reference */
+    eip = ngx_pstrcpy (pool, &ip);
+    if (eip == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing ip %V login because of internal error"
+                "in ip throttle whitelist control (deep copy ip for get)", &ip);
+        callback->on_allow(callback);
+        return;
+    }
+
+    callback->ip = eip;
+    callback->wl_key = key;
+
+    w.ctx = callback;
+    w.request_code = mcreq_get;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_mail_throttle_whitelist_ip_success_handler;
+    w.on_failure = ngx_mail_throttle_whitelist_ip_failure_handler;
+
+    ngx_memcache_post(&w, *key, NGX_EMPTY_STR,/* pool */ NULL, log);
+}
+
+static void
+ngx_mail_throttle_whitelist_ip_success_handler (mc_work_t *w) {
+    ngx_log_t           *log;
+    ngx_pool_t          *pool;
+    throttle_callback_t *callback;
+
+    callback = (throttle_callback_t *)w->ctx;
+    log = callback->log;
+    pool = callback->pool;
+
+    if (w->payload.len > 0) {
+        if (w->payload.data[0] == '1') {
+            ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ip %V whitelisted (from cache)", callback->ip);
+            callback->on_allow(callback);
+            return;
+        }
+        else {
+            ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "ip %V is not whitelisted (from cache)", callback->ip);
+            ngx_mail_throttle_ip(*callback->ip, callback);
+            return;
+        }
+    }
+    else {
+        ngx_mail_throttle_whitelist_lookup_ip(callback);
+    }
+}
+
+static void
+ngx_mail_throttle_whitelist_ip_failure_handler (mc_work_t *w) {
+
+    ngx_log_t           *log;
+    throttle_callback_t *callback;
+
+    callback = (throttle_callback_t *)w->ctx;
+    log = callback->log;
+
+    if (w->response_code == mcres_failure_normal) {
+        // NOT FOUND
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0, "whitelist status for IP %V not found in cache", callback->ip);
+        ngx_mail_throttle_whitelist_lookup_ip(callback);
+    }
+    else {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "cache failure trying to see if %V should be whitelisted", callback->ip);
+        ngx_mail_throttle_ip(*callback->ip, callback);
+    }
+}
+
+static ngx_str_t ngx_mail_throttle_ip_ttl_txt (
+    ngx_mail_throttle_srv_conf_t * tscf,
+    ngx_uint_t protocol
+)
+{
+    ngx_str_t ip_ttl_txt;
+
+    switch (protocol) {
+        case NGX_MAIL_POP3_PROTOCOL:
+            ip_ttl_txt = tscf->mail_login_ip_pop3_ttl_text;
+            break;
+        case NGX_MAIL_IMAP_PROTOCOL:
+            ip_ttl_txt = tscf->mail_login_ip_imap_ttl_text;
+            break;
+        default:
+            ip_ttl_txt = tscf->mail_login_ip_ttl_text;
+    }
+    return ip_ttl_txt;
+}
+
+static void ngx_mail_throttle_ip_failure_handler (mc_work_t *w)
+{
+    throttle_callback_t  *callback = w->ctx;
+    ngx_log_t            *log = callback->log;
+    if (w->response_code == mcres_failure_normal) {
+        /* increment failed, we must begin to add counter for this ip */
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0,
+            "ip throttle:%V create counter", callback->ip);
+        ngx_mail_throttle_ip_add (callback->ip, callback);
+
+    } else if (w->response_code == mcres_failure_again) {
+        mc_work_t nw; /* create a new work entry */
+        nw.ctx = callback;
+        nw.request_code = mcreq_incr;
+        nw.response_code = mcres_unknown;
+        nw.on_success = ngx_mail_throttle_ip_success_handler;
+        nw.on_failure = ngx_mail_throttle_ip_failure_handler;
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+                "retry to check ip throttle:[%V]", callback->ip);
+        ngx_memcache_post(&nw, *callback->key, *callback->value,
+                          /* pool */ NULL, log);
+
+    } else { /* mcres_failure_unavailable */
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+             "throttle allowing access from ip %V because of "
+             "memcache service is unavailable when try to "
+             "increment ip counter", callback->ip);
+        callback->on_allow(callback);
+    }
+}
+
+static void ngx_mail_throttle_ip_add
+    (ngx_str_t *ip, throttle_callback_t *callback)
+{
+    ngx_pool_t     *pool    = callback->pool;
+    ngx_log_t      *log     = callback->log;
+    ngx_mail_session_t  *s  = callback->session;
+    ngx_mail_throttle_srv_conf_t * tscf;
+    mc_work_t       w;
+    ngx_str_t       k, value;
+    ngx_str_t      *key;
+    ngx_str_t       ip_ttl_text;
+
+    ngx_log_error (NGX_LOG_INFO, log, 0, "counter for %V not found, "
+                        "create ip throttle counter", ip);
+
+    w.ctx = callback;
+    w.request_code = mcreq_add;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_mail_throttle_ip_add_success_handler;
+    w.on_failure = ngx_mail_throttle_ip_add_failure_handler;
+
+    /* use ttl for discrete time sampling of ip login hits */
+    tscf = ngx_mail_get_module_srv_conf(s, ngx_mail_throttle_module);
+
+    ip_ttl_text = ngx_mail_throttle_ip_ttl_txt(tscf, s->protocol);
+    k = ngx_mail_throttle_get_ip_throttle_key(pool, log, *ip, s->protocol);
+
+    if (k.len == 0) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+               "allowing ip %V login because of internal error "
+               "in ip throttle control (generate key for add)", ip);
+        callback->on_allow(callback);
+        return;
+    }
+
+    ngx_log_debug3 (NGX_LOG_DEBUG_MAIL, log, 0,
+        "ngx_mail_throttle_ip_add: protocol=%s, ip_ttl_text=%V, k=%V",
+        ngx_encode_protocol(s->protocol, 'l'), &ip_ttl_text, &k);
+
+    key = ngx_pstrcpy (pool, &k);
+    if (key == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+               "allowing ip %V login because of internal error "
+               "in ip throttle control (deep copy key for add)", ip);
+    }
+
+    ngx_str_set(&value, "1");
+
+    callback->value = ngx_pstrcpy (pool, &value);
+    if (key == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+               "allowing ip %V login because of internal error "
+               "in ip throttle control (deep copy key for add)", ip);
+    }
+    callback->key = key;
+    callback->ip = ip;
+    callback->ttl = &ip_ttl_text;
+
+    ngx_memcache_post_with_ttl(&w, *key, value, ip_ttl_text,/* pool */ NULL, log);
+}
+
+static void ngx_mail_throttle_ip_add_success_handler(mc_work_t *w)
+{
+    throttle_callback_t *callback = w->ctx;
+    ngx_log_t           *log = callback->log;
+
+    /* counter addition succeeded */
+    ngx_log_error (NGX_LOG_INFO, log, 0,
+        "ip throttle:%V counter created and access allowed", callback->ip);
+    /* TODO handle extreme case where ip_limit is 0 or 1 */
+    callback->on_allow(callback);
+}
+
+/* memcache error handler (connection error or memory allocation error) */
+static void ngx_mail_throttle_ip_add_failure_handler (mc_work_t *w)
+{
+    throttle_callback_t   *callback = w->ctx;
+    ngx_log_t             *log = callback->log;
+
+    if (w->response_code == mcres_failure_normal) {
+        /* Counter creation failed because of getting "NOT_STORED". This could
+         * occur when more than one processes try to login and post "incr"
+         * and all get "NOT_FOUND", and then try to add new counter. One of
+         * them will get "STORED" and others will reach here. In some other
+         * extreme cases, such as the ttl is very short, or some mis-handling
+         * of memcache, this case may also happen. Considering the little
+         * probability and the endurable inaccuracy, just ignore it.
+         */
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+            "allowing ip %V login because unable to create the "
+            "ip counter", callback->ip);
+        callback->on_allow(callback);
+
+    } else if (w->response_code == mcres_failure_again) {
+        mc_work_t nw;
+        nw.ctx = callback;
+        nw.request_code = mcreq_add;
+        nw.response_code = mcres_unknown;
+        nw.on_success = ngx_mail_throttle_ip_add_success_handler;
+        nw.on_failure = ngx_mail_throttle_ip_add_failure_handler;
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+                "retry to check ip throttle:[%V]", callback->ip);
+        ngx_memcache_post_with_ttl(&nw, *callback->key, *callback->value,
+                *callback->ttl, /* pool */ NULL, callback->log);
+    } else { /* mcres_failure_unavailable */
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "throttle allowing access from ip %V because "
+                "error occurs in memcache module when try to "
+                "create counter", callback->ip);
+        callback->on_allow(callback);
+    }
+}
+
+/* check whether the client user name should be allowed to proceed, or whether
+   the connection should be throttled
+ */
+void ngx_mail_throttle_user (ngx_str_t user, throttle_callback_t *callback)
+{
+    ngx_pool_t          *pool;
+    ngx_log_t           *log;
+    ngx_connection_t    *c;
+    ngx_str_t           *cusr;
+    ngx_mail_session_t  *s;
+    mc_work_t            w;
+    ngx_str_t            proxyip;
+    ngx_str_t           *dummy_value;
+
+    pool = callback->pool;
+    log = callback->log;
+    c = callback->connection;
+    s = callback->session;
+
+    ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, log, 0,
+        "user throttle: lookup alias, user:%V", &user);
+
+    /* save a copy of the user name */
+    cusr = ngx_pstrcpy(pool, &user);
+    if (cusr == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing user %V login because of internal error "
+                "in user throttle control (deep copy user for incr)", &user);
+        callback->on_allow(callback);
+        return;
+    }
+
+    if (s->vlogin) {
+        /* user alias has already been looked up */
+        ngx_log_debug1 (NGX_LOG_DEBUG_MAIL, log, 0,
+            "user throttle: skip alias lookup, user:%V", &user);
+        ngx_mail_throttle_quser(cusr, callback);
+        return;
+    }
+
+    w.ctx = callback;
+    w.request_code = mcreq_get;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_mail_throttle_user_success_handler;
+    w.on_failure = ngx_mail_throttle_user_failure_handler;
+
+    /* GSSAPI workaround: don't lookup aliases for GSSAPI */
+    if (s->auth_method == NGX_MAIL_AUTH_GSSAPI) {
+        ngx_log_error(NGX_LOG_INFO, log, 0,
+            "not looking up cached aliases for auth=gssapi");
+        ngx_mail_throttle_quser(cusr, callback);
+        return;
+    }
+
+    /* first stringify the proxy-ip address */
+    proxyip = ngx_mail_get_socket_local_addr_str (pool, c->fd);
+
+    s->key_alias = ngx_zm_lookup_get_mail_alias_key(
+            pool,
+            log,
+            *cusr,
+            proxyip
+        );
+
+    if (s->key_alias.len == 0) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "allowing user %V login because of internal error "
+                "in user throttle control (create alias key)", &user);
+        callback->on_allow(callback);
+        return;
+    }
+
+    dummy_value = ngx_palloc (pool, sizeof (ngx_str_t));
+
+    ngx_str_null (dummy_value);
+
+    callback->key = &s->key_alias;
+    callback->value = dummy_value;
+    callback->user = cusr;
+
+    ngx_memcache_post(&w, s->key_alias, *dummy_value,/* pool */ NULL, log);
+}
+
+/* callback to replace login user name with an alias, if any */
+static void ngx_mail_throttle_user_success_handler (mc_work_t *w)
+{
+    throttle_callback_t     *callback = w->ctx;
+    ngx_mail_session_t      *s = callback->session;
+    ngx_str_t                login; //full qualified name
+
+    /* deep copy w->payload onto s->login (pool is callback->pool) */
+    login.data = ngx_pstrdup (callback->pool, &w->payload);
+    if (login.data != NULL)
+    {
+        login.len = w->payload.len;
+        s->vlogin = 2; // lookup alias and found
+        s->qlogin = login;
+        ngx_log_error (NGX_LOG_INFO, callback->log, 0,
+            "user throttle: alias %V replaced by %V",
+            callback->user, &s->login);
+        ngx_mail_throttle_quser (&s->login, callback);
+    } else {
+        ngx_mail_throttle_quser (callback->user, callback);
+    }
+}
+
+static void ngx_mail_throttle_user_failure_handler (mc_work_t *w)
+{
+    throttle_callback_t  *callback = w->ctx;
+    ngx_str_t            *user = callback->user;
+    ngx_mail_session_t   *s = callback->session;
+    ngx_log_t            *log = callback->log;
+
+    if (w->response_code == mcres_failure_normal) {
+        //NOT_FOUND
+        ngx_log_error(NGX_LOG_INFO, log, 0,
+            "user throttle: no alias for user:%V",
+            user);
+        s->vlogin = 1;  /* avoid duplicate lookups for alias */
+        s->qlogin = s->login;
+        ngx_mail_throttle_quser (callback->user, callback);
+
+    } else if(w->response_code == mcres_failure_again) {
+        mc_work_t nw;
+        nw.ctx = callback;
+        nw.request_code = mcreq_get;
+        nw.response_code = mcres_unknown;
+        nw.on_success = ngx_mail_throttle_user_success_handler;
+        nw.on_failure = ngx_mail_throttle_user_failure_handler;
+        ngx_log_error (NGX_LOG_NOTICE, callback->log, 0,
+                "retry to lookup alias %V before user throttle", callback->user);
+        ngx_memcache_post(&nw, *callback->key, *callback->value,
+                            /* pool */ NULL, log);
+
+    } else if(w->response_code == mcres_failure_input) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                       "throttle deny since the user name %V is invalid",
+                       callback->user);
+        callback->on_deny(callback);
+    } else { /* mcres_failure_unavailable */
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+                "throttle allowing access from user %V because "
+                "memcache service is unavailable when try to "
+                "perform alias lookup", callback->user);
+        callback->on_allow(callback);
+    }
+}
+
+/* same as ngx_mail_throttle_user, but works on a fully qualified user name */
+static void ngx_mail_throttle_quser (ngx_str_t * quser, throttle_callback_t *callback)
+{
+    ngx_log_t           *log;
+    ngx_pool_t          *pool;
+    mc_work_t            w;
+    ngx_str_t            k;
+    ngx_str_t           *value, *key;
+    ngx_flag_t           check_only;
+
+    pool = callback->pool;
+    log = callback->log;
+    check_only = callback->check_only;
+
+    k = ngx_mail_throttle_get_user_throttle_key(pool, log, *quser);
+    if (k.len == 0) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "allowing user %V login because of internal error "
+            "in user throttle control (generate key for get)", quser);
+        callback->on_allow(callback);
+        return;
+    }
+
+    key = ngx_pstrcpy (pool, &k);
+    if (key == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "allowing user %V login because of internal error "
+            "in user throttle control (deep copy check user key)", quser);
+        callback->on_allow(callback);
+    }
+
+    if (check_only == 0)
+    {   // try to increment the counter for this user
+        ngx_log_error (NGX_LOG_INFO, log, 0, "check user throttle:%V", quser);
+        w.ctx = callback;
+        w.request_code = mcreq_incr;
+        w.response_code = mcres_unknown;
+        w.on_success = ngx_mail_throttle_quser_success_handler;
+        w.on_failure = ngx_mail_throttle_quser_failure_handler;
+
+        value = ngx_palloc (pool, sizeof(ngx_str_t));
+        if (value == NULL) {
+            ngx_log_error (NGX_LOG_ERR, log, 0,
+                    "allowing user %V login because of internal error"
+                    "in ip throttle control (alloc mem for incr value)", quser);
+            callback->on_allow(callback);
+            return;
+        }
+
+        ngx_str_set(value, "1");
+    }
+    else
+    {   // just check the counter
+        ngx_log_error (NGX_LOG_INFO, log, 0, "check user throttle:%V, check only", quser);
+        w.ctx = callback;
+        w.request_code = mcreq_get;
+        w.response_code = mcres_unknown;
+        w.on_success = ngx_mail_throttle_quser_success_handler;
+        w.on_failure = ngx_mail_throttle_quser_failure_handler;
+
+        value = ngx_palloc (pool, sizeof(ngx_str_t));
+        if (value == NULL) {
+            ngx_log_error (NGX_LOG_ERR, log, 0,
+                    "allowing ip %V login because of internal error"
+                    "in user throttle control (alloc mem for get value)", quser);
+            callback->on_allow(callback);
+            return;
+        }
+
+        ngx_str_null (value);
+    }
+
+    callback->key = key;
+    callback->value = value;
+    callback->user = quser;
+
+    ngx_memcache_post(&w, *key, *value,/* pool */ NULL, log);
+}
+
+static void ngx_mail_throttle_quser_success_handler (mc_work_t *w)
+{
+    throttle_callback_t     *callback = w->ctx;
+    ngx_mail_session_t      *s = callback->session;
+    ngx_log_t               *log = callback->log;
+    ngx_mail_throttle_srv_conf_t * tscf;
+    size_t                   hits;
+    ngx_str_t                counter;
+
+    /* increment succeeded / get succeeded */
+    counter.data = ngx_pstrdup(callback->pool, &w->payload);
+
+    if (counter.data == NULL) { /* enomem */
+        counter = throttle_zero;
+    } else {
+        counter.len = w->payload.len;
+    }
+
+    /* check if the limit has exceeded */
+    ngx_log_debug2 (NGX_LOG_DEBUG_MAIL, log, 0,
+        "user throttle:%V is %V", callback->user, &counter);
+
+    hits = ngx_atoi (counter.data, counter.len);
+
+    tscf = ngx_mail_get_module_srv_conf (s, ngx_mail_throttle_module);
+    if (tscf->mail_login_user_max == 0) {
+        //should never reach here because unlimited case has been handled
+        ngx_log_error (NGX_LOG_INFO, log, 0,
+            "user throttle:%V allow [count:%d,limit:inf]",
+            callback->user, hits);
+        callback->on_allow(callback);
+    } else if (hits <= tscf->mail_login_user_max) {
+        ngx_log_error (NGX_LOG_INFO, log, 0,
+            "user throttle:%V allow [count:%d,limit:%d]",
+            callback->user, hits, tscf->mail_login_user_max);
+        callback->on_allow(callback);
+    } else {
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+            "user throttle:%V deny [count:%d,limit:%d]",
+            callback->user, hits, tscf->mail_login_user_max);
+        callback->on_deny(callback);
+    }
+}
+
+static void ngx_mail_throttle_quser_failure_handler (mc_work_t *w)
+{
+    throttle_callback_t *callback = w->ctx;
+    ngx_log_t           *log = callback->log;
+    ngx_flag_t           check_only = callback->check_only;
+
+    if (w->response_code == mcres_failure_normal) {
+        if (check_only) {
+           ngx_log_error (NGX_LOG_INFO, log, 0,
+                "user throttle:%V not found, allow due to check only",
+                callback->user);
+           callback->on_allow(callback);
+       } else {
+           ngx_log_debug1(NGX_LOG_DEBUG_MAIL, log, 0,
+                "user throttle:%V add counter", callback->user);
+           ngx_mail_throttle_user_add(callback->user, callback);
+       }
+
+    } else if (w->response_code == mcres_failure_again) {
+        mc_work_t nw;
+        nw.ctx = callback;
+        if (check_only) {
+            nw.request_code = mcreq_get;
+        } else {
+            nw.request_code = mcreq_incr;
+        }
+        nw.response_code = mcres_unknown;
+        nw.on_success = ngx_mail_throttle_quser_success_handler;
+        nw.on_failure = ngx_mail_throttle_quser_failure_handler;
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+                "retry to check user throttle:%V", callback->user);
+        ngx_memcache_post(&nw, *callback->key, *callback->value,
+                            /* pool */ NULL, log);
+        } else if(w->response_code == mcres_failure_input) {
+            ngx_log_error (NGX_LOG_ERR, log, 0,
+                       "throttle deny since the user name %V is invalid",
+                       callback->user);
+            callback->on_deny(callback);
+        } else { /* mcres_failure_unavailable */
+            if (check_only) {
+                ngx_log_error (NGX_LOG_ERR, log, 0,
+                    "throttle allowing access from user %V because "
+                    "memcache service is unavailable when try to "
+                    "get user counter", callback->user);
+            } else {
+                ngx_log_error (NGX_LOG_ERR, log, 0,
+                    "throttle allowing access from user %V because "
+                    "memcache service is unavailable when try to "
+                    "increment user counter", callback->user);
+            }
+        callback->on_allow(callback);
+    }
+}
+
+/* add a throttle counter for a user, here user might be an alias or a fqn */
+static void ngx_mail_throttle_user_add
+    (ngx_str_t *user, throttle_callback_t *callback)
+{
+    ngx_pool_t             *pool    = callback->pool;
+    ngx_log_t              *log     = callback->log;
+    ngx_mail_session_t     *s       = callback->session;
+    ngx_mail_throttle_srv_conf_t *tscf;
+    mc_work_t               w;
+    ngx_str_t               k;
+    ngx_str_t              *value, *key;
+
+    ngx_log_error (NGX_LOG_INFO, log, 0, "create a throttle counter for user %V", user);
+    w.ctx = callback;
+    w.request_code = mcreq_add;
+    w.response_code = mcres_unknown;
+    w.on_success = ngx_mail_throttle_user_add_success_handler;
+    w.on_failure = ngx_mail_throttle_user_add_failure_handler;
+
+    k = ngx_mail_throttle_get_user_throttle_key(pool, log, *user);
+    if (k.len == 0) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "allowing user %V login because of internal error "
+            "in user throttle control (generate key for add)", user);
+        callback->on_allow(callback);
+        return;
+    }
+
+    key = ngx_pstrcpy (pool, &k);
+    if (key == NULL) {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "allowing user %V login because of internal error "
+            "in user throttle control (deep copy key for add)", user);
+        callback->on_allow(callback);
+        return;
+    }
+
+    tscf = ngx_mail_get_module_srv_conf (s, ngx_mail_throttle_module);
+
+    value = ngx_palloc (pool, sizeof(ngx_str_t));
+    if (value == NULL) {
+       ngx_log_error (NGX_LOG_ERR, log, 0,
+               "allowing user %V login because of internal error"
+               "in user throttle control (alloc mem for add value)", user);
+       callback->on_allow(callback);
+       return;
+    }
+
+    ngx_str_set(value, "1");
+
+    callback->key = key;
+    callback->value = value;
+    callback->user = user;
+    callback->ttl = &tscf->mail_login_user_ttl_text;
+
+    ngx_memcache_post_with_ttl(&w, *key, *value, tscf->mail_login_user_ttl_text,
+            /* pool */ NULL, log);
+    return;
+}
+
+static void ngx_mail_throttle_user_add_success_handler(mc_work_t *w)
+{
+    throttle_callback_t *callback = w->ctx;
+    ngx_log_t           *log = callback->log;
+
+    /* counter addition succeeded */
+    ngx_log_error (NGX_LOG_INFO, log, 0,
+        "throttle allowing access from user %V, counter created",
+        callback->user);
+    callback->on_allow(callback);
+}
+
+/* memcache error handler (connection error or memory allocation error) */
+static void ngx_mail_throttle_user_add_failure_handler (mc_work_t *w)
+{
+    throttle_callback_t  *callback = w->ctx;
+    ngx_log_t            *log = callback->log;
+
+    if (w->response_code == mcres_failure_normal) {
+        /* Counter creation failed because of getting "NOT_STORED". This could
+         * occur when more than one processes try to login and post "incr"
+         * and all get "NOT_FOUND", and then try to add new counter. One of
+         * them will get "STORED" and others will reach here. In some other
+         * extreme cases, such as the ttl is very short, or some mis-handling
+         * of memcache, this case may also happen. Considering the little
+         * probability and the endurable inaccuracy, just ignore it.
+         */
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+            "allowing user %V login because unable to create the "
+            "user counter", callback->user);
+        callback->on_allow(callback);
+
+    } else if (w->response_code == mcres_failure_again) {
+        mc_work_t nw;
+        nw.ctx = callback;
+        nw.request_code = mcreq_add;
+        nw.response_code = mcres_unknown;
+        nw.on_success = ngx_mail_throttle_user_add_success_handler;
+        nw.on_failure = ngx_mail_throttle_user_add_failure_handler;
+        ngx_log_error (NGX_LOG_NOTICE, log, 0,
+                "retry to check user throttle:%V", callback->user);
+        ngx_memcache_post_with_ttl(&nw, *callback->key, *callback->value,
+                            *callback->ttl, /* pool */ NULL, log);
+    } else {
+        ngx_log_error (NGX_LOG_ERR, log, 0,
+            "throttle allowing access from ip %V because "
+            "memcache service is unavailable when try to "
+            "create user counter", callback->user);
+        callback->on_allow(callback);
+    }
+}
+
+static ngx_str_t
+ngx_mail_throttle_get_user_throttle_key (
+    ngx_pool_t      *pool,
+    ngx_log_t       *log,
+    ngx_str_t        user
+)
+{
+    ngx_str_t       k;
+    u_char         *p;
+    size_t          l;
+    uintptr_t       escape;
+
+    escape = 2 * ngx_escape_uri(NULL, user.data, user.len,
+            NGX_ESCAPE_MEMCACHED);
+
+    l = sizeof("throttle:") - 1 +
+        sizeof("user=") - 1 +
+        user.len + escape;
+
+    k.data = ngx_palloc(pool, l);
+    if (k.data == NULL)
+    {
+        k.len = 0;
+        return k;
+    }
+
+    p = k.data;
+    p = ngx_cpymem(p, "throttle:", sizeof("throttle:") - 1);
+    p = ngx_cpymem(p, "user=", sizeof("user=") - 1);
+
+    if (escape == 0) {
+        p = ngx_cpymem(p, user.data, user.len);
+    } else {
+        p = (u_char *)ngx_escape_uri(p, user.data, user.len,
+                NGX_ESCAPE_MEMCACHED);
+    }
+
+    k.len = p - k.data;
+
+    return k;
+}
+
+static char *
+ngx_encode_protocol (
+    ngx_uint_t protocol,
+    char eptype			/* s=short, l (or anything else)=long */
+)
+{
+    switch (protocol) {
+        case NGX_MAIL_POP3_PROTOCOL:
+            return eptype == 's' ? "p" : "pop3";
+        case NGX_MAIL_IMAP_PROTOCOL:
+            return eptype == 's' ? "i" : "imap";
+        case NGX_MAIL_SMTP_PROTOCOL:
+            return eptype == 's' ? "s" : "smtp";
+        default:
+            return eptype = 's' ? "u" : "unknown";
+    }
+}
+
+
+static ngx_str_t
+ngx_mail_throttle_get_ip_throttle_key (
+    ngx_pool_t      *pool,
+    ngx_log_t       *log,
+    ngx_str_t        ip,
+    ngx_uint_t	     protocol
+)
+{
+    ngx_str_t   k;
+    size_t      l;
+    u_char     *p;
+
+    l = sizeof("throttle:") - 1 +
+        sizeof("proto=") - 1 +
+        1 +
+        sizeof(",ip=") - 1 +
+        ip.len;
+
+    k.data = ngx_palloc(pool, l);
+    if (k.data == NULL)
+    {
+        k.len = 0;
+        return k;
+    }
+
+    p = k.data;
+    p = ngx_cpymem(p, "throttle:", sizeof("throttle:") - 1);
+    p = ngx_cpymem(p, "proto=", sizeof("proto=") - 1);
+    p = ngx_cpymem(p, ngx_encode_protocol(protocol, 's'), 1);
+    p = ngx_cpymem(p, ",ip=", sizeof(",ip=") - 1);
+    p = ngx_cpymem(p, ip.data, ip.len);
+
+    k.len = p - k.data;
+
+    return k;
+}
+
+static ngx_str_t
+ngx_mail_throttle_get_ip_whitelist_key (
+    ngx_pool_t      *pool,
+    ngx_log_t       *log,
+    ngx_str_t        ip
+)
+{
+    ngx_str_t   k;
+    size_t      l;
+    u_char     *p;
+
+    l = sizeof("whitelist:") - 1 +
+        sizeof("ip=") - 1 +
+        ip.len;
+
+    k.data = ngx_palloc(pool, l);
+    if (k.data == NULL)
+    {
+        k.len = 0;
+        return k;
+    }
+
+    p = k.data;
+    p = ngx_cpymem(p, "whitelist:", sizeof("whitelist:") - 1);
+    p = ngx_cpymem(p, "ip=", sizeof("ip=") - 1);
+    p = ngx_cpymem(p, ip.data, ip.len);
+
+    k.len = p - k.data;
+
+    return k;
+}
diff --git a/src/mail/ngx_mail_throttle_module.h b/src/mail/ngx_mail_throttle_module.h
new file mode 100644
index 000000000..90d2dadb5
--- /dev/null
+++ b/src/mail/ngx_mail_throttle_module.h
@@ -0,0 +1,80 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#ifndef _NGX_MAIL_THROTTLE_H_INCLUDED_
+#define _NGX_MAIL_THROTTLE_H_INCLUDED_
+
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_mail.h>
+#include <ngx_memcache.h>
+
+struct ngx_mail_throttle_srv_conf_s {
+    ngx_uint_t   mail_login_ip_max;
+    ngx_msec_t   mail_login_ip_ttl;
+    ngx_str_t    mail_login_ip_ttl_text;
+    ngx_str_t    mail_login_ip_imap_ttl_text;
+    ngx_str_t    mail_login_ip_pop3_ttl_text;
+    ngx_str_t    mail_login_ip_rejectmsg;
+    ngx_uint_t   mail_login_user_max;
+    ngx_msec_t   mail_login_user_ttl;
+    ngx_str_t    mail_login_user_ttl_text;
+    ngx_str_t    mail_login_user_rejectmsg;
+    ngx_uint_t   mail_login_ip_imap_max;
+    ngx_msec_t   mail_login_ip_imap_ttl;
+    ngx_uint_t   mail_login_ip_pop3_max;
+    ngx_msec_t   mail_login_ip_pop3_ttl;
+    ngx_array_t *mail_throttle_whitelist_ips;     /* array of ngx_cidr_t */
+    time_t       mail_whitelist_ip_ttl;
+    ngx_str_t    mail_whitelist_ip_ttl_text;
+};
+typedef struct ngx_mail_throttle_srv_conf_s ngx_mail_throttle_srv_conf_t;
+
+struct throttle_callback_s;
+typedef void (*throttle_handler_pt) (struct throttle_callback_s*);
+typedef void * throttle_ctx_t;
+
+struct throttle_callback_s {
+    ngx_flag_t              check_only; /* whether just check the counter or increment it */
+    ngx_mail_session_t     *session; /* current mail session */
+    ngx_connection_t       *connection; /* current connection */
+    ngx_event_t            *rev;    /* current read event */
+    void                   *config; /* pointer to a configuration */
+    ngx_log_t              *log;
+    ngx_pool_t             *pool;
+    throttle_handler_pt     on_allow; /* handler for allow access */
+    throttle_handler_pt     on_deny;  /* handler for deny access */
+
+    /* the following fields are used internally by throttle control */
+    ngx_str_t              *user;           /* user name used by user throttle control */
+    ngx_str_t              *ip;             /* ip address used by ip throttle control */
+    ngx_str_t              *value;          /* the value for re-post memcache request */
+    ngx_str_t              *key;            /* the key for re-post memcache request */
+    ngx_str_t              *ttl;            /* the ttl value for re-post memcache request */
+    ngx_str_t              *wl_key;         /* key for whitelist IP memcache add */
+    ngx_uint_t              is_whitelisted; /* used by whitelist IP memcache callback */
+};
+
+typedef struct throttle_callback_s throttle_callback_t;
+
+ngx_flag_t ngx_mail_throttle_init (ngx_mail_core_srv_conf_t *cscf);
+void ngx_mail_throttle_ip (ngx_str_t ip, throttle_callback_t *callback);
+void ngx_mail_throttle_whitelist_ip (ngx_str_t ip, throttle_callback_t *callback);
+void ngx_mail_throttle_user (ngx_str_t user, throttle_callback_t *callback);
+ngx_uint_t ngx_mail_throttle_ip_max_for_protocol (ngx_mail_throttle_srv_conf_t *tscf, ngx_uint_t protocol);
+
+extern ngx_module_t ngx_mail_throttle_module;
+
+#endif
diff --git a/src/mail/ngx_mail_zmauth_module.c b/src/mail/ngx_mail_zmauth_module.c
new file mode 100644
index 000000000..3f5189f1e
--- /dev/null
+++ b/src/mail/ngx_mail_zmauth_module.c
@@ -0,0 +1,561 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#include <ngx_config.h>
+#include <ngx_mail.h>
+#include <ngx_mail_zmauth_module.h>
+#include <ngx_zm_lookup.h>
+
+typedef void (*ngx_mail_zmauth_handler_pt)(ngx_mail_session_t *s,
+    ngx_mail_zmauth_ctx_t *ctx);
+
+struct ngx_mail_zmauth_ctx_s {
+    ngx_zm_lookup_work_t      *work;
+    ngx_event_t               *wait_ev;
+    ngx_pool_t                *pool;
+    ngx_str_t                  errmsg; //TODO necessary?
+};
+
+static void ngx_mail_zmauth_wait_handler(ngx_event_t *ev);
+static ngx_int_t ngx_mail_zmauth_escape(ngx_pool_t *pool, ngx_str_t *text,
+        ngx_str_t *escaped);
+static void ngx_mail_zmauth_unescape(ngx_str_t *text);
+static void ngx_mail_zmauth_lookup_result_handler(ngx_zm_lookup_work_t * work);
+
+static void *ngx_mail_zmauth_create_conf(ngx_conf_t *cf);
+static char *ngx_mail_zmauth_merge_conf(ngx_conf_t *cf, void *parent,
+        void *child);
+static char * ngx_mail_zm_auth_http(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+
+static void ngx_mail_zmauth_block_read(ngx_event_t *ev);
+static void ngx_mail_zmauth_cleanup(void * data);
+
+static ngx_command_t ngx_mail_zmauth_module_commands[] = {
+    { ngx_string("zm_auth_http"),
+      NGX_MAIL_MAIN_CONF | NGX_MAIL_SRV_CONF | NGX_CONF_NOARGS,
+      ngx_mail_zm_auth_http,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+     ngx_null_command
+};
+
+static ngx_mail_module_t ngx_mail_zmauth_module_ctx = {
+     NULL,                            /* protocol */
+     NULL,                            /* create main configuration */
+     NULL,                            /* init main configuration */
+     ngx_mail_zmauth_create_conf,     /* create server configuration */
+     ngx_mail_zmauth_merge_conf       /* merge server configuration */
+};
+
+ngx_module_t ngx_mail_zmauth_module = {
+     NGX_MODULE_V1,
+     &ngx_mail_zmauth_module_ctx,     /* module context */
+     ngx_mail_zmauth_module_commands, /* module directives */
+     NGX_MAIL_MODULE,                 /* module type */
+     NULL,                            /* init master */
+     NULL,                            /* init module */
+     NULL,                            /* init process */
+     NULL,                            /* init thread */
+     NULL,                            /* exit thread */
+     NULL,                            /* exit process */
+     NULL,                            /* exit master */
+     NGX_MODULE_V1_PADDING
+};
+
+static ngx_str_t ngx_mail_zmauth_proto[] = { ngx_string("pop3"), ngx_string("imap"),
+        ngx_string("smtp") };
+
+/* the methods order must follow the macro definition of NGX_MAIL_AUTH_XXXX in mail.h */
+static ngx_str_t ngx_mail_zmauth_method[] = {
+        ngx_string("plain"),    /* NGX_MAIL_AUTH_PLAIN */
+        ngx_string("login"),    /* NGX_MAIL_AUTH_LOGIN */
+        ngx_string("login"),    /* NGX_MAIL_AUTH_LOGIN_USERNAME */
+        ngx_string("apop"),     /* NGX_MAIL_AUTH_APOP */
+        ngx_string("cram-md5"), /* NGX_MAIL_AUTH_CRAM_MD5 */
+        ngx_string("none"),     /* NOT TAKE AUTH */
+        ngx_string("passwd"),   /* NGX_MAIL_AUTH_PASSWD */
+        ngx_string("plain"),    /* NGX_MAIL_AUTH_PLAIN_IR */
+        ngx_string("gssapi"),   /* NGX_MAIL_AUTH_GSSAPI */
+        ngx_string("gssapi")    /* NGX_MAIL_AUTH_GSSAPI_IR */
+};
+
+static ngx_str_t LOGIN_FAILED = ngx_string("LOGIN failed");
+static ngx_str_t AUTHENTICATE_FAILED = ngx_string("AUTHENTICATE failed");
+static ngx_str_t AUTHENTICATION_FAILED = ngx_string("authentication failed: ");
+
+void
+ngx_mail_zmauth_init(ngx_mail_session_t *s) {
+    ngx_pool_t *pool;
+    ngx_mail_zmauth_ctx_t    *ctx;
+    ngx_zm_lookup_work_t     *work;
+    ngx_str_t                 escaped_login, escaped_account_name;
+    ngx_mail_cleanup_t       *cln;
+    ngx_flag_t                proxy_ssl;
+
+    s->connection->log->action = "in mail zmauth state";
+
+    /* create pool and module context */
+    pool = ngx_create_pool(2048, s->connection->log);
+    if (pool == NULL) {
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    ctx = ngx_pcalloc(pool, sizeof(ngx_mail_zmauth_ctx_t));
+    if (ctx == NULL) {
+        ngx_destroy_pool(pool);
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    ctx->pool = pool;
+    ngx_mail_set_ctx(s, ctx, ngx_mail_zmauth_module);
+
+    /* init clean up */
+    cln = ngx_mail_cleanup_add(s, 0);
+    cln->data = s;
+    cln->handler = ngx_mail_zmauth_cleanup;
+
+    /* init wait event */
+    ctx->wait_ev = ngx_palloc(pool, sizeof(ngx_event_t));
+    if (ctx->wait_ev == NULL) {
+        ngx_destroy_pool(pool);
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+    ngx_memzero (ctx->wait_ev, sizeof (ngx_event_t));
+    ctx->wait_ev->handler = ngx_mail_zmauth_wait_handler;
+    ctx->wait_ev->log = s->connection->log;
+    ctx->wait_ev->data = s->connection;
+
+    work = ngx_pcalloc(pool, sizeof(ngx_zm_lookup_work_t));
+    if (work == NULL) {
+        ngx_destroy_pool(pool);
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    if (s->auth_method == NGX_MAIL_AUTH_PASSWD    ||
+        s->auth_method == NGX_MAIL_AUTH_PLAIN     ||
+        s->auth_method == NGX_MAIL_AUTH_PLAIN_IR  ||
+        s->auth_method == NGX_MAIL_AUTH_LOGIN     ||
+        s->auth_method == NGX_MAIL_AUTH_LOGIN_USERNAME) {
+        work->auth_method = ZM_AUTHMETH_USERNAME;
+    } else if (s->auth_method == NGX_MAIL_AUTH_GSSAPI ||
+               s->auth_method == NGX_MAIL_AUTH_GSSAPI_IR) {
+        work->auth_method = ZM_AUTHMETH_GSSAPI;
+        work->auth_id = s->authid;
+    } else {
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                "unsupported auth method %V",
+                &ngx_mail_zmauth_method[s->auth_method]);
+        ngx_destroy_pool(pool);
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    proxy_ssl = ngx_mail_get_proxy_ssl(s);
+
+    switch (s->protocol) {
+    case NGX_MAIL_POP3_PROTOCOL:
+        work->protocol = proxy_ssl?ZM_PROTO_POP3S:ZM_PROTO_POP3;
+        break;
+    case NGX_MAIL_IMAP_PROTOCOL:
+        work->protocol = proxy_ssl?ZM_PROTO_IMAPS:ZM_PROTO_IMAP;
+        break;
+    default:
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                "unsupported auth protocol %V",
+                &ngx_mail_zmauth_proto[s->protocol]);
+        ngx_destroy_pool(pool);
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    if (ngx_mail_zmauth_escape(pool, &s->login, &escaped_login) != NGX_OK) {
+        ngx_destroy_pool(pool);
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+    work->username = escaped_login;
+
+    work->connection = s->connection;
+    work->login_attempts = s->login_attempt;
+    work->log = s->connection->log;
+    work->pool = s->connection->pool;
+    work->data = s;
+    work->on_success = ngx_mail_zmauth_lookup_result_handler;
+    work->on_failure = ngx_mail_zmauth_lookup_result_handler;
+
+    switch (s->vlogin) {
+    case 0:
+        work->alias_check_stat = ZM_ALIAS_NOT_CHECKED;
+        break;
+    case 1:
+        work->alias_check_stat = ZM_ALIAS_NOT_FOUND;
+        work->account_name = work->username;
+        work->alias_key = s->key_alias;
+        break;
+    case 2:
+        work->alias_check_stat = ZM_ALIAS_FOUND;
+        if (ngx_mail_zmauth_escape(pool, &s->qlogin,
+                                   &escaped_account_name) != NGX_OK) {
+            ngx_destroy_pool(pool);
+            ngx_mail_session_internal_server_error(s);
+            return;
+        }
+        work->account_name = escaped_account_name;
+        work->alias_key = s->key_alias;
+        break;
+    default:
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                "Should never reach here");
+        return;
+    }
+
+    ctx->work = work;
+
+    s->connection->read->handler = ngx_mail_zmauth_block_read;
+
+    ngx_zm_lookup(work);
+}
+
+static void
+ngx_mail_zmauth_wait_handler(ngx_event_t *ev) {
+    ngx_connection_t *c;
+    ngx_mail_session_t *s;
+    ngx_mail_zmauth_ctx_t *ctx;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, ev->log, 0, "mail zmauth wait handler");
+
+    c = ev->data;
+    s = c->data;
+    ctx = ngx_mail_get_module_ctx(s, ngx_mail_zmauth_module);
+
+    if (ev->timedout) {
+        /* we need to close the connection immediately */
+
+        ngx_destroy_pool(ctx->pool);
+        ngx_mail_set_ctx(s, NULL, ngx_mail_zmauth_module);
+        s->quit = 1;
+        ngx_mail_send(c->write);
+
+        return;
+    }
+
+    if (ev->active) {
+        if (ngx_handle_read_event(ev, 0) != NGX_OK) {
+            ngx_mail_close_connection(c);
+        }
+    }
+}
+
+static void
+ngx_mail_zmauth_cleanup (void * data)
+{
+    ngx_mail_session_t * s;
+    ngx_mail_zmauth_ctx_t * ctx;
+    s = (ngx_mail_session_t *)data;
+    ctx = ngx_mail_get_module_ctx(s, ngx_mail_zmauth_module);
+    if (ctx != NULL) {
+        ngx_zm_lookup_finalize(ctx->work);
+        ngx_destroy_pool(ctx->pool);
+        ngx_mail_set_ctx(s, NULL, ngx_mail_zmauth_module);
+    }
+}
+
+static ngx_int_t
+ngx_mail_zmauth_escape(ngx_pool_t *pool, ngx_str_t *text,
+        ngx_str_t *escaped) {
+    u_char *p;
+    uintptr_t n;
+
+    n = ngx_escape_uri(NULL, text->data, text->len, NGX_ESCAPE_MAIL_AUTH);
+
+    if (n == 0) {
+        *escaped = *text;
+        return NGX_OK;
+    }
+
+    escaped->len = text->len + n * 2;
+
+    p = ngx_pnalloc(pool, escaped->len);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    (void) ngx_escape_uri(p, text->data, text->len, NGX_ESCAPE_MAIL_AUTH);
+
+    escaped->data = p;
+
+    return NGX_OK;
+}
+
+/* text will be modified */
+static void
+ngx_mail_zmauth_unescape(ngx_str_t *text) {
+    u_char       *src, *dst;
+    size_t        len;
+
+    src = text->data;
+    dst = text->data;
+
+    ngx_unescape_uri(&dst, &src, text->len, NGX_UNESCAPE_URI);
+
+    len = (text->data + text->len) - src;
+    if (len) {
+        dst = ngx_copy(dst, src, len);
+    }
+
+    text->len = dst - text->data;
+}
+
+static void *
+ngx_mail_zmauth_create_conf(ngx_conf_t *cf) {
+    ngx_mail_zmauth_conf_t *zmcf;
+
+    zmcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_zmauth_conf_t));
+    if (zmcf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    zmcf->use_zmauth = NGX_CONF_UNSET;
+
+    return zmcf;
+}
+
+static char *
+ngx_mail_zmauth_merge_conf(ngx_conf_t *cf, void *parent, void *child) {
+    ngx_mail_zmauth_conf_t *prev = parent;
+    ngx_mail_zmauth_conf_t *conf = child;
+
+    ngx_conf_merge_value(conf->use_zmauth, prev->use_zmauth, 0);
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_mail_zm_auth_http(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
+    ngx_mail_zmauth_conf_t *zmcf = conf;
+    zmcf->use_zmauth = 1;
+
+    return NGX_CONF_OK;
+}
+
+static void
+ngx_mail_zmauth_lookup_result_handler(ngx_zm_lookup_work_t * work) {
+    ngx_mail_session_t     *s;
+    ngx_mail_zmauth_ctx_t  *ctx;
+    size_t                  size;
+    u_char                 *p;
+    ngx_addr_t             *peer;
+    ngx_str_t               errmsg;
+
+    s = (ngx_mail_session_t *) work->data;
+    ctx = (ngx_mail_zmauth_ctx_t *)ngx_mail_get_module_ctx(s, ngx_mail_zmauth_module);
+
+    if (work->result == ZM_LOOKUP_SUCCESS) {
+        ngx_mail_zmauth_unescape(&work->account_name);
+
+        /* copy the lookup result from zmauth pool to s->connection pool */
+        s->qlogin = *(ngx_pstrcpy(s->connection->pool, &work->account_name));
+        s->key_alias = *(ngx_pstrcpy(s->connection->pool, &work->alias_key));
+        s->key_route = *(ngx_pstrcpy(s->connection->pool, &work->route_key));
+        if (s->auth_method == NGX_MAIL_AUTH_GSSAPI ||
+            s->auth_method == NGX_MAIL_AUTH_GSSAPI_IR) {
+            s->dusr = *(ngx_pstrcpy(s->connection->pool, &work->auth_id));
+            s->dpasswd = *(ngx_pstrcpy(s->connection->pool, &work->zm_auth_token));
+        }
+        peer = ngx_palloc(s->connection->pool, sizeof(ngx_addr_t));
+
+        peer->name = *(ngx_pstrcpy(s->connection->pool, &work->route->name));
+        peer->socklen = work->route->socklen;
+        peer->sockaddr = ngx_palloc(s->connection->pool, peer->socklen);
+        if(peer->sockaddr == NULL) {
+            return; /* NO MEM */
+        }
+        ngx_memcpy(peer->sockaddr, work->route->sockaddr, peer->socklen);
+
+        switch (work->alias_check_stat) {
+           case ZM_ALIAS_NOT_FOUND:
+               s->vlogin = 1;
+               break;
+           case ZM_ALIAS_FOUND:
+               s->vlogin = 2;
+               break;
+           default:
+               break;
+               /* do nothing */
+           }
+
+        ngx_destroy_pool(ctx->pool);
+        ngx_mail_set_ctx(s, NULL, ngx_mail_zmauth_module);
+        ngx_mail_proxy_init(s, peer);
+        return;
+    } else {
+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                      "An error occurred in mail zmauth: %V",
+                       &work->err);
+
+        /* construct error msg */
+        if (work->result != ZM_LOOKUP_LOGIN_FAILED) {
+            /* zmauth clean up will destroy the ctx->pool */
+            ngx_mail_session_internal_server_error(s);
+            return;
+        }
+
+        errmsg = LOGIN_FAILED; /* should we return the real err msg to user? */
+
+        switch (s->protocol) {
+
+        case NGX_MAIL_POP3_PROTOCOL:
+            size = sizeof("-ERR ") - 1 + errmsg.len + sizeof(CRLF) - 1;
+            if (s->command == NGX_POP3_AUTH) {
+                size +=  AUTHENTICATION_FAILED.len;
+            }
+            break;
+
+        case NGX_MAIL_IMAP_PROTOCOL:
+            if (s->command == NGX_IMAP_AUTHENTICATE) {
+                errmsg = AUTHENTICATE_FAILED;
+            }
+            size = s->tag.len + 1 /*for space*/+ sizeof("NO ") - 1 + errmsg.len
+                   + sizeof(CRLF) - 1;
+            break;
+
+        default: /* NGX_MAIL_SMTP_PROTOCOL */
+            ngx_log_error(NGX_LOG_CRIT, s->connection->log, 0, "smtp is not supported!!");
+            return;
+        }
+
+        p = ngx_pnalloc(s->connection->pool, size);
+        if (p == NULL) {
+            ngx_destroy_pool(ctx->pool);
+            ngx_mail_session_internal_server_error(s);
+            return;
+        }
+
+        ctx->errmsg.data = p;
+
+        switch (s->protocol) {
+
+        case NGX_MAIL_POP3_PROTOCOL:
+            *p++ = '-'; *p++ = 'E'; *p++ = 'R'; *p++ = 'R'; *p++ = ' ';
+            if (s->command == NGX_POP3_AUTH) {
+                p = ngx_cpymem(p, AUTHENTICATION_FAILED.data, AUTHENTICATION_FAILED.len);
+            }
+            break;
+
+        case NGX_MAIL_IMAP_PROTOCOL:
+            p = ngx_cpymem(p, s->tag.data, s->tag.len);
+            *p++ = ' '; *p++ = 'N'; *p++ = 'O'; *p++ = ' ';
+            break;
+
+        default: /* NGX_MAIL_SMTP_PROTOCOL */
+            break;
+        }
+
+        p = ngx_cpymem(p, errmsg.data, errmsg.len);
+        *p++ = CR; *p++ = LF;
+
+        ctx->errmsg.len = p - ctx->errmsg.data;
+        s->out = ctx->errmsg;
+
+        if (work->result == ZM_LOOKUP_LOGIN_FAILED && work->wait_time >= 0) {
+            ngx_add_timer(ctx->wait_ev, (ngx_msec_t) (work->wait_time * 1000));
+
+            s->connection->read->handler = ngx_mail_zmauth_block_read;
+        } else {
+            s->quit = 1;
+            ngx_mail_send(s->connection->write);
+            ngx_mail_set_ctx(s, NULL, ngx_mail_zmauth_module);
+            ngx_destroy_pool(ctx->pool);
+        }
+        return;
+    }
+}
+
+static void
+ngx_mail_zmauth_block_read(ngx_event_t *ev)
+{
+    ngx_connection_t          *c;
+    ngx_mail_session_t        *s;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, ev->log, 0,
+                   "mail zmauth block read");
+
+    if (ngx_handle_read_event(ev, 0) != NGX_OK) {
+        c = ev->data;
+        s = c->data;
+
+        ngx_mail_session_internal_server_error(s);
+    }
+}
+
+/* Utility function to check if a (login) name has the zimbra
+   supported `special' extensions
+   The test is to see if the name ends with /tb, /wm, or /ni
+   tb = thunderbird
+   wm = windows mobile
+   ni = no idle
+ */
+ngx_flag_t
+has_zimbra_extensions (ngx_str_t login)
+{
+    ngx_flag_t  f = 0;
+
+    if ((login.len > 3) &&
+        (!ngx_memcmp (login.data + (login.len - 3), "/tb", 3) ||
+         !ngx_memcmp (login.data + (login.len - 3), "/wm", 3) ||
+         !ngx_memcmp (login.data + (login.len - 3), "/ni", 3)
+        )
+       ) {
+       f = 1;
+    }
+
+    return f;
+}
+
+/* Strip off any zimbra `special' extensions from a (login) name
+   Returns a shallow copy of the original name, with the length
+   shortened by 3 to strip off the trailing characters
+ */
+/* Never use this ngx_str_t
+strip_zimbra_extensions (ngx_str_t login)
+{
+    ngx_str_t   t = login;
+
+    if (has_zimbra_extensions (login)) {
+        t.len -= 3;
+    }
+
+    return t;
+} */
+
+ngx_str_t
+get_zimbra_extension (ngx_str_t login)
+{
+    ngx_str_t   e = ngx_string("");
+
+    if (has_zimbra_extensions(login)) {
+        e.data = login.data + (login.len - 3);
+        e.len = 3;
+    }
+
+    return e;
+}
diff --git a/src/mail/ngx_mail_zmauth_module.h b/src/mail/ngx_mail_zmauth_module.h
new file mode 100644
index 000000000..2d5c46bc4
--- /dev/null
+++ b/src/mail/ngx_mail_zmauth_module.h
@@ -0,0 +1,35 @@
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Zimbra Collaboration Suite Server
+ * Copyright (C) 2011 Zimbra Software, LLC.
+ *
+ * The contents of this file are subject to the Zimbra Public License
+ * Version 1.4 ("License"); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://www.zimbra.com/license.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
+ * ***** END LICENSE BLOCK *****
+ */
+
+#ifndef _NGX_MAIL_ZMAUTH_MODULE_H_INCLUDED_
+#define _NGX_MAIL_ZMAUTH_MODULE_H_INCLUDED_
+
+typedef struct ngx_mail_zmauth_ctx_s  ngx_mail_zmauth_ctx_t;
+
+typedef struct {
+    ngx_flag_t    use_zmauth;
+} ngx_mail_zmauth_conf_t;
+
+/* zmauth portal */
+void ngx_mail_zmauth_init(ngx_mail_session_t *s);
+
+/* utility */
+ngx_flag_t has_zimbra_extensions (ngx_str_t login);
+ngx_str_t strip_zimbra_extensions (ngx_str_t login);
+ngx_str_t get_zimbra_extension (ngx_str_t login);
+
+extern ngx_module_t ngx_mail_zmauth_module;
+
+#endif
diff --git a/src/os/unix/ngx_process_cycle.c b/src/os/unix/ngx_process_cycle.c
index 5817a2c23..3fd6bbcea 100644
--- a/src/os/unix/ngx_process_cycle.c
+++ b/src/os/unix/ngx_process_cycle.c
@@ -4,6 +4,10 @@
  * Copyright (C) Nginx, Inc.
  */
 
+/*
+ * Portions Copyright (c) Zimbra Software, LLC. [1998-2020]. All Rights Reserved.
+ */
+
 
 #include <ngx_config.h>
 #include <ngx_core.h>
@@ -84,6 +88,7 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)
     ngx_msec_t         delay;
     ngx_listening_t   *ls;
     ngx_core_conf_t   *ccf;
+    struct rlimit     rlmt;
 
     sigemptyset(&set);
     sigaddset(&set, SIGCHLD);
@@ -130,6 +135,53 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)
 
     ngx_start_worker_processes(cycle, ccf->worker_processes,
                                NGX_PROCESS_RESPAWN);
+    /* The directives such as "user", "rlimit_core", etc. should also be
+     * effective on master process. Changed by Zimbra
+     */
+    if (ccf->rlimit_nofile != NGX_CONF_UNSET) {
+        rlmt.rlim_cur = (rlim_t) ccf->rlimit_nofile;
+        rlmt.rlim_max = (rlim_t) ccf->rlimit_nofile;
+
+        if (setrlimit(RLIMIT_NOFILE, &rlmt) == -1) {
+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                          "setrlimit(RLIMIT_NOFILE, %i) failed",
+                          ccf->rlimit_nofile);
+        }
+    }
+
+    if (ccf->rlimit_core != NGX_CONF_UNSET) {
+        rlmt.rlim_cur = (rlim_t) ccf->rlimit_core;
+        rlmt.rlim_max = (rlim_t) ccf->rlimit_core;
+
+        if (setrlimit(RLIMIT_CORE, &rlmt) == -1) {
+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
+                          "setrlimit(RLIMIT_CORE, %O) failed",
+                          ccf->rlimit_core);
+        }
+    }
+
+    if (geteuid() == 0) {
+        if (setgid(ccf->group) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          "setgid(%d) failed", ccf->group);
+            /* fatal */
+            exit(2);
+        }
+
+        if (initgroups(ccf->username, ccf->group) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          "initgroups(%s, %d) failed",
+                          ccf->username, ccf->group);
+        }
+
+        if (setuid(ccf->user) == -1) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,
+                          "setuid(%d) failed", ccf->user);
+            /* fatal */
+            exit(2);
+        }
+    }
+    /* end change by Zimbra */
     ngx_start_cache_manager_processes(cycle, 0);
 
     ngx_new_binary = 0;
